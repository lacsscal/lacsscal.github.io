<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unix-Linux-Process-management</title>
      <link href="/2022/03/02/7.Unix-Linux-Process-management/"/>
      <url>/2022/03/02/7.Unix-Linux-Process-management/</url>
      
        <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、进程基础"><a href="#一、进程基础" class="headerlink" title="一、进程基础"></a>一、进程基础</h2><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0.概念"></a>0.概念</h3><blockquote><p>程序：静态文件，二进制指令和数据的集合，存储在磁盘中</p><p>进程：程序的动态执行过程，资源分配的基本单位(占CPU资源以执行程序指令，占存储资源以保存状态(数据段，代码段，堆…))，进程是处于执行器的程序和相关资源的总称。(同一份静态程序，可以启动多个不同进程).以进程的视角来看，它是独占CPU的，同时它也是独占内存空间的。以进程视角看到的内存空间称为虚拟内存空间。如下图所示。</p><p>[注]在内核态空间里面，与进程相关的数据结构是每个进程都不同的，物理存储器和内核代码数据是所有进程共享的。内核进程通常被成为内核线程，因为它们没有自己的独立地址空间，它们永远运行在内核态空间或者说它们本身就是内核的一部分。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%9B%B4%E7%BB%86%E5%8C%96%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.jpg" alt="更细化恶虚拟内存空间"></p><blockquote><p>Linux开机:(ROM中存有自举程序，计算机加电，CPU的PC置为自举程序的第一条指令，这个程序的唯一职责是把OS本身(至少是启动计算机的那部分)装入内存)主要关注进程的话，略过这些细节，在所有硬件配置好的情况下，<strong>这时bootloader程序会启动0号进程。0号进程会配置实时时钟，它的主要工作是启动1号进程(init,新版中被systemd取代)和2号进程(页面守护进程)</strong>,0号进程在启动完1号2号进程后终止(后面OS会再重启一个0号进程，但功能完全不同，它是idel空闲进程PID:0, 因为CPU总要选择一个进程运行，所以没活干的时候让CPU运行idel进程以省电。<strong>1号进程是其他所有用户进程的祖先, 2号进程是其他内核线程的祖先</strong>内核进程不占用户虚拟地址，也称做用户线程</p></blockquote><h3 id="1-一些库函数和系统调用"><a href="#1-一些库函数和系统调用" class="headerlink" title="1.一些库函数和系统调用"></a>1.一些库函数和系统调用</h3><p><code>GETPID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GETPPID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GETUID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GETEUID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GETGID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GETEGID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>在这些信息的基础上，要清晰一些概念，进程是动态的，当进程启动后，<strong>启动者的权限和属性</strong>以及程序的指令和数据会加载到内存中，为了方便普通用户定位进程，操作系统会为进程分配唯一正整数标识符PID，进程之间存在亲缘关系(pid, ppid)。为了方便内核进行进程的权限管理，默认进程拥有启动用户的身份(uid, gid)。<strong>内核对进程进行访问权限检查是，检查的是euid, egid</strong>默认与uid,gid相同。</p><p>下面用这些基础概念和系统调用探究一下<code>$passwd</code>的实现原理</p></blockquote><h3 id="2-passwd的实现原理与特殊权限管理"><a href="#2-passwd的实现原理与特殊权限管理" class="headerlink" title="2. $passwd的实现原理与特殊权限管理"></a>2. <code>$passwd</code>的实现原理与特殊权限管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scallacs@scallacs$ ll /etc/shadow </span><br><span class="line">-rw-r----- 1 root shadow 1.5K Feb 28 19:51 /etc/shadow</span><br></pre></td></tr></table></figure><blockquote><p>密码存在/etc/shadow 中，该文件的所有者为root,所属组为shadow，照这样用常规思路来想，用户在不是root或b不在shadow组的情况下是不能修改shadow的，甚至在shadow组中也只有读权限。</p><p>Q：那么：为什么普通用户使用passwd命令能成功修改密码?</p><p>A：显然普通用户在执行passwd时，获取了/etc/shadow的写权限，也就是说此时普通用户的euid是root。（前文讲到:内核对进程进行访问权限检查是，检查的是euid)。也就是说，存在这样一种机制，使得用户在运行某进程时修改自己的euid或egid.</p><p>Q：想一想还有没有类似的命令，运行时可以做到本身权限不能做到的事情</p><p>A：sudo</p><p>那么，获取一下这两个命令可执行文件的信息，看看有无什么特殊之处</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scallacs@scallacs$ <span class="built_in">which</span> sudo</span><br><span class="line">/usr/bin/sudo</span><br><span class="line">scallacs@scallacs$ ll /usr/bin/sudo</span><br><span class="line">-rwsr-xr-x 1 root root 146K Jan 19  2021 /usr/bin/sudo</span><br><span class="line">scallacs@scallacs$ ll /usr/bin/passwd  </span><br><span class="line">-rwsr-xr-x 1 root root 59K Jan 26 00:26 /usr/bin/passwd</span><br><span class="line">   |</span><br><span class="line">  s权限</span><br></pre></td></tr></table></figure><blockquote><p>它们都有s权限</p></blockquote><blockquote><p>文件的特殊权限：</p><p>在此前的9位普通权限的基础上，还有三位特殊权限，</p><p>针对所有者权限有SUID，用于在程序运行中修改自己的euid为文件所有者。</p><p>类似的针对所属组有SGID，用于修改自己的egid为文件所属组。</p><p>对于目录文件，可以使用sticky bit(SBIT)权限限制用户协同工作时的一些操作。比如/tmp</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxrwt  18 root root  12K Mar  2 20:28 tmp </span><br><span class="line">         |</span><br><span class="line">       sticky bit 对目录有写权限，但不能删除其他用户的文件</span><br></pre></td></tr></table></figure><p><code>应用举例：SUID SGID</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">A用户编写一个程序，用来往file文件中写入内容hello，然后编译后，增加s权限，这时B用户执行该程序，能够往file文件中写入hello。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./write file</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用户A执行</span><br><span class="line">scallacs@scallacs:~/test/$ ./write file</span><br><span class="line">scallacs@scallacs:~/test/$ cat file </span><br><span class="line">hello</span><br><span class="line">用户A为程序增加suid权限</span><br><span class="line">scallacs@scallacs:~/test/$ chmod u+s write</span><br><span class="line">scallacs@scallacs:~/test/$ ls -l write</span><br><span class="line">-rwsrwxr-x <span class="number">1</span> scallacs scallacs <span class="number">8496</span> Feb <span class="number">28</span> <span class="number">20</span>:<span class="number">23</span> write</span><br><span class="line">   |</span><br><span class="line">  所有者有s权限</span><br><span class="line">先把文件清空</span><br><span class="line">scallacs@scallacs:~/test/$ echo -n &gt; file </span><br><span class="line">    </span><br><span class="line">切到用户B 执行</span><br><span class="line">scallacs@scallacs:~/test/$ su test</span><br><span class="line">Password: </span><br><span class="line">[test@scallacs /home/scallacs/test/\[]$ ./write file</span><br></pre></td></tr></table></figure><h3 id="3-使用系统调用创建进程-由可执行程序启动多个进程"><a href="#3-使用系统调用创建进程-由可执行程序启动多个进程" class="headerlink" title="3.使用系统调用创建进程(由可执行程序启动多个进程)"></a>3.使用系统调用创建进程(由可执行程序启动多个进程)</h3><p><code>system(3)</code></p><blockquote><p>之前使用过这个库函数，它是可以执行系统命令的比如<code>system(&quot;cls&quot;);</code>，也就是说它启动了另外的进程，可以使用<code>ps</code>命令看一下。会发现它创建了3个进程，并且3个进程之间存在父子亲缘关系。那么它的原理是什么，man一下它的手册</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The  <span class="title">system</span><span class="params">()</span>  library  function  uses <span class="title">fork</span><span class="params">(<span class="number">2</span>)</span> to create a child process</span></span><br><span class="line"><span class="function">that executes the shell command specified in command <span class="keyword">using</span>  <span class="title">execl</span><span class="params">(<span class="number">3</span>)</span>  as follows:</span></span><br><span class="line"><span class="function">   <span class="title">execl</span><span class="params">(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, (<span class="keyword">char</span> *) <span class="number">0</span>)</span></span>;</span><br><span class="line">system() returns after the command has been completed.</span><br></pre></td></tr></table></figure><blockquote><p><code>system()</code> 使用 <code>fork()</code>和<code>execl()</code>实现</p></blockquote><p><code>fork(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>fork的原理(先引入几个概念)</p><p>中断：硬件发送信息给CPU，CPU通知OS处理中断事宜.</p><p>异常：类似中断的概念，进程主动给CPU发消息(软件中断)，在x86体系,系统调用利用软中断实现(这个软中断叫<strong>陷入</strong>)</p><p>[注]OS对中断和异常的处理流程是一致的，除了信息的来源不同。</p><p>中断的上半部 下半部….</p></blockquote><blockquote><p>通过 fork 创建的子进程，它从父进程继承了进程的地址空间，包括进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设定、进程优先级、进程组ID、当前工作目录、根目录、资源限制、控制终端，而子进程所独有的只有它的进程ID、资源使用和计时器等。</p><p>子进程与父进程是clone与被clone的关系，在这种情况下，子进程可能会<em>认为自己</em>是**调用fork()**的那个人，因此以返回值区分子进程与父进程，子进程返回0，父进程返回子进程的PID。这样，用一个选择结构就可以让父子进程执行不同的操作。</p></blockquote><p><code>fork的基本用法</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child, pid = %d, ppid = %d\n&quot;</span>,</span><br><span class="line">            getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent, pid = %d, ppid = %d\n&quot;</span>,</span><br><span class="line">            getpid(),getppid());</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>fork()的写时复制</p><p>当执行了 fork 了以后，父子进程地址空间的内容是完全一致，所以完全可以共享同一片物理内存，也就是父子进程的同一个虚拟地址会对应同一个物理内存字节。通常来说，内存的分配单位是页，我们可以为每一个内存页维持一个引用计数。代码段的部分因为只读，所以完全可以多个进程同时共享。而对于地址空间的其他部分，当进程对某个内存页进行写入操作的时候，我们再真正执行被修改的虚拟内存页分配物理内存并拷贝数据，这就是所谓的<strong>写时复制</strong>。在执行拷贝以后，同样的虚拟地址就无法对应同样物理内存字节了。如下图所示</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/fork%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png"></p><blockquote><p>fork()刚创建出子进程以及父子进程只进行读操作都不会影响物理内存，二者共享同一片物理内存即可，但一旦有写操作发生，未改变的进程就需要拷贝原物理页，并分配新的物理页。* Copy On Write.*</p><p>[注]内核态地址空间拷贝和用户态会有所区别。 fork 产生的子进程会拷贝一份文件描述符数组，但是通过文件描述符所指向的文件对象是共享的。这种拷贝方式类似于 dup 系统调用，所以父子进程对同一个文件对象会共享读写位置</p><p>共享文件对象&lt;=&gt;共享内核文件缓冲区的偏移</p></blockquote><p><code>关于共享文件对象的思考</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">程序一共输出多少个“-”</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">共打印<span class="number">8</span>个，<span class="built_in">printf</span>()格式串中没有\n 输出放到<span class="built_in">stdout</span>:行缓冲</span><br><span class="line">第一次循环fork创建一个子进程 父子进程<span class="built_in">stdout</span>中各有一个 <span class="string">&#x27;-&#x27;</span></span><br><span class="line">第二次循环各自创建一个子进程 一个四个进程用户空间信息一致，再执行<span class="built_in">printf</span>各自放入一个<span class="string">&#x27;-&#x27;</span></span><br><span class="line">程序结束 全部打印 一共<span class="number">8</span>个</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">把<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>)换成<span class="built_in">printf</span>(<span class="string">&quot;-\n&quot;</span>)；程序会输出多少个“-”?思考一下为什么？</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-\n&quot;</span>);<span class="comment">//共打印6个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">共打印<span class="number">6</span>个</span><br><span class="line">第一次循环fork创建一个子进程 父子进程各向<span class="built_in">stdout</span>输出一个 <span class="string">&#x27;-&#x27;</span>，然后<span class="built_in">stdout</span>空了</span><br><span class="line">第二次循环各自创建一个子进程 一个四个进程用户空间信息一致都是空的，再执行<span class="built_in">printf</span>各自输出一个<span class="string">&#x27;-&#x27;</span></span><br><span class="line">程序结束 全部打印 一共<span class="number">6</span>个</span><br></pre></td></tr></table></figure><p><code>execl(3)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>exec(execute)用在 fork 之后，将子进程的指令部分进行替换修改。当进程执行到 exec* 系统调用的时候，它会将传入的指令来取代进程本身的代码段、数据段、栈和堆，然后将PC指针重置为新的代码段的入口。</p></blockquote><p><code>示例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过execl拉起来一个进程，传递两个数字，比如15和65。被拉起的进程创建一个随机数，该随机数的范围在15-65之间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    execl(<span class="string">&quot;random&quot;</span>, <span class="string">&quot;./random&quot;</span>, <span class="string">&quot;15&quot;</span>, <span class="string">&quot;56&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个随机数，该随机数的范围在15-65之间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./add 15 56</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> lhs = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> rhs = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> rand = random()%(rhs - lhs + <span class="number">1</span>);</span><br><span class="line">    rand += lhs;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the random num = %d\n&quot;</span>, rand);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>使用fork 与execl实现system</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个mysystem程序，实现跟system函数类似的功能（只需要创建一个子进程）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySystem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//解析command 以space分割</span></span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> *args[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, command); </span><br><span class="line">        <span class="comment">// puts(str);</span></span><br><span class="line">        <span class="keyword">char</span> *word = strtok(str, <span class="string">&quot; &quot;</span>); </span><br><span class="line">        <span class="comment">// puts(word); </span></span><br><span class="line">        args[<span class="number">0</span>] = word;<span class="comment">//之前试图用strcpy函数写，写不进去? 遇到没显示的地方可能是访问空指针导致段错误了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((word = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// puts(word);</span></span><br><span class="line">            args[i] = word;<span class="comment">//操作数组小心越界问题 对于子进程的gdb调试方法 set follow-fork-mode child</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// execl(&quot;random&quot;, &quot;./random&quot;, &quot;15&quot;, &quot;56&quot;, NULL);</span></span><br><span class="line">        execv(<span class="string">&quot;random&quot;</span>, args);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system(&quot;./random 15 56&quot;); //传进一个命令，起一个shell，执行它</span></span><br><span class="line">    mySystem(<span class="string">&quot;./random 15 56&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WAIT(2)</code></p><blockquote><p>进程结束后的资源回收问题 : 真正回收资源的系统调用</p><p>而由资源回收问题会引出–孤儿进程， 僵尸进程等概念</p><p>子进程资源一定由父进程回收，若是父进程在子进程终止前终止，此时的子进程是孤儿进程 <code>orphan</code>， 当子进程终止，父进程正忙，无法帮助子进程回收资源，或父进程一直没执行<code>wait</code>，此时子进程是僵尸进程</p><p>…….</p></blockquote><p><code>一堆多进程管理的概念........</code></p><h2 id="二、进程间通信-IPC-Inter-Process-Communication"><a href="#二、进程间通信-IPC-Inter-Process-Communication" class="headerlink" title="二、进程间通信 IPC:Inter Process Communication"></a>二、进程间通信 IPC:Inter Process Communication</h2><blockquote><p>分别从几种进程间通信机制总结，每个机制可能搭配几个相关函数或系统调用的手册信息和一个或几个小例程，分析一下各种机制的特点。</p></blockquote><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><blockquote><p>之前用过命令创建的有名管道, 也能在程序中创建管道。在<code>fork()</code>的基础上还能使用匿名管道。</p></blockquote><p><code>POPEN(3) PCLOSE(3)</code>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line">                         |</span><br><span class="line">                     底层实现是fork()+exec()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">用的不多，意义不大, fork+匿名管道pipe可能更常用一点</span><br></pre></td></tr></table></figure><p><code>PIPE(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line">                 |</span><br><span class="line">               传参时退化为指针，主要是提示去传入长度为<span class="number">2</span>的数组，这个数组会保存文件描述符返回，由此可操纵匿名管道</span><br><span class="line">The <span class="built_in">array</span> pipefd is used to <span class="keyword">return</span> two file descriptors referring to the ends of the pipe.</span><br><span class="line">pipefd[<span class="number">0</span>] refers to the read end of the pipe.  pipefd[<span class="number">1</span>] refers to the  write  end  of  the  pipe.</span><br><span class="line">Data  written  to  the  write  end of the pipe is buffered by the kernel until it is read from the read end of the pipe.     </span><br></pre></td></tr></table></figure><blockquote><p>配合<code>fork()</code>一起使用，<code>fork()</code>出的两个进程是共享文件对象的，而用户态资源又是全部拷贝的</p><p>这样父子进程分别拥有用于描述匿名管道读端，写端文件对象的文件描述符，各自关闭一端就能实现半双工通信，两根管道各自关闭一端就能实现全双工通信。(显然，这样的特性是依赖与fork()实现的)</p></blockquote><p><code>示例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让父进程打开文件file1，读取其内容，通过管道发送给子进程，而子进程将内容写入到文件file2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./pipe2 file1 file2</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> fds1[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> fds2[<span class="number">2</span>];</span><br><span class="line">    pipe(fds1);</span><br><span class="line">    pipe(fds2);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程 父读子写 关闭父的写子的读</span></span><br><span class="line">        close(fds1[<span class="number">1</span>]);</span><br><span class="line">        close(fds2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> fd2 = open(argv[<span class="number">2</span>], O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(read(fds1[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// puts(buf);</span></span><br><span class="line">            write(fd2, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// read(fds1[0], buf, sizeof(buf));</span></span><br><span class="line">        <span class="comment">// puts(buf);</span></span><br><span class="line">        <span class="comment">// write(fds2[1], &quot;hello i am child&quot;, 17);</span></span><br><span class="line">        close(fd2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程 父写子读 关闭父的读 子的写</span></span><br><span class="line">        close(fds1[<span class="number">0</span>]);</span><br><span class="line">        close(fds2[<span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">int</span> fd1 = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(read(fd1, buf, <span class="keyword">sizeof</span>(buf)) != <span class="number">0</span>)&#123;</span><br><span class="line">            write(fds1[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write(fds1[1], &quot;i am parent\n&quot;, 13);   </span></span><br><span class="line">        <span class="comment">// char buf[1024];</span></span><br><span class="line">        <span class="comment">// read(fds2[0], buf, sizeof(buf));</span></span><br><span class="line">        <span class="comment">// puts(buf);</span></span><br><span class="line">        close(fds1[<span class="number">1</span>]);</span><br><span class="line">        close(fd1);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MIFIFO(3)   创建有名管道</p><p>UNLINK(2)  删除文件(删除的本质是:接触数据与文件系统的连接—数据不一定被销毁)</p><p>RENAME(2)  移动文件</p><p>LINK(2) 创建硬链接</p></blockquote><h3 id="2-共享内存"><a href="#2-共享内存" class="headerlink" title="2. 共享内存"></a>2. 共享内存</h3><blockquote><p>基于system V 版本的系统调用  $ipcs </p></blockquote><blockquote><p>使用步骤 </p><p>——&gt;通过文件使用<code>FTOK(3)</code>得到一个shmid（是个数字）或者自定义一个数字也可(此数字识别不同的IPC机制?同一个数字可能串号冲突?)</p><p>——&gt; <code>SHMGET(2)</code>生成共享内存</p><p>——&gt; <code>SHMAT(2)</code>将共享内存映射到虚拟地址空间(申请到的共享内存是物理内存，但想要使用它必须先映射) </p><p>——&gt; 之后类似malloc申请到的空间一样操作它即可  </p><p>——&gt; 分配在堆区 用<code>SHMDT(2)</code>释放 并用·<code>shmctl(shmid,IPC_RMID,NULL);</code>删除</p></blockquote><p><code>FTOK(3)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SHMGET(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SHMOP(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SHMOP(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SHMCTL(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p><code>示例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./fhm file</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(argv[<span class="number">1</span>], <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;Hou are you&quot;</span>);</span><br><span class="line">    <span class="comment">// puts(p);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//创建并写入</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./shm_r file1 用同一个文件创建的key相同</span></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(argv[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>); </span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">int</span> ret = shmdt(p);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;shmadt&quot;</span>);</span><br><span class="line">    <span class="comment">// while(1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两个独立进程同时对一个共享内存去访问修改，可能造成竞争条件的出现race condition 由此可以引出信号量作为互斥机制</p></blockquote><blockquote><p>竞争条件:并发的执行流对共享资源的访问会导致竞争条件(进程是默认隔离的，所以出现概率比较低)</p></blockquote><p><code>竞争条件举例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">父子进程各自对共享内存变量加一千万，结果不是两千万</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(IPC_PRIVATE, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmid&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//取4字节存整数</span></span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span> *)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            ++*p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            ++*p;</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./shm_fork </span><br><span class="line">*p = <span class="number">18630024</span></span><br></pre></td></tr></table></figure><h3 id="3-信号量-以二元信号量为主"><a href="#3-信号量-以二元信号量为主" class="headerlink" title="3. 信号量(以二元信号量为主)"></a>3. 信号量(以二元信号量为主)</h3><blockquote><p>由上例中引出的竞争条件，分析其原因，<code>++*p;</code>这条指令在汇编层与机器层是更细化的 大概能分作三步(读取值，计算值，写回值)，如果中途被打断，可能会使得计算(访存)时所用的(得到的)并非最新值</p><p>想要解决这种情况需要有一种机制使的这三步要么不做，要么一次做完。比如原子操作，比如信号量。</p></blockquote><blockquote><p>信号量是描述资源数量的整数 &lt;= 0 : 资源不可用   &gt; 0 : 资源可用</p><p>PV操作 P:测试并加锁，V:释放并解锁 PV之间访问临界资源(这部分代码叫”临界区”)</p></blockquote><blockquote><p>使用步骤 </p><p>——&gt; <code>SEMGET(2)</code>获取信号量</p><p>——&gt;用·<code>semctl(semid, 数组下标, 行为, ....);</code>操作信号， 一般先设初值<code>semctl(semid, 0, SETVAL, 1);</code></p><p>——&gt;定义PV操作</p><p>——&gt;在需要加锁的地方调用<code>SEMOP(2)</code></p></blockquote><p><code>SEMGET(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SEMCTL(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SEMOP(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nsops)</span></span>;</span><br></pre></td></tr></table></figure><p><code>使用示例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用二元信号量，让两个进程对同一个数各加1千万次之后，最终每次执行结果都是2千万，看一下需要耗时多长时间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//准备共享内存,四个字节存加的数</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="comment">//准备二元信号量</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;semctl&quot;</span>);</span><br><span class="line">    <span class="comment">//设置PV操作 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>; <span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="comment">//计算耗时，使用gettimeofday</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">begTime</span>, <span class="title">endTime</span>;</span></span><br><span class="line">    gettimeofday(&amp;begTime, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//完成准备工作，生成两个进程</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            ++*p;</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            ++*p;</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        gettimeofday(&amp;endTime, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total microseconds = %ld\n&quot;</span>, (endTime.tv_sec - begTime.tv_sec)*<span class="number">1000000</span> + endTime.tv_usec - begTime.tv_usec);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/test$ ./pv</span><br><span class="line">*p = <span class="number">20000000</span></span><br><span class="line">Total microseconds = <span class="number">32416265</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>题外话 : dekker算法 伪代码与实现; 计数信号量; ......</code></p><p><code>伪代码</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># dekker算法的基本思路</span><br><span class="line">    variables</span><br><span class="line">        wants_to_enter : array of 2 booleans</span><br><span class="line">        turn : integer</span><br><span class="line"></span><br><span class="line">    wants_to_enter[0] ← false</span><br><span class="line">    wants_to_enter[1] ← false</span><br><span class="line">    turn ← 0   // or 1</span><br><span class="line"># p0</span><br><span class="line">p0:</span><br><span class="line">   wants_to_enter[0] ← true</span><br><span class="line">   while wants_to_enter[1] &#123;</span><br><span class="line">      if turn ≠ 0 &#123;</span><br><span class="line">         wants_to_enter[0] ← false</span><br><span class="line">         while turn ≠ 0 &#123;</span><br><span class="line">           // busy wait</span><br><span class="line">         &#125;</span><br><span class="line">         wants_to_enter[0] ← true</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // critical section</span><br><span class="line">   ...</span><br><span class="line">   turn ← 1</span><br><span class="line">   wants_to_enter[0] ← false</span><br><span class="line">   // remainder section</span><br><span class="line"># p1</span><br><span class="line">p1:</span><br><span class="line">   wants_to_enter[1] ← true</span><br><span class="line">   while wants_to_enter[0] &#123;</span><br><span class="line">      if turn ≠ 1 &#123;</span><br><span class="line">         wants_to_enter[1] ← false</span><br><span class="line">         while turn ≠ 1 &#123;</span><br><span class="line">           // busy wait</span><br><span class="line">         &#125;</span><br><span class="line">         wants_to_enter[1] ← true</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // critical section</span><br><span class="line">   ...</span><br><span class="line">   turn ← 0</span><br><span class="line">   wants_to_enter[1] ← false</span><br><span class="line">   // remainder section</span><br></pre></td></tr></table></figure><p><code>dekker 实现+20000000</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(IPC_PRIVATE, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmid&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//算值</span></span><br><span class="line">    p[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">//wants_to_enter[0] false 两个标志</span></span><br><span class="line">    p[<span class="number">2</span>] = <span class="literal">false</span>; <span class="comment">//wants_to_enter[1]</span></span><br><span class="line">    p[<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">//turn轮转</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            <span class="comment">//p0</span></span><br><span class="line">            p[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//子进程的flag</span></span><br><span class="line">            <span class="keyword">while</span>(p[<span class="number">2</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">3</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">                    p[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">//1号标志false</span></span><br><span class="line">                    <span class="keyword">while</span>(p[<span class="number">3</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//busy wait</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    p[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++*p;</span><br><span class="line">            p[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">            p[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//p1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            p[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(p[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">3</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                    p[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">while</span>(p[<span class="number">3</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">            ++*p;</span><br><span class="line">            p[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            p[<span class="number">2</span>] = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);   </span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/test/day13/homework$ make</span><br><span class="line">gcc  dekker.c -o dekker -g -O0</span><br><span class="line">scallacs@scallacs:~/test$ ./dekker  </span><br><span class="line">*p = <span class="number">20000000</span>  单核</span><br><span class="line">[ubuntu@VM<span class="number">-16</span><span class="number">-8</span>-ubuntu ~/linux/\ []$ ./dekker </span><br><span class="line">*p = <span class="number">19899008</span>  双核 会受到核心数影响，单核时表现完美</span><br></pre></td></tr></table></figure><p><code>计数信号量 + 生产者消费者问题</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1002</span>, <span class="number">2</span>,IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="comment">// unsigned short  *array;  /* Array for GETALL, SETALL */ 要使用SETALL初始化</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> arr[] = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;; <span class="comment">//arr[0]&lt;-&gt;商品  arr[1]&lt;-&gt;货仓 初始货仓摆满商品</span></span><br><span class="line">    <span class="keyword">int</span> ret = semctl(semid, <span class="number">0</span>, SETALL, arr);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;semctl setall&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出看看是否初始化成功，增量编程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sem[0] = %d, sem[1] = %d\n&quot;</span>, semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">    <span class="comment">// 设置信号量做PV操作, 先设定操作的行为,针对两种资源使用信号量集合</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">produce</span>[2];</span><span class="comment">//produce[0]:商品 produce[1]:货仓?</span></span><br><span class="line">    produce[<span class="number">0</span>].sem_num = <span class="number">0</span>;</span><br><span class="line">    produce[<span class="number">0</span>].sem_op = <span class="number">1</span>; <span class="comment">//商品+1</span></span><br><span class="line">    produce[<span class="number">0</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    produce[<span class="number">1</span>].sem_num = <span class="number">1</span>;</span><br><span class="line">    produce[<span class="number">1</span>].sem_op = <span class="number">-1</span>;</span><br><span class="line">    produce[<span class="number">1</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">consume</span>[2];</span><span class="comment">//consume[0]:商品 consume[1]:货仓</span></span><br><span class="line">    consume[<span class="number">0</span>].sem_num = <span class="number">0</span>;</span><br><span class="line">    consume[<span class="number">0</span>].sem_op = <span class="number">-1</span>; <span class="comment">//商品-1</span></span><br><span class="line">    consume[<span class="number">0</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    consume[<span class="number">1</span>].sem_num = <span class="number">1</span>;</span><br><span class="line">    consume[<span class="number">1</span>].sem_op = <span class="number">1</span>;</span><br><span class="line">    consume[<span class="number">1</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="comment">// 启动父子进程分别作为生产者和消费者</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// sleep(1);//如果交换睡眠时间会一直显示&#123;5, 0&#125;消费太慢</span></span><br><span class="line">            usleep(<span class="number">500000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am consumer, before consume, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">            <span class="comment">// semop(semid,consume,2);//这个操作会影响到2个资源 </span></span><br><span class="line">            semop(semid, &amp;consume[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consumer buy a product\n&quot;</span>);</span><br><span class="line">            semop(semid, &amp;consume[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am consumer, after consume, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// usleep(500000);</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am producer, before produce, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">            <span class="comment">// semop(semid,produce,2);//这个操作会影响到2个资源 </span></span><br><span class="line">            semop(semid, &amp;produce[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;produce a product\n&quot;</span>);</span><br><span class="line">            semop(semid, &amp;produce[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am producer, after produce, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./produceAndConsume </span><br><span class="line">sem[<span class="number">0</span>] = <span class="number">5</span>, sem[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am producer, before produce, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">produce a product</span><br><span class="line">i am producer, after produce, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">i am producer, before produce, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">produce a product</span><br><span class="line">i am producer, after produce, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">2</span>, space = <span class="number">3</span></span><br><span class="line">i am producer, before produce, product = <span class="number">2</span>, space = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4.消息队列"></a>4.消息队列</h3><blockquote><p>这里使用的是狭义的消息队列(广义的消息队列:网络消息中间件)， 这里的是面向消息的进程间通信机制</p><p>使用流程与前二者类似</p><p>——&gt; <code>MSGGET(2)</code>获取消息队列</p><p>——&gt; <code>MSGSND(2)</code> 发</p><p>——&gt; <code>MSGRCV(2)</code> 收</p><p>后面综合使用时演示</p></blockquote><p><code>MSGGET(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>MSGSND(2)</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><p> <code>MSGRCV(2)</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="5-信号"><a href="#5-信号" class="headerlink" title="5. 信号"></a>5. 信号</h3><blockquote><p>进程间异步通信机制(软件层面的，异步:不知道什么时候有信号来;管道是同步的:先写再读)</p><p>信号分为产生 递送(对某个进程施加影响(处理信号))两个阶段</p><p><code>kill -l </code>列出所有信号 共有64个 每种信号对应一个整数</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">递送信号发生了什么(递送信号的默认行为)(收到信号的默认行为:是可以通过注册信号改变这些行为的)</span><br><span class="line">Each signal has a current disposition, <span class="built_in">which</span> determines how the process behaves when it is delivered the signal.</span><br><span class="line"></span><br><span class="line">The entries <span class="keyword">in</span> the <span class="string">&quot;Action&quot;</span> column of the table below specify the default disposition <span class="keyword">for</span> each signal, as follows:</span><br><span class="line">      Term   Default action is to terminate the process.  终止进程 Ctrl C</span><br><span class="line">      Ign    Default action is to ignore the signal. 忽略信号<span class="built_in">wait</span>()的实现原理 SIGCHILD 告知父进程可以回收</span><br><span class="line">      Core   Default action is to terminate the process and dump core (see core(5)). 终止生成并core文件 Ctrl \ </span><br><span class="line">      Stop   Default action is to stop the process. 暂停 Ctrl Z</span><br><span class="line">      Cont   Default action is to <span class="built_in">continue</span> the process <span class="keyword">if</span> it is currently stopped. 恢复<span class="built_in">bg</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>将递送信号时的默认行为改变为自己定义的行为<code>SIGNAL(2)</code>(更改递送信号时的默认行为:可以实现进程的有序退出)</p><p>递送信号的本质 是 修改被递送信号的进程的task_struct （[注]9号信号的默认行为不能改）</p></blockquote><blockquote><p>执行流程如下图所示，在进程执行过程中受到信号，CPU的使用权移交给信号产生者，它会要求进程调用预定义的回调函数handler()，将这个信号的默认行为使用handler()定义的行为取代，函数接口如下</p></blockquote><p><code>SIGNAL(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line">                                              |-&gt;注册一个handler</span><br><span class="line">把系统信号的递送行为改为自己注册的行为</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.png" alt="回调函数的执行"></p><blockquote><p>如果有多个信号同时递送，会发现这么一种现象，有的递送行为没有执行，分析会发现，相同信号的递送会有如下现象</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BF%A1%E5%8F%B7%E9%80%92%E9%80%81.png" alt="信号递送"></p><blockquote><p>Q:那么为什么 多余的信号会被丢弃</p><p>A:这涉及两个结构体 <code>mask </code> <code>掩码，表示是否阻塞 pending   </code>未决信号集，表示是否有未决信号 它们都是位图实现的</p><p>所以在递送X信号时，会将mask的X置为1(递送结束恢复为0)(信号递送过程中把自己阻塞:把自己加入mask)—-&gt;当新信号产生，若这个信号也是X，查询mask发现其中有自己，那就把自己加入pending(对应位置1)—–&gt;再有一个X产生，同样的流程，但因为底层实现是位图pending只能保存一个，所以它被丢弃。</p><p>类似的，如果第三个信号是个新的，且mask中没它，就会转而执行新信号的递送…….</p></blockquote><blockquote><p>signal系统调用也存在一些缺陷，它的很多特性是写死的，比如递送X信号时会将X加入mask因此还有更好用的系统调用</p></blockquote><p><code>SIGACTION(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure><p><code>用法示例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;<span class="comment">//指定不把自己加入mask,可反复切换，没使用SIGINFO指定为单参数版本的handler</span></span><br><span class="line">    act.sa_handler = handler; <span class="comment">//指定回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用sigaction注册信号 注册2号3号信号执行handler以来回打断</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGQUIT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./sigaction </span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">Killed</span><br></pre></td></tr></table></figure><blockquote><p>后续，这些进程间通信机制都用的比较少，有更好的实现方案</p><p>用网络取代管道，用线程取代共享内存，用互斥锁取代信号量(当然，信号是比较独特的进程间通信机制，用到时再复盘)</p></blockquote><h3 id="6-综合应用：实现一个四窗口聊天"><a href="#6-综合应用：实现一个四窗口聊天" class="headerlink" title="6. 综合应用：实现一个四窗口聊天"></a>6. 综合应用：实现一个四窗口聊天</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通信方式：</span><br><span class="line">- 4个进程，A进程和B进程负责通信，从标准输入读到的字符串通过管道发给对方，A1和B1进程负责显示。</span><br><span class="line">- A进程从标准输入读到的字符串发给B进程后，放到共享内存里，从管道中读到的字符串也放到共享内存里，A1进程到共享内存中拿到字符串，打印到屏幕上。</span><br><span class="line">- B进程从标准输入读到的字符串发给B进程，同时通过消息队列发给B1进程，B1进程从消息队列中读出消息，打印到屏幕上。</span><br><span class="line">退出方式：</span><br><span class="line">- 第一种：可以通过ctrl+C退出，任意一个进程收到CTRL+C时，给所有进程（包括自己）发送10号信号，每个进程收到10号信号后，开始执行有序退出。</span><br><span class="line">- 第二种：通过kill命令给4个进程中的任何一个进程发送10号信号，收到信号的进程再给其他3个进程发送10号信号。每个进程在自己的信号处理函数中执行有序退出。</span><br><span class="line">有序退出的工作内容：</span><br><span class="line">- 有序退出要做的主要有：关闭管道，解除对共享内存的映射，删除共享内存，删除信号量，删除消息队列。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  注意：A和A1进程都要访问共享内存，需要同信号量完成同步，所以退出时要也删除信号量。</span><br><span class="line">  提示：A1进程和B1进程需要知道每条消息是对方发来的消息还是发给对方的消息，用消息队列的一方可以通过mtype的值来标识，</span><br><span class="line">       用共享内存的进程可以自己定义一个类似 msgbuf的结构体，然后结构体中也用一个类似mtype的成员来标记。</span><br></pre></td></tr></table></figure><p><code>a.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">2048</span>];</span><br><span class="line">&#125;<span class="keyword">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pa, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid 输出看看是否正常收到</span></span><br><span class="line">    <span class="comment">// 程序启动，先获取四个进程的PID存入全局变量输出一下(通信时用不到，但退出时有用)</span></span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">0</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ******************************************************</span></span><br><span class="line">    <span class="comment">// 通信，a2b管道通信</span></span><br><span class="line">    <span class="comment">// int ret_ab = mkfifo(&quot;a2b&quot;, 0666);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_ab, -1, &quot;mkfifo&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信 a2a1 by 共享内存+信号量 ?共享内存中怎么设置msgbuf结构体? 类似malloc</span></span><br><span class="line">    <span class="comment">// 为什么要用信号量：写的时候不允许读 先做共享内存读写再做信号量</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">msg_t</span> *p = (<span class="keyword">msg_t</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信号量完成同步(不用的话a1显示时有时候会阻塞住?)(Q:stdin的消息较少阻塞，pipe的消息很容易?)确实是同步问题，加锁解决</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret_sem = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem, <span class="number">-1</span>, <span class="string">&quot;semctl setval&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>;<span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开a2b的写端，b2a的读端 完成后输出</span></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;a2b&quot;</span>, O_WRONLY);</span><br><span class="line">    ERROR_CHECK(fdw, <span class="number">-1</span>, <span class="string">&quot;open pipe a2b\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;b2a&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fdr, <span class="number">-1</span>, <span class="string">&quot;open pipe b2a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;chat established!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//IO多路复用</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);<span class="comment">//设置监听集合</span></span><br><span class="line">        <span class="keyword">int</span> ret_slt = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from process b\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdb = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdb == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// puts(buf);//后面改成在进程a1上显示</span></span><br><span class="line">            <span class="comment">// 从管道读来自b的消息 重定向到a1进程去显示 来自管道的消息定为2</span></span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            p-&gt;mtype = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;mtext, buf);</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from stdin.\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdin = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdin == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fdw, buf, ret_rdin);<span class="comment">//除开给管道发送一份之外还要写给a1显示进程一份</span></span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            p-&gt;mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;mtext, buf);</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    shmdt(p);</span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>a1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">2048</span>];</span><br><span class="line">&#125;<span class="keyword">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">1</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *************************************************</span></span><br><span class="line">    <span class="comment">// 读取共享内存中的消息</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">msg_t</span> *p = (<span class="keyword">msg_t</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信号量完成同步</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret_sem = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem, <span class="number">-1</span>, <span class="string">&quot;semctl setval&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>;<span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mtype == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg from process b:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg type = %d, msg = %s\n&quot;</span>, p-&gt;mtype, p-&gt;mtext);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mtype == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg from stdin:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg type = %d, msg = %s\n&quot;</span>, p-&gt;mtype, p-&gt;mtext);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Q : 怎么做到读出一条消息后阻塞? 清空一下阻塞住了但是 有时候接不到下条消息?等会加锁试试</span></span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line">        semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int ret_shmdt = shmdt(p);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_shmdt, -1, &quot;shmdt&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> ret_sem_rm = semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem_rm, <span class="number">-1</span>, <span class="string">&quot;semctl IPC_RMID&quot;</span>);</span><br><span class="line">    shmdt(p);   <span class="comment">//有一片共享内存(a2a1通信用的那片)和信号量没有正确退出，其他的正常</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>b.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">2</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *********************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信，b2b1(b1为显示端) 使用消息队列，要做的事情:b把从管道读端,键盘输入读到的数据重定向到b1,区分消息类型 by 消息队列</span></span><br><span class="line">    <span class="comment">// 消息对列发端</span></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">bufin</span>, <span class="title">bufpipe</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信，a2b管道通信</span></span><br><span class="line">    <span class="comment">// int ret_ba = mkfifo(&quot;b2a&quot;, 0666);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_ba, -1, &quot;mkfifo&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开b2a的写端，a2b的读端 完成后输出</span></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;a2b&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fdr, <span class="number">-1</span>, <span class="string">&quot;open pipe b2a\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;b2a&quot;</span>, O_WRONLY);</span><br><span class="line">    ERROR_CHECK(fdw, <span class="number">-1</span>, <span class="string">&quot;open pipe a2b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;chat established!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        <span class="keyword">int</span> ret_slt = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from process a\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rda = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rda == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// puts(buf);//管道读端读到的原本直接输出，现在重定向到b1进程 by message queue;</span></span><br><span class="line">            </span><br><span class="line">            bufpipe.mtype = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(bufpipe.mtext, buf);</span><br><span class="line">            <span class="keyword">int</span> ret_msgque_pipe = msgsnd(msgid, &amp;bufpipe, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret_msgque_pipe, <span class="number">-1</span>, <span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from stdin.\n&quot;);//隐藏掉这些信息进程b就只管输入了,显示全在b1</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdin = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdin == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fdw, buf, ret_rdin);<span class="comment">//后面改成在进程a1上显示</span></span><br><span class="line">            <span class="comment">// 键盘输入还要再在b1上显示一次</span></span><br><span class="line">            bufin.mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(bufin.mtext, buf);</span><br><span class="line">            <span class="keyword">int</span> ret_msgque_in = msgsnd(msgid, &amp;bufin, <span class="keyword">sizeof</span>(bufin), <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret_msgque_in, <span class="number">-1</span>, <span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>b1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">3</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *********************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// msgrcv</span></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">bufin</span>, <span class="title">bufpipe</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin)); <span class="comment">//两种消息有时候会阻塞?</span></span><br><span class="line">        <span class="keyword">int</span> ret_msgrcv_in = msgrcv(msgid, &amp;bufin, <span class="keyword">sizeof</span>(bufin), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//1, IPC_NOWAIT  改填0不限制消息类型直接取出</span></span><br><span class="line">        ERROR_CHECK(ret_msgrcv_in, <span class="number">-1</span>, <span class="string">&quot;msgrcv_in&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgrcv form stdin:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type = %ld, msg = %s\n&quot;</span>, bufin.mtype, bufin.mtext);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));       <span class="comment">//注意这个限制消息队列长度的参数：msgrcv: Argument list too long</span></span><br><span class="line">        <span class="keyword">int</span> ret_msgrcv_pipe = msgrcv(msgid, &amp;bufpipe, <span class="keyword">sizeof</span>(bufpipe), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//2, IPC_NOWAIT</span></span><br><span class="line">        ERROR_CHECK(ret_msgrcv_pipe, <span class="number">-1</span>, <span class="string">&quot;msgrcv_pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgrcv from pipe:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type = %ld, msg = %s\n&quot;</span>, bufpipe.mtype, bufpipe.mtext);</span><br><span class="line">        <span class="comment">//这样会循环取出，几乎一瞬间取完然后进程终止(怎么阻塞它)？不加IPC_NOWAIT 即可</span></span><br><span class="line">        <span class="comment">//目前对b1用Ctrl+C 不会影响a, b进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Unix/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix/Linux-file-management</title>
      <link href="/2022/02/26/6.Unix-Linux-file-management/"/>
      <url>/2022/02/26/6.Unix-Linux-file-management/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote><p>对于Linux的学习很早就开始了，但是直到现在才稍微有了一点比较深刻的感受。之前可能偏运维方向的Linux知识学的多一点，一直没有深入的学习，同时也没有接触到工作环境以得到更多的使用机会。所以所学习的知识大都浮于表面。并且有过了几次学了就忘的糟糕经历，反复多次学习，始终不曾从入门到熟练。只能说对这个系统稍有熟悉。最近的一次学习是当时准备找一份运维相关的工作，所以在网上找了视频准备系统学习。基本完整的走了一次从基础知识-&gt;脚本编程-&gt;系统管理-&gt;服务管理-&gt;Linux集群的流程。知识点很多，学到Linux集群时没能成功完成当时的项目，同时发现前期所学的知识遗忘太多，感觉十分挫败，同时由于一些其他的原因，最终没有走这个方向。但是我觉得与Linux的缘分不止于此 :)</p><p>最近在整理复盘C的知识时，在Linux环境下学习，有些和此前不同的感受，回顾C和Unix的历史，是否从稍微深入的研究Linux方向学习更适合我，近期在做这件事情，并将一些收获记录如下。</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-一点历史"><a href="#0-一点历史" class="headerlink" title="0 .一点历史"></a>0 .一点历史</h3><blockquote><p>还是从一点历史引入，感觉了解一些历史缘由，会更好地理解采用某种特定实现技术的原因</p><p>看了一点《The art of Unix Programming》 序中有一句话挺吸引我</p><p><em>Unix is not so much an operating system as an oral history.  —-Neal Stephenson</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-&gt;(早期)批处理OS</span><br><span class="line">-&gt;(1960)MIT分时OS:多终端+大型机</span><br><span class="line">-&gt;(1965)AT&amp;T:Bell+MIT+GE(通用电气):Multics计划(全面通用分时OS:bye)</span><br><span class="line">-&gt;(1969)Bell认为该计划GG,退出 (不算失败，有些成果) ：Ken Thompson 写了 Space Travle, PDP-7小型机移植，对它重写OS内核并移植 称Unics</span><br><span class="line">-&gt;Unics(核心哲学:一切皆文件, 程序的目的只有一个-有效的完成目标 : 与Multics理念不同《The Art of Unix Programming》)</span><br><span class="line">-&gt;(1969)Linus Torvalds 在芬兰诞生</span><br><span class="line">-&gt;尝试用高级语言解决移植问题BCPL, PASCAL-&gt;编译出的内核性能不够好-&gt;根据BCPL发明C</span><br><span class="line">-&gt;(1973)Deneish Richie(C的主要发明者)用C重写了Unics系统(提供了管道等重要功能),更名为Unix</span><br><span class="line">-&gt;(1977)AT&amp;T将Unix源代码(用C写的,高可移植性)发给学术界-&gt;UC Berkeley-&gt;Bill Joy professor 编译成适合自己机器的系统，增减一些功能:命名为BSD(Berkeley Software Distribution)</span><br><span class="line">-&gt;(1979)AT&amp;T:推出System V(five(Sun - Solaris)):第七版(不再开源:商业纠纷开始):特性:可以支持x86架构的个人计算机</span><br><span class="line">-&gt;(1984)不再开源对教授OS的professor产生了影响:Andrew TannenBaum-&gt;自己写个Mini Unix -&gt; Minix</span><br><span class="line">-&gt;(1986)完成Minix, 并出版《Operating System : Design and Implementation》附带Minix的源代码</span><br><span class="line">        《Modern Operating System》也是他写的</span><br><span class="line">-&gt;同期 Richard Stallman 发起了GNU计划:GNU:Gnu is not Unix!(GCC, Emacs, Bash Shell, GDB...)目标创建一套完全自由的Unix OS(当时的Unix与硬件捆绑销售)但是缺少Unix内核</span><br><span class="line">-&gt;草拟 GPL协议(General Publilc License | 🙂 copyleft &lt;!-&gt; copyright:著作权) 开源 != 免费(维护可以收费)</span><br><span class="line">-&gt;(1988)IEEE:POSIX标准(旨在:保证各个OS间的兼容性) (IEEE-IX-&gt;POSIX:Portable Operating System Interface X:(Unix))可移植...</span><br><span class="line">-&gt;(1993)Linus:宏内核构造的Linux内核面世</span><br></pre></td></tr></table></figure><h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><blockquote><p>感觉之前学过很多次，并且每次学习也有用纸质或者文档记录，博客记录学到，使用过的命令，但大多情况学过不用就忘了，不是长久之计，这次就不记录这些。尽量多用以熟练。同时，本文的侧重点不在使用这方面，想要更深入的学习一些东西。</p></blockquote><blockquote><p>如果有不会的熟练使用 <code>$man</code></p><p>一点准备工作，环境使用的Ubuntu18.04 帮助手册不全<code>sudo apt install manpages-posix-dev</code></p></blockquote><h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3><blockquote><p>这是一张来自《Advanced Programing in the UNIX Environment》的图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/imgUnix%E6%9E%B6%E6%9E%84.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Kernel：OS内核：管理硬件资源，给上层程序提供运行环境(所以有很多驱动，提供很多接口，服务)</span><br><span class="line">System calls：系统调用：内核给上层程序提供的接口(有些繁琐复杂，做些封装-&gt;系统库)程序由系统调用使用内核提供的功能</span><br><span class="line">Library routines:库函数 (printf, scanf:对系统调用做一次封装)上层程序不能直接与硬件交互，需调用底层接口(对System calls封装)</span><br><span class="line">Shell：命令行解释器(bash:Bourne-again shell:/bin/bash):命令，脚本(命令的集合)， 访问内核资源</span><br><span class="line">Applications:应用程序:可以直接使用系统调用调用内核功能，也能使用系统库提供内核功能</span><br></pre></td></tr></table></figure><blockquote><p>在学习C的过程中，用到过不少库函数，按照这幅图从 库函数-&gt;System call-&gt;Kernel 由外层到里层深入的学习确实是此前没有接触过的全新思路，当然，任务也很艰巨《APUE》《内核源码》都是大部头，希望后面有毅力能啃完吧 : )</p></blockquote><blockquote><p>接下来按照OS的功能划分，以文件管理,进程管理,内存管理,IO管理 来分块学习。</p></blockquote><h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><blockquote><p>关于一切皆文件这个理念</p><p>对于这个Unix设计哲学，之前是知道这个名词，但是要具体来说可能说不出什么，结合一些文件操作来理解可能更为清晰。(图画的丑: ))在程序的运行过程中，计算机是怎样去操作磁盘上的文件的? 在一个程序运行时，由CPU去代码段取一条条指令，并将指令执行生成的数据放入堆栈等数据区。那么指令的操作数在哪？在内存上，内存的数据是从磁盘上取出的，最终也会持久化的存储在磁盘上。从中取，往回存这两个操作是怎么做到的，把磁盘看做程序运行时的外部设备，它在内存上建立了映射区—称作文件缓冲区。文件缓冲区在内存上，但是影响外部设备。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/img%E6%96%87%E4%BB%B6_%E6%93%8D%E4%BD%9C.jpg"></p><blockquote><p>以此类推，目录文件，设备文件，管道文件等等，理念是一致的，对于众多的文件类型使用通用的方式去操作它们。文件操作操作的是内存上的数据，影响的是外部设备。对于Linux而言存在内核态与用户态，当文件操作涉及外部硬件时，用户态将这些操作委托给内核态去完成，这就离不开系统调用。</p><p>理解了这一点，就可以通过学习文件操作更深入的理解(操作文件会影响外部硬件，这个函数就不是普通的函数而是系统调用)。使用库函数和系统调用来操作文件，从库函数–&gt;系统调用。</p><p>基于文件指针的文件操作函数(ANSI 标准库函数) –&gt; 基于系统调用的文件操作</p></blockquote><h4 id="3-1-文件操作-基于-库函数-文件指针FILE"><a href="#3-1-文件操作-基于-库函数-文件指针FILE" class="headerlink" title="3.1 文件操作 - 基于(库函数)文件指针FILE*"></a>3.1 文件操作 - 基于(库函数)文件指针FILE*</h4><blockquote><p>从普通文件的打开与操作开始</p></blockquote><p><code>流</code>：表示任意输入<code>src</code>, 任意输出<code>dst</code> ，屏蔽硬件设备之间的差异，使得C像读写文件一样读写任意设备。</p><blockquote><p>内存与硬件设备存在读写性能上的鸿沟，OS在内存上为<code>流</code>设置缓冲区，C通过文件指针<code>FILE*</code>实现对流的访问, 启动任意进程OS将打开三个标准流<code>stdin</code> , <code>stdout</code>,  <code>stderr</code>.它们都默认与硬件关联。</p></blockquote><p>从普通文件操作开始, 读写之前先打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">返回值是指针:暗含的意思-&gt;返回值指针指向必定不在被调函数栈帧(而在用户态某个空间，需用户自行释放)</span><br><span class="line">返回文件指针访问流</span><br><span class="line">|</span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* mode)</span></span>;</span><br><span class="line">                                                |</span><br><span class="line">                                            打开模式(考虑后续操作)</span><br><span class="line">                                            <span class="string">&quot;r&quot;</span> :只读打开</span><br><span class="line">                                            <span class="string">&quot;r+&quot;</span>:读写打开 文件必须存在</span><br><span class="line">                                            <span class="string">&quot;w&quot;</span> :只写创建 文件不需要存在</span><br><span class="line">                                            <span class="string">&quot;w+&quot;</span>:读写创建 文件存在就清空</span><br><span class="line">                                            <span class="string">&quot;a+&quot;</span>:读写追加 在原有数据后写入新值</span><br><span class="line">                                                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* stream)</span></span>;                                                    </span><br></pre></td></tr></table></figure><blockquote><p>文件不再使用要关闭，这涉及一点更底层的系统调用<code>open</code>相关，之后会谈到<code>fopen</code>与<code>open</code>的联系。<br>简单来讲OS使用文件描述符来打开文件资源，<code>fopen</code>返回的文件指针FILE*实际指向的即是这些文件描述符。<br>不使用<code>fclose</code>释放这些文件描述符的话，需要进程结束时由OS去回收它们。<br>如果在一个程序中持续打开文件又不关闭，文件描述符是可能被用完的。再涉及一点后面的知识，使<code>fopen</code>时一般与库函数<code>fwrite</code>等搭配使用而<strong>库函数</strong>与后面的<code>write</code>这样的<strong>系统调用</strong>是不一样的，它不会直接将数据写入磁盘，而是有缓冲区的，当达到一定条件(比如缓冲区满)才会将数据写入磁盘。所以如果程序正常退出，缓冲中的数据会安全写入磁盘，但如果异常退出缓冲中的数据可能丢失。所以使用<code>fclose</code>能确保数据安全。</p></blockquote><p>文件读写操作 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">处理字符串</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">                                        |</span><br><span class="line">           (序列化|反序列化)做格式化输入输出到目标文件，有时候用fwrite二进制处理更方便</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br><span class="line">                                   |</span><br><span class="line">                               把这些流参数写成<span class="built_in">stdin</span>,<span class="built_in">stdout</span> 就是<span class="built_in">puts</span>,gets等库函数</span><br><span class="line">                                        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line">    </span><br><span class="line">处理二进制</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>处理文件的函数的基本读写操作 - 基于文件指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">&#125;<span class="keyword">student_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./fopen file file2</span></span><br><span class="line">    <span class="comment">//注意这几段测试代码不能混用，让文件流指针走到文件末尾了?</span></span><br><span class="line">    <span class="comment">/*******************fgetc fputc************************/</span></span><br><span class="line">    <span class="keyword">int</span> retc = fgetc(fp);<span class="comment">//读一个字符成功返回字符，失败返回EOF(-1)</span></span><br><span class="line">    ERROR_CHECK(retc, <span class="number">-1</span>, <span class="string">&quot;fgetc read EOF&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,retc);</span><br><span class="line">    <span class="keyword">int</span> retpc = fputc(<span class="string">&#x27;p&#x27;</span>,fp);</span><br><span class="line">    ERROR_CHECK(retpc, <span class="number">-1</span>, <span class="string">&quot;fputc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************fgets fputs************************/</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">1024</span>, fp) != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        <span class="built_in">fputs</span>(buf, dst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******************fscanf fprintf************************/</span></span><br><span class="line">    <span class="keyword">student_t</span> stu[<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="number">60.1</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>, <span class="number">88.88</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">3</span>, <span class="string">&quot;laowang&quot;</span>, <span class="number">99.87</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;\n%d-%s-%.2lf&quot;</span>, stu[i].id, stu[i].name, stu[i].score);</span><br><span class="line">        <span class="comment">//格式化输入到文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******************fread fwrite************************/</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2048</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(n = fread(buf, <span class="number">1</span>, <span class="keyword">sizeof</span>(buf), fp) != <span class="number">0</span>)&#123;</span><br><span class="line">        fwrite(buf, <span class="number">1</span>, <span class="built_in">strlen</span>(buf), dst);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(dst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件定位操作</p><blockquote><p>对于流这个概念有个很重要的性质—流有它关联的位置指针，在进行读写操作时，文件位置指针会自动推进，以顺序访问文件。</p><p>但是也有手段去改变这个文件位置指针的指向，如以下几个库函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                              SEEK_SET, SEEK_CUR, SEEK_END</span><br><span class="line">                                         参照点</span><br><span class="line">                                           |</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;  &lt;=&gt; fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br></pre></td></tr></table></figure><p>关于<code>fopen</code>与<code>open</code>的底层联系,见3.3</p><blockquote><p> [补充]：</p><p> 对于之前程序中经常会用到的两种操作，抽取成两个带参宏：</p><ul><li>1.参数个数检查：</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARGS_CHECK(argc, num) </span></span><br><span class="line">&#123;<span class="keyword">if</span>(argc != num)&#123;<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;args error!\n&quot;</span>);<span class="keyword">return</span> <span class="number">-1</span>;&#125;&#125; </span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>2.函数运行错误检查</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_CHECK(ret, num, msg) &#123;<span class="meta-keyword">if</span>(ret == num) &#123;perror(msg);return -1;&#125;&#125;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p> 关于文本格式文件与二进制格式文件的使用，熟悉使用二进制格式文件，节省空间，转换效率高，怎么写就怎么读</p></blockquote><blockquote><p>关于参考手册的查询 <code>&gt;$ man xxx</code>重点关注函数原型，返回值</p></blockquote><blockquote><p>创建文件由于掩码<code>umask : 0002</code>的影响 取反按位与 其它用户没有写权限 </p></blockquote><blockquote><p><code>puts(str); == printf(&quot;%s\n&quot;,str);</code>   <code>scanf</code> 从非空白读到空白  <code>gets</code> 从开始读到换行</p></blockquote><h4 id="3-2-目录操作"><a href="#3-2-目录操作" class="headerlink" title="3.2 目录操作"></a>3.2 目录操作</h4><blockquote><p>先学习一些库函数和系统调用，然后组合使用他们实现一些系统命令。</p></blockquote><p>CHMOD(2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>GETCWD(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">                    |</span><br><span class="line">                  将当前工作目录的绝对路径复制到buf所指空间，buf不够大可能报错,在栈上</span><br><span class="line">                                               </span><br><span class="line">getcwd(<span class="literal">NULL</span>, <span class="number">0</span>); 另一种用法，返回当前工作目录</span><br><span class="line">buf为<span class="literal">NULL</span>，依照size大小自动分配，而size也为<span class="number">0</span>，则根据绝对路径字符串长在**堆**上分配，需自行<span class="built_in">free</span>     </span><br></pre></td></tr></table></figure><p>CHDIR(2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure><p>MKDIR(2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>RMDIR(2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><em>关于文件系统(OS中负责管理持久数据的子系统)，基本单位是文件，对文件的组织方式不同就会生成不同的文件系统，对于任意文件，快速定位到它的位置是首要的需求。所以在文件系统的设计之初就需要利用专门的索引结构来管理所有文件。索引结构的基本单位是*<em>索引节点</em></em>(具有固定大小，其中存放单个文件的位置，文件类型，权限，修改时间等信息。是文件的唯一标识，会占据磁盘空间)文件系统利用数组组织这些索引节点并用一个辅助的位图实现高效的管理文件信息。*</p></blockquote><blockquote><p>按照一切皆文件的设计理念，目录也是文件。类比文件操作的文件指针与文件流，目录也有对应的目录流结构以及相应的位置指针</p><p>目录的存储原理</p><p>Linux 会为每个文件分配两个数据结构 索引节点(index node)目录项(directory entry) 分别记录文件的元信息和目录层次结构。<strong>目录项</strong>会记录文件名，索引节点指针，与其他节点的层级关联关系等。多个目录项关联起来形成目录结构。目录项由内核维护，不存放在磁盘，缓存在内存。注意<strong>索引节点</strong>才是唯一标识。扯远了，这一块其实理的不是很清楚，后面再看看。</p></blockquote><blockquote><p>总之，目录作为特殊的文件，简单来讲会把其下的所有目录项(孩子)组织成链表结构，当需要访问这个目录时，需要将其映射到内存中，这就变成了目录流结构如下图所示。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/目录结构.jpg" alt="目录流" style="zoom: 80%;" /><blockquote><p>链表节点为dirent(directory entry)定义如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ man <span class="number">3</span> readdir</span><br><span class="line">In the glibc implementation, the dirent structure is defined as follows:</span><br><span class="line">&lt;dirent.h&gt;</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">               <span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">               <span class="keyword">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span>  </span><br><span class="line">                                              访问下个dirent结点，实际是依赖于本结点中d_off属性</span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* Type of file; not supported</span></span><br><span class="line"><span class="comment">                                              by all filesystem types */</span></span><br><span class="line">               <span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>对于的目录文件，提供了对应的库函数操作它们 从映射到内存(打开目录流)-&gt;提取目录项信息-&gt;-&gt;-&gt;</p></blockquote><p>OPENDIR(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>CLOSEDIR(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure><p>READDIR(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"> On success, readdir() returns a pointer  to  a  dirent  structure.   </span><br><span class="line">(This structure may be statically allocated; <span class="keyword">do</span> <span class="keyword">not</span> attempt to <span class="built_in">free</span>(<span class="number">3</span>) it.)</span><br><span class="line"> 这个函数返回以结构体类型为基类型的指针，但不需要主调申请内存(如此前在堆上<span class="built_in">malloc</span>的)特别的，此函数在数据段上申请内存。</span><br><span class="line">(与全局变量申请在一起)</span><br><span class="line">主调调用此函数，此函数readdir申请内存。主调创建一个指针即可。(不同库函数作者的口味不同)</span><br><span class="line">     </span><br><span class="line">用法：</span><br><span class="line">    truct dirent *pdirent;</span><br><span class="line">    <span class="keyword">while</span> ((pdirent = readdir(pdir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        do_something;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>几个定位，不太常用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dir)</span></span>;            <span class="comment">//重新定位到目录文件的头部 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dir,<span class="keyword">off_t</span> offset)</span></span>; <span class="comment">//用来设置目录流目前的读取位置 </span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">telldir</span><span class="params">(DIR *dir)</span></span>;             <span class="comment">//返回目录流当前的读取位置</span></span><br></pre></td></tr></table></figure><p>STAT(2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>有了以上的库函数与系统调用，可以做点有意思的事情，实现几个UNIX命令看看</p></blockquote><p><code>ls -l</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递任意一个目录路径，能够显示该目录的ls -l的效果。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">switch_mon</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="string">&quot;Mon&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="string">&quot;Feb&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="string">&quot;Mar&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="string">&quot;Apr&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="string">&quot;May&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">return</span> <span class="string">&quot;Jun&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">return</span> <span class="string">&quot;Jul&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">return</span> <span class="string">&quot;Aug&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: <span class="keyword">return</span> <span class="string">&quot;Sep&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>: <span class="keyword">return</span> <span class="string">&quot;Oct&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">return</span> <span class="string">&quot;Nov&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>: <span class="keyword">return</span> <span class="string">&quot;Dec&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//OJ做法，不用switch-case 直接定义一个数组即可</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * month[<span class="number">12</span>] = &#123;<span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span>, <span class="string">&quot;Apr&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;Jun&quot;</span>, </span><br><span class="line">                            <span class="string">&quot;Jul&quot;</span>,<span class="string">&quot;Aug&quot;</span>, <span class="string">&quot;Sep&quot;</span>, <span class="string">&quot;Oct&quot;</span>, <span class="string">&quot;Nov&quot;</span>, <span class="string">&quot;Dec&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">switch_mode</span><span class="params">(<span class="keyword">mode_t</span> mode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">11</span>];<span class="comment">//字符串给点余量，其实申请大一点空间也可以</span></span><br><span class="line">    <span class="keyword">switch</span>(mode &amp; S_IFMT)&#123;<span class="comment">//取出高四位表示文件类型</span></span><br><span class="line">        <span class="keyword">case</span> S_IFBLK : str[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR : str[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR : str[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO : str[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK : str[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG : str[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK : str[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt; <span class="number">10</span> ; ++i, ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mode &amp; mask)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(i % <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: str[i] = <span class="string">&#x27;x&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: str[i] = <span class="string">&#x27;r&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: str[i] = <span class="string">&#x27;w&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str[i] = <span class="string">&#x27;-&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        mask /= <span class="number">2</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./ls_l path</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    DIR* pdir = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    ERROR_CHECK(pdir, <span class="literal">NULL</span>, <span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">    <span class="comment">//列出目标目录下的详细信息 先进到这个目录</span></span><br><span class="line">    <span class="keyword">int</span> ret = chdir(argv[<span class="number">1</span>]);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">    <span class="comment">//进到目标目录读, dirent的结构体信息不够丰富，使用stat函数,它有一个struct stat *statbuf的传入传出参数</span></span><br><span class="line">    <span class="comment">// 由主调准备它</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">pdirent</span>;</span></span><br><span class="line">    <span class="keyword">while</span>((pdirent = readdir(pdir)) != <span class="literal">NULL</span>)&#123;<span class="comment">//注意readdir的用法</span></span><br><span class="line">        <span class="keyword">int</span> ret = stat(pdirent-&gt;d_name, &amp;statbuf);<span class="comment">//只读dirent信息不够丰富，使用stat</span></span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="comment">// 按照ls -l命令的需求使用stat结构体的字段</span></span><br><span class="line">        switch_mode(statbuf.st_mode);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %ld %s %s %6ld %s %d %d:%d %s\n&quot;</span>,</span><br><span class="line">            <span class="comment">// statbuf.st_mode,</span></span><br><span class="line">            statbuf.st_nlink,</span><br><span class="line">            getpwuid(statbuf.st_uid)-&gt;pw_name,<span class="comment">//stat结构体中是id转换成字符串</span></span><br><span class="line">            getgrgid(statbuf.st_gid)-&gt;gr_name,</span><br><span class="line">            statbuf.st_size,</span><br><span class="line">            <span class="comment">// ctime(&amp;statbuf.st_mtime),</span></span><br><span class="line">            switch_mon(localtime(&amp;statbuf.st_mtime)-&gt;tm_mon), <span class="comment">//对获取的时间信息做点修改</span></span><br><span class="line">            localtime(&amp;statbuf.st_mtime)-&gt;tm_mday,</span><br><span class="line">            localtime(&amp;statbuf.st_mtime)-&gt;tm_hour,</span><br><span class="line">            localtime(&amp;statbuf.st_mtime)-&gt;tm_sec,</span><br><span class="line">            pdirent-&gt;d_name</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(pdir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tree</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现tree命令的效果。使用深度优先遍历递归实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给出路径与画结构的间隔宽度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFSerch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line">    DIR* pdir = opendir(path);</span><br><span class="line">    ERROR_CHECK(pdir, <span class="literal">NULL</span>, <span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">pdirent</span>;</span></span><br><span class="line">    <span class="keyword">char</span> newpath[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>((pdirent = readdir(pdir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//不必显示 . .. 注意字符串比较 其他的项先打印空格再打印名字</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pdirent-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(pdirent-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pdirent-&gt;d_name);</span><br><span class="line">        <span class="comment">//key 遇见子目录的情况，生成新路径递归</span></span><br><span class="line">        <span class="keyword">if</span>(pdirent-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(newpath, <span class="string">&quot;%s%s%s&quot;</span>, path, <span class="string">&quot;/&quot;</span>, pdirent-&gt;d_name);</span><br><span class="line">            DFSerch(newpath, width+<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./myTree .</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    DFSerch(argv[<span class="number">1</span>], <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-基于文件描述符操作文件-文件操作-基于系统调用-不带缓冲的文件IO"><a href="#3-3-基于文件描述符操作文件-文件操作-基于系统调用-不带缓冲的文件IO" class="headerlink" title="3.3 基于文件描述符操作文件 || 文件操作-基于系统调用(不带缓冲的文件IO)"></a>3.3 基于文件描述符操作文件 || 文件操作-基于系统调用(不带缓冲的文件IO)</h4><blockquote><p>所谓的不带缓冲，不带的是用户态文件缓冲区。如下图所示 注意也是内存中，只是相对在内核部分</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E4%B8%8D%E5%B8%A6%E7%BC%93%E5%86%B2IO.png" alt="不带缓冲的文件IO"></p><blockquote><p>使用文件本质是把磁盘与用户建立连接，但这件事情是OS做的，OS在内核态建立了文件对象，直接与硬件对应，如果要让用户直接通过指针去操作这些文件对象，显然是不合适的。这就引入了新的结构—索引数组，用户可以通过索引数组的下标:文件描述符去间接的找到真正的文件</p><p>即：进程空间的内核部分维护一个已打开文件的数组，管理所有已打开的文件，文件描述符是这个数组的索引(文件描述符：非负整数，是指针数组的下标，用于找到文件对象)。</p><p>其实日常所用的<code>stdin, stdout, stderr</code>就是最常见的文件对象 任意一个进程都默认打开这三个文件对象，他们的文件描述符即<code>0,1,2</code></p></blockquote><p><code>OPEN(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">//有两个版本，是用宏实现的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> the <span class="keyword">new</span> file descriptor, <span class="keyword">or</span> <span class="number">-1</span> <span class="keyword">if</span> an error occurred .</span><br><span class="line">从这里就能隐约看出一点不同，fopen执行成功返回的是一个文件指针，会在用户态有一块内存空间，先把数据拷贝去FILE结构体。FILE结构的本质是一块缓冲区。</span><br><span class="line">而open则不同，返回的是一个整数值——文件描述符，会通过它实现进程与打开文件间的交互。</span><br><span class="line">&gt;$ man open 可以看到一段open 与fopen对应关系的描述</span><br><span class="line">    </span><br><span class="line">The file descriptor associated with the stream is opened as <span class="keyword">if</span> by  a  call</span><br><span class="line">to open(<span class="number">2</span>) with the following flags:</span><br><span class="line"></span><br><span class="line">              ┌─────────────┬───────────────────────────────┐</span><br><span class="line">              │fopen() mode │ open() flags                  │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     r       │ O_RDONLY                      │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     w       │ O_WRONLY | O_CREAT | O_TRUNC  │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     a       │ O_WRONLY | O_CREAT | O_APPEND │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     r+      │ O_RDWR                        │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     w+      │ O_RDWR | O_CREAT | O_TRUNC    │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     a+      │ O_RDWR | O_CREAT | O_APPEND   │</span><br><span class="line">              └─────────────┴───────────────────────────────┘</span><br><span class="line">    </span><br><span class="line">[补]</span><br><span class="line"><span class="keyword">int</span> creat(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode); <span class="comment">//文件名 权限 </span></span><br><span class="line"><span class="comment">//creat现在已经不常用了，它等价于</span></span><br><span class="line">open(pathname,O_CREAT|O_TRUNC|O_WRONLY,mode);</span><br></pre></td></tr></table></figure><p><code>CLOSE(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">调用close，则该进程对文件所加的锁全都被释放，并且使文件的打开引用计数减<span class="number">1</span>，</span><br><span class="line">只有文件的打开引用计数变为<span class="number">0</span>以后，文件才会被真正的关闭。</span><br></pre></td></tr></table></figure><blockquote><p>使用read和write来读写文件，它们统称为不带缓冲的IO</p></blockquote><p><code>READ(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; <span class="comment">//出错返回-1， 读完返回0， 其他返回读写个数</span></span><br></pre></td></tr></table></figure><p><code>WRITE(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>只是这么看的话,对于不带缓冲IO的感觉挺迷的，想一想<code>read</code>和<code>fread</code>的区别, 使用<code>read</code>读CPU陷入内核态处理文件读取，频繁使用<code>read</code>读取少量数据则数据读取效率较低。而<code>fread</code>是有缓冲的,它在用户态有文件缓冲区，达到一定条件时才向文件对象中写。这个条件可能是缓冲区满了，也可能是读取结束。这就减少了系统调用的次数，可能缓冲满才进行一次状态切换。当然，代价是多进行了一次拷贝。如下方示意图；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2.png" alt="状态切换"></p><blockquote><p>接下来使用前面的知识实现一下<code>cp -r</code></p></blockquote><p><code>cp -r</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpdir</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *src, <span class="keyword">char</span> <span class="keyword">const</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpfile</span><span class="params">(<span class="keyword">char</span> *src, <span class="keyword">char</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./cp_r src dst</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    cpdir(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpdir</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *src, <span class="keyword">char</span> <span class="keyword">const</span> *dst)</span></span>&#123;</span><br><span class="line">    mkdir(dst, <span class="number">0755</span>);</span><br><span class="line">    <span class="comment">//创建目标目录，定义一个基类型为目录项结构体的指针用于遍历(流式结构指针自动后移)源目录,打开源目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">pdirent</span>;</span></span><br><span class="line">    DIR* pdir = opendir(src);</span><br><span class="line">    <span class="keyword">char</span> newsrc[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> newdst[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ERROR_CHECK(pdir, <span class="literal">NULL</span>, <span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历源目录，跳过目录项 . 和 .. 目录项类型为DT_DIR先配置好新地址然后递归，目录项类型为其他文件copy</span></span><br><span class="line">    <span class="keyword">while</span>((pdirent = readdir(pdir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pdirent-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(pdirent-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//注意C的字符串比较</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//和tree稍有不同tree是遍历到直接打印，遇到子目录才递归进去，cp -r不管是不是子目录都需准备新目标地址，因为只给了目录</span></span><br><span class="line">        <span class="built_in">sprintf</span>(newsrc, <span class="string">&quot;%s%s%s&quot;</span>, src, <span class="string">&quot;/&quot;</span>, pdirent-&gt;d_name);</span><br><span class="line">        <span class="built_in">sprintf</span>(newdst, <span class="string">&quot;%s%s%s&quot;</span>, dst, <span class="string">&quot;/&quot;</span>, pdirent-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span>(pdirent-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">            cpdir(newsrc, newdst);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cpfile(newsrc, newdst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpfile</span><span class="params">(<span class="keyword">char</span> *src, <span class="keyword">char</span> *dst)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fdr = open(src, O_RDONLY);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(dst, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = read(fdr, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">//注意read与write的常用法</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(fdw, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他的文件操作 ：改变文件大小<code>ftruncate</code>，文件映射机制<code>mmap</code>配合<code>ftruncate</code>使用</p></blockquote><p><code>TRUNCATE(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>mmap</code>可以将一个磁盘文件映射到存储空间的一个缓冲区上，无需使用<code>read</code>和<code>write</code>进行IO</p></blockquote><p><code>MMAP(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个文件，里边内容为hello，通过mmap映射该文件后，修改hello为world，然后解除映射。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./mmap file</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> cut = ftruncate(fd, <span class="number">5</span>);</span><br><span class="line">    ERROR_CHECK(cut, <span class="number">-1</span>, <span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line">    <span class="comment">//建立映射关系</span></span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">5</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>); </span><br><span class="line">    ERROR_CHECK(p, MAP_FAILED, <span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    munmap(p,<span class="number">5</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-4-IO多路转接模型"><a href="#3-4-IO多路转接模型" class="headerlink" title="3.4 IO多路转接模型"></a>3.4 IO多路转接模型</h4><h2 id="写在后面-结"><a href="#写在后面-结" class="headerlink" title="写在后面(结)"></a>写在后面(结)</h2><blockquote><p>还是太菜，任重而道远</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Unix/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_Summarize_with_code</title>
      <link href="/2022/02/17/5.C-Summarize-with-code/"/>
      <url>/2022/02/17/5.C-Summarize-with-code/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote><p>接上篇<a href="https://lacsscal.github.io/2022/02/10/C-Summarize/">总结1</a> 上篇更多偏向文字叙述，以及一些概念方面的整理与思考，本篇结合一些常用的数据结构以及算法，换一个论述点再做一些整理</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1.基本数据结构"></a>1.基本数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="2-常见排序算法"><a href="#2-常见排序算法" class="headerlink" title="2. 常见排序算法"></a>2. 常见排序算法</h3><blockquote><p>关于排序算法分析</p><p>1.时间复杂度</p><p>冒泡排序，插入排序，简单选择排序无法突破<code>O(n2)</code>时间复杂度，因为其有序化过程中都是一个一个来减少逆序度的，当逆序度为0时整个序列有序，相对的希尔，并归，快排，堆排能突破是因为其不依赖相邻元素逐个排序。</p><ul><li><p>最好，最坏，平均   </p><p>分析时间复杂度，要给出 最好，最坏，平均情况下的时间复杂度(给出最好，最坏情况下对应要排序的原始数据情况)</p><ul><li><p>平均时间复杂度分析</p><p>n个元素有n!种排序，然后统计比较和交换的次数，再计算平均值。想想就十分复杂。</p><p>这里我们采用逆序对的方式来分析。</p><p>有序元素对：<code>arr[i] &lt;= arr[j], i &lt; j  </code></p><p>逆序元素对：<code>arr[i] &gt; arr[j], i &lt; j</code></p><p>有序度：数组中有序元素对的个数</p><p>逆序度：数组中逆序元素对的个数</p><p>满有序度：数组排好序后的有序度。</p><p>假设数组有n个元素，满有序度 =  <code>n(n-1)/2</code></p><p>公式： 满有序度 = 有序度 + 逆序度排序过程就是增加有序度，减少逆序度，最终达到满有序度的过程。</p></li></ul></li><li><p>常数，系数，低阶  </p><p>时间复杂度反应规模n很大时的增长趋势，忽略常数，系数，低阶(考虑规模小的数据时考虑这些因素)</p></li><li><p>比较， 交换  </p><p>基于比较的排序算法涉及元素的比较，交换，分析效率要考虑这些</p></li></ul><p>2.空间复杂度  </p><p>是否是原地算法</p><p>3.稳定性  </p><p>待排序列中存在值相等的元素，排序后这些元素间的前后关系是否不变</p></blockquote><p><code>bubble</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// i 表示冒泡的次数，也就是比较的趟数</span></span><br><span class="line">        <span class="keyword">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//每趟比较中，j从0开始取相邻两个元素比较(交换),每趟一定有一个元素有序排好，可以利用i</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;<span class="comment">//做点优化，使得有序(这趟没执行交换)之后结束排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有序度是数组中具有有序关系的元素对的个数。如果一个数组完全有序，有序度就是<code>Cn2 = n(n-1)/2</code>，这种叫做满有序度。</p><p>对于冒泡排序来说，交换会导致：有序度+1， 逆序度-1.</p><p>所以 交换的次数 = 逆序度。可以简单的认为平均情况下，逆序度 = <code> n(n-1)/4</code> 比较的次数肯定比交换的次数多，但少于 <code>n(n-1)/2</code>所以平均情况下，时间复杂度为<code>O(n2)</code></p></blockquote><p><code>selection</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// i表示选择元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = i;<span class="comment">//先预设当前索引所指数为最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//j从后一个元素开始向后找有无更小的</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每趟先假定本趟开头为最小元素，记录其索引，从其后一个元素开始向后遍历，找到更小的，更新最小元索引记录一趟走完交换本趟开头与最小<br>发生长距离的交换 所以不稳定</p><p>[5, 5, 1, 2, 3, 0, ]第一个5换到第二个5后面</p><p><code>O(n2) </code>不存在最好最坏，都是<code>O(n2)</code></p></blockquote><p><code>insertion</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">// i代表待插入元素的索引，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">int</span> val = arr[i];<span class="comment">//先记录，如果要插到前面的话需要前方元素后移，可能会覆盖它</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">//找到待插元素的前一个元素</span></span><br><span class="line">        <span class="comment">// 元素(比记录的待插元素大)往后移(凡比ta大的都后移，留出ta的位置)</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从第二个元素开始，每趟排序使当前遍历元素变得有序，取出元素值后先记录，往前找，凡前前面的元素(认为是有序序列)比ta大的，都后移，留出ta的位置，把它插入</p><p>最好<code>O(n) </code>比较n-1此，序列有序，不做交换</p><p>最坏O(n2)</p><p>逆序度分析平均时间复杂度 </p><p>稳定</p></blockquote><blockquote><p>选择排序一般不使用，冒泡排序一般也不用，</p><p>可能会用到的是插入排序为什么选择插入而不选择冒泡选择O()表示法省略了系数项和低阶项</p></blockquote><p><code>shell</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 组间插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123; <span class="comment">//还是插入排序的特性，先取后面的元素，只是这里用增量序列分组</span></span><br><span class="line">                                        <span class="comment">//i = gap 以 n = 10 个数为例 每轮 gap /= 2;  </span></span><br><span class="line">                                        <span class="comment">// 8 9 1 7 2 3 5 4 6 0  gap = 5</span></span><br><span class="line">                                        <span class="comment">// |         |</span></span><br><span class="line">                                                     i</span><br><span class="line">            <span class="keyword">int</span> val = arr[i];    <span class="comment">//组内比大小交换</span></span><br><span class="line">            <span class="keyword">int</span> j = i - gap;    </span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];<span class="comment">//每组前面的值先赋值给后面的值</span></span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = val; <span class="comment">//先减掉后加上用于交换赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缩小gap</span></span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(缩小增量排序)插入排序的优化版本 (第一批突破<code>O(n^2))</code>基于插入排序的性质提出改进方法  </p><ul><li><p>插入排序对基本有序的数据操作时，效率高。  </p></li><li><p>插入排序的缺点:每次比较相邻两个元素:对于基本有序的数组，一直比较相邻元素若有插入距离远的将比较多次，不适合</p></li></ul><p>希尔有先比较 距离远的(使得数据基本有序)基本有序的元素交换距离短</p><p>选择一个增量序列gap:(希尔推荐:n/2, n/4, …, 1)，分组，然后组间插入排序缩小增量 再分组 组间插入排序</p><p>插入排序:当数组基本有序，性能好(利用这一点)的有限，并解决不能长距离交换元素的缺点</p><p>长距离交换元素 不稳定</p><p>时间复杂度小于<code>O(n^2),</code>与增量序列有关</p></blockquote><p><code>merge</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//所给的接口感觉不好实现，在函数内部做一层封装委托出去</span></span><br><span class="line">    merge_sort1(arr, <span class="number">0</span>, n - <span class="number">1</span>);       <span class="comment">//知道数组的长度，把头当左界，尾当右界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;<span class="comment">//采用分治的思想，假定已有部分子序列有序，把他们合并</span></span><br><span class="line">                                                  <span class="comment">//至于怎么得到有序的子序列anyway，先不管，交个计算机，我只考虑这一层</span></span><br><span class="line">    <span class="comment">// 边界条件                                      //使用递归来做</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 递归公式</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);       <span class="comment">//使用已知的左右界求得中间节点，作为下层的右界，左界</span></span><br><span class="line">    merge_sort1(arr, left, mid);                  <span class="comment">//下层将要给我的是有序的左半边子序列 右半边子序列，实现合并即可</span></span><br><span class="line">    merge_sort1(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(arr, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;<span class="comment">//关键 实现归并操作</span></span><br><span class="line">    <span class="keyword">int</span>* temp = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>((right - left + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//先分配长度为n的辅助数组，排序过程中先将数据存入辅助序列</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;  <span class="comment">//两半有序子序列合并成整个有序序列</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;       <span class="comment">//Caution: 不能是 arr[i] &lt; arr[j] 相等的左边仍在前面 保证稳定性</span></span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;                  <span class="comment">//如果有一边的数据未取完，剩余的全复制过去</span></span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[left + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(nlog n)</code>的时间复杂度。代价是需要额外的内存空间<code>O(n) </code> tmp数组辅助。</p><p>稳定</p><p>建立在归并操作上的一种有效的排序算法是采用分治法（Divide and Conquer）(一种算法设计思想，策略)的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；</p><p>即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p></blockquote><p><code>Quick</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//同样，给定的接口不太好实现，可以利用已有的信息构建自己的内部接口委托实现</span></span><br><span class="line">    quick_sort1(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; <span class="comment">// pivot 枢 基准 定标点， 从数列中挑出元素做基准定标点</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)                               </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = partition(arr, left, right);         <span class="comment">// 这个pivot的选取由分区函数实现，可以认为它有序了</span></span><br><span class="line">                                                   <span class="comment">// 接下来下层函数实现 pivot左边和右边的排序</span></span><br><span class="line">    quick_sort1(arr, left, idx - <span class="number">1</span>);</span><br><span class="line">    quick_sort1(arr, idx + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;    <span class="comment">//那么怎么找到这个定标点，使得比它小的在它左边，大的在它右边</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];                         <span class="comment">//定标的过程中也完成了局部的排序， 先选定pivot在最左侧(有不同选法)</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123;           <span class="comment">//本例做法:标定在左边，先判右边，在右边找到比pivot小的，</span></span><br><span class="line">            j--;        </span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[j];                           <span class="comment">//填入pivot的位置，而这个位置的值暂存在pivot中也不会丢失</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123;           <span class="comment">//再判断左边，此时arr[i]为新填入，一定会向右走，当遇到比pivot大的</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = arr[i];                           <span class="comment">//填到刚才换走数据的位置中</span></span><br><span class="line">    &#125;<span class="comment">//当i, j 相遇，此时比pivot小的已经全部换去左边，比pivot大的已经全部换去右边，这里是pivot的正确位置，填入并返回</span></span><br><span class="line"></span><br><span class="line">    arr[i] = pivot;    <span class="comment">//来回交换，但一次始终只交换一个，由pivot暂存有一个值，所以不会有数据丢失</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>实现简答，变种多，性能好(桶排序和计数排序不基于比较 所以能突破<code>O(nlog(n))</code>)</p><p>算法思路：</p><ol><li>从数列中挑出一个元素，称为 “基准”<code>（pivot）</code>；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置(也是它最终的位置)。这个操作我们称之为分区<code>(partition)</code>；</li><li>递归地<code>(recursive)</code>把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>最坏情况：<code>O(n^2) </code>每次分区，基准都位于最右边或者最左边<code> T(n) = T(n-1) + O(n) = T(n-2) + O(n-1) + O(n) =.....</code>.;  <code>partition</code> 为<code>O(n)</code> 两个指针 i, j 分别遍历<br>最好情况：<code>O(nlogn)</code>每次分区，基准值都位于中间， <code>T(n) = 2T(n/2) + n; </code>每次问题规模折半</p></blockquote><p><code>heap</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;     <span class="comment">//先构建大顶堆，使堆顶最大，左右子树也是大顶堆</span></span><br><span class="line">    build_heap(arr, n);             <span class="comment">//传入序列与长度完成构建,取最大值做顶</span></span><br><span class="line">    <span class="keyword">int</span> length = n;                 <span class="comment">//此时还没进行排序，认为 无序区的长度为 n</span></span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">1</span>) &#123;            <span class="comment">//单个节点为最小大顶堆</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, length - <span class="number">1</span>);   <span class="comment">//将此时的顶换至末尾，减少序列长度-&gt;认为最大(顶)排序完成</span></span><br><span class="line">        length--;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, length);    <span class="comment">//将长度减少的序列重新调整成大顶堆，实际最大数据已经填在数组正确位置不再对它操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到最后一个有孩子的结点         //分析数组，先把无序的数组认为是一个完全二叉树，要让这个数组满足大顶堆的性质</span></span><br><span class="line">                                    <span class="comment">//无序的完全二叉树不是堆，需要调整</span></span><br><span class="line">                                    <span class="comment">//调整从数组的末尾开始做起，找到最后一个有孩子的节点，认为它的孩子是大顶堆</span></span><br><span class="line">                                    <span class="comment">//把这个节点和它的孩子们这棵子树调整成大顶堆</span></span><br><span class="line">                                    <span class="comment">//往数组的前面继续...</span></span><br><span class="line">    <span class="comment">// 数组从0 开始编号 左孩子为2i+1 右孩子为 2i+2</span></span><br><span class="line">    <span class="comment">// i:  leftChild=2i + 1, rightChild = 2i + 2;</span></span><br><span class="line">    <span class="comment">// 找最后一个有孩子的节点序号i 判断有孩子，只要有左孩子就行</span></span><br><span class="line">    <span class="comment">// 2i + 1 &lt;= n - 1 --&gt; i &lt;= (n - 2) / 2;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//从最后一个有孩子的节点开始调整，调整完后下一个调整的是数组中排在它前面的</span></span><br><span class="line">        heapify(arr, i, n);                     <span class="comment">//依次完成调整，构建大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//从上往下调整为大顶堆</span></span><br><span class="line">                                         <span class="comment">//记录并与左右孩子比较</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = i;</span><br><span class="line">        <span class="keyword">int</span> leftChild = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightChild = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftChild &lt; n &amp;&amp; arr[leftChild] &gt; arr[maxIdx]) <span class="comment">//限制避免数组越界再比较</span></span><br><span class="line">            maxIdx = leftChild;</span><br><span class="line">        <span class="keyword">if</span> (rightChild &lt; n &amp;&amp; arr[rightChild] &gt; arr[maxIdx])</span><br><span class="line">            maxIdx = rightChild;</span><br><span class="line">        <span class="keyword">if</span> (maxIdx == i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i, maxIdx);</span><br><span class="line">        i = maxIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>二叉堆 完全二叉树</p><p>大顶堆：堆顶元素最大，左右子树也是大顶堆</p><p>小顶堆：堆顶元素最小，左右子树也是小顶堆</p><p>堆:近似完全二叉树:性质:子节点的键值或索引总是小于（或者大于）它的父节点 </p><p><em>Wikipedia</em></p><p>以升序排序说明，把数组转换成最大堆(Max-Heap Heap)，这是一种满足最大堆性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。</p><p>思路：</p><ol><li>构建大顶堆</li><li>交换堆顶和无序区最后一个元素 此后 无序区元素个数-1，有序区元素个数+1</li><li>把无序区重新调整成大顶堆O(log(n))重复步骤2</li></ol><p>完全二叉树可以用数组去做-&gt;把待排序数组看成堆</p><p>先把待排序数组看做无序的完全二叉树 数组从前到后对应树的层序 ： 这个无序的完全二叉树不是堆，需要调整</p><p><strong>定义：单个节点的树是大顶堆</strong>找到第一个有孩子的节点 它的左右孩子一定是大顶堆然后把第一个有孩子的这棵树构建成大顶堆(做法:这个有孩子的节点与其左右孩子比较，大的改为父亲节点) –&gt;获得了第一个是大顶堆的子树以此类推-&gt;从后往前找，判，变      </p><p>大顶堆构建完成<br>由构建的过程知，堆顶元素为数组中最大元素，堆顶元素位于数组中索引为0的位置，交换它与数组的末尾</p></blockquote><p><code>二叉搜索与其变种</code></p><p><code>递归实现</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 递归公式</span></span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line"><span class="keyword">return</span> binary_search1(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)</span><br><span class="line"><span class="keyword">return</span> binary_search1(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">return</span> binary_search1(arr, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>循环实现</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>变种 </code>查找第一个与target相等的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid == left || arr[mid - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找最后一个小于等于target值的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt;= target) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == right || arr[mid + <span class="number">1</span>] &gt; target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找最后一个与key相等的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找3</span></span><br><span class="line"><span class="comment">//&#123; 0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 4, 5, 6, 7, 8, 9 &#125;;</span></span><br><span class="line"><span class="comment">//                             |</span></span><br><span class="line"><span class="comment">//     返回9</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; target) &#123;<span class="comment">//向右缩小范围</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;<span class="comment">//向左缩小范围</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (mid == right || arr[mid+<span class="number">1</span>] &gt; target) &#123;<span class="comment">//处理相等，走到末尾(此时右边界)或者下个大于target可返回</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找第一个大于等于key值的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; target) &#123;<span class="comment">//向右缩小范围</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid == left || arr[mid<span class="number">-1</span>] &lt; target) &#123;<span class="comment">//当前arr[mid]&gt;= target 向左走到边界 或者遇见小的</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="写在后面-结"><a href="#写在后面-结" class="headerlink" title="写在后面(结)"></a>写在后面(结)</h2><blockquote><p>本次关于C的整理梳理工作暂时告一段落，总的来说，起初的基础知识方面的整理有些浮躁，不耐烦，但是在重看过程中发现了不少之前未注意到的点，多对自己提问，试图站在作者的角度思考这个问题的产生与解决，分析需求并给出解决办法是有好处的，新的视角会带来一些未曾有过的思考。</p><p>同时也发现学过或者说学过不止一遍不代表就是懂得，就是精通。越发感觉此前的学习方式存在不少问题。<strong>Talk is cheap. Show me the code.</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C Summarize</title>
      <link href="/2022/02/10/4.C-Summarize/"/>
      <url>/2022/02/10/4.C-Summarize/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote><p>  对于C的学习，已经反复好多次了，前面一直想要做个系统的梳理，但总是会出各种状况。之前有过跟着视频学习，自己对着书看写例程写课后题等等，最完整的一次梳理是在2020年的寒假，那次花了比较多的时间，从重看翁恺老师的视频开始，后续继续看了《K&amp;R》《C陷阱与缺陷》《C和指针》《C专家编程》等书。前期跟视频以及看《K&amp;R》可能算是做到了专注，精读，但后面有完成任务式的阅读，最终感觉效果不佳。当然，那段时间确实感觉有较大的提升，可后面因为一些事情耽误，很长一段时间没有再碰过。</p><p>最近打算重新系统梳理相关知识。这次打算配合最近捡起的知识点及写的程序，对C做大致的总结梳理。(总结自用，可能不甚严谨)</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-历史"><a href="#0-历史" class="headerlink" title="0.历史"></a>0.历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ken Thompson为了游戏(Space Travel)</span><br><span class="line">Multics -&gt; Unics(最初汇编PDP-7,移植性问题-&gt;发明BCPL:B语言)-&gt;</span><br><span class="line">Dennis Ritchie加入</span><br><span class="line">Dennis Ritchie-&gt;B不适合Unics(内核)开发:发明C -&gt; 用C重写Unics更名为Unix</span><br></pre></td></tr></table></figure><blockquote><p>结论： C用来<strong>开发系统软件</strong> (重写Unics系统,而此系统是K为了发挥PDP-7的全部性能以玩游戏而产生的)：       </p><p>所以C没有try-catch机制(耗费性能)       C与汇编有强对应关系</p></blockquote><h3 id="1-虚拟内存空间"><a href="#1-虚拟内存空间" class="headerlink" title="1.虚拟内存空间"></a>1.虚拟内存空间</h3><blockquote><p>源码经-&gt;预处理-&gt;编译-&gt;汇编-&gt;链接  程序-静态</p></blockquote><blockquote><p>变成了可执行文件，而可执行文件加载进内存变为进程，用于独立的虚拟内存空间 进程-动态</p></blockquote><p><img src="https://s2.loli.net/2022/02/15/fDxObctmSZCYWNM.png" alt="虚拟内存空间.png"></p><p>每个进程有自己的虚拟内存空间，而这个图可以辅助理解一些语言以及程序的相关特性。</p><blockquote><p>如：</p><ol><li>0x00000000 NULL 预留出不能访问 再将其定义为宏 #define 0x00000000 NULL (减少magic number)</li><li>HEAP 向上增长，结构体之类，程序员自行管理(如何申请，如何释放)</li><li>STACK 向下增长 存栈帧(活动记录：编译器实现过程调用的数据结构),存局部变量，运行函数</li><li>虚拟地址空间分区:高地址-&gt;低地址：OS区, 栈, 堆, 代码段数据段, NULL;</li><li>大端小端: 多字节数据布局问题<br>little-endian: 低地址存低位:小端: 0a 00 00 00(存10(0a)， 低–&gt;高)<br>big-endian   : 低地址存高位:大端: 00 00 00 0a<br>多字节间(00 00 00 0a)数据顺序相反，字节内(0a)不变</li><li>为什么OS存放在高地址:几乎所有OS都这么设计，编程要计算内存资源做地址分配，从低地址开始比较合理<br>OS为用户程序服务，映射到高地址<br>放在高地址用户程序很难碰到，在实模式时期也能最大程度兼容用户程序(使之保有原地址而不是后移)</li></ol></blockquote><h3 id="2-未曾想过并认为理所当然的问题"><a href="#2-未曾想过并认为理所当然的问题" class="headerlink" title="2. 未曾想过并认为理所当然的问题"></a>2. 未曾想过并认为理所当然的问题</h3><blockquote><p>关于之前没有关注过的认为理所当然的问题 辅助理解编译器给出的一些信息<br>1.<br>什么是表达式，语句，表达式语句<br>表达式(计算某值的公式)有值 按C的语言规定，很多地方需要给一个表达式 比如 while(…){}括号中需要一个表达式<br>所以<code>while(int i)&#123;&#125;</code>报错 <code>int i</code>不是一个表达式(是初始化语句?)<br>表达式以;结尾变成表达式语句<br>为什么编译器有时提示xxx不做 左值(一片存储空间)<br>表达式就不能做左值(它是计算某个值的公式)这个值应该是固定的不能让它改变也就不能做左值<br><code>&#123;...&#125;</code>是复合语句，让编译器将{}内的语句理解为一条语句</p><p>2.<br>为什么宏定义不用分号做结尾 <code>#define N 10</code><br>ta是预处理指令，是指令而不是语句，因此不用;结尾<br>预处理时是直接把它复制做文本替换的</p><p>3.<br>为什么<code>scanf()</code>, <code>printf()</code>函数能处理不定参数，这是怎么做到的?<br>可以输出输入多个参数的值，但又不知道多个几个</p><p>4.<br>知道优先级这个概念与内容<br>但是编译器是怎么理解并解析优先级的?</p><p>5.<br>为什么 <code>switch-case</code> 中 <code>case:</code> 后不需要加花括号{}<br>case是标签</p><p>6.<br><code>while do-while for</code> 之间的替换问题<br>由于<code>for(int i = 0; i &lt; n; ++i)</code>//将循环条件的改变放在语句中 所以在使用continue;时不要用它做替换</p><p>7.<br>为什么数组元素需要类型相同(一片连续内存，并且它被划分为大小相等的小空间)<br>为了随机访问-&gt;寻址公式:<code> address_i = base_address + i * sizeof(type);</code><br>为什么数组下标从0开始？<br>也是为了实现寻址公式。从1开始寻址会变为<code>address_i = base_address + (i-1) * sizeof(type); </code><br>或者不用第一个空间(浪费)则公式不变<code>address_i = base_address + i * sizeof(type);</code></p><ol start="8"><li>为什么函数不返回数组(做参数带出是可以的)<br> 要让它做返回值，说明是在这个函数周期内声明的?函数返回时，本地变量生存期结束，回收返回野指针?</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findMinMax</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="comment">/*** WRONG ***/</span></span><br><span class="line"> <span class="keyword">int</span> result[<span class="number">2</span>];</span><br><span class="line"> result[<span class="number">0</span>] = result[<span class="number">1</span>] = arr[<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (arr[i] &lt; result[<span class="number">0</span>])</span><br><span class="line">         result[<span class="number">0</span>] = arr[i];</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; result[<span class="number">1</span>])</span><br><span class="line">         result[<span class="number">1</span>] = arr[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样返回的指针也是指向当前函数的栈帧区域的，函数返回，这片区域不可控，变为野指针</p><p>9.<br>带参宏 <code>#define SIZE(a) (sizeof(a) / sizeof(a[0]))</code>挺好用的 </p><p>10.<br>为什么数组名在传递给函数时被视为指针？<br>C只有值传递，早期考虑传递数组整个copy耗时耗内存<br>所以使传递数组为参数时退化为指针(为什么会用“退化”–&gt;与隐式类型转化相似)<br><code>int find_largest(int a[], int n)&#123;&#125;</code><br><code>int find_largest(int *a, int n)&#123;&#125;</code>这样写可读性差，但更接近本质</p><p>11.<br>编译器帮忙补全的main()的参数<code>int main(int argc, char const *argv[])</code><br>命令行参数<br>OS调用<code>main(int argc, char const *argv[]) </code>并传参给它<br><code>argc   </code> : 参数计数<br><code>*argv[] </code>: 参数组，第一条参数为 函数名<br>有了这个特性<br>传递给<code>main()</code>不同的参数，可以产生不同的行为(.e.g:文件操作不再需要写死文件地址)“由命令行参数改变函数行为”</p><p>12.<br>使用free()函数时，参数只是给了一个 指针(指向某片内存的首地址)，free怎么知道要释放多少内存?<br>在之前分配内存时就给出了此块内存占多少字节 (关于这点可以看《CS:APP》free_list空闲链表)(free为程序员减负)?</p></blockquote><p><img src="https://s2.loli.net/2022/02/15/7G4lhe9OjHZXMig.png" alt="优先级表.png"></p><p><img src="https://s2.loli.net/2022/02/15/One4RJdaDyXchmp.png" alt="ASCII表.png"></p><h3 id="3-递归-recursion"><a href="#3-递归-recursion" class="headerlink" title="3. 递归 recursion"></a>3. <strong>递归 recursion</strong></h3><p>定义时调用本身 (传统引例为:斐波那契数列求和，其实这并不是一个很好的例子(画出递归树可知有<strong>太多重复计算</strong>性能差))</p><p><strong>但作为分析案例是合适的</strong></p><p>它满足以下条件：</p><ul><li>大问题分解为小问题</li><li>大小问题求解方式一致，只是规模不同</li><li>小问题的解可合成大问题的解</li></ul><p>可是使用递归，但注意在递归代码书写时，一定要有:</p><ul><li><p>边界条件(没有的话会调用下去直到Stack Overflow)</p></li><li><p>递归公式要考虑重复计算问题:</p></li></ul><p>以斐波那契为例，由于存在重复计算问题，其实效率不高</p><p>总结：<strong>得出递归公式，知道边界条件且解决重复计算问题可用递归</strong></p><p>更经典的例子:</p><p><strong>汉诺塔问题 Hanoi</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> start, <span class="keyword">char</span> middle, <span class="keyword">char</span> end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hanoi(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> start, <span class="keyword">char</span> middle, <span class="keyword">char</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, start, end); <span class="comment">//记得设置边界条件，不然会一直递归下去</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        hanoi(n<span class="number">-1</span>, start, end, middle);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, start, end);</span><br><span class="line">        hanoi(n<span class="number">-1</span>, middle, start, end);</span><br><span class="line">    &#125;<span class="comment">//抽象的思考问题，不要考虑具体实现细节，交个计算机来做，只想这一步该完成什么(这里即:将前n-1个经end移至middle)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>约瑟夫问题 Joseph (只是其中一种，隔一个杀一个的情况)</strong></p><p><img src="https://s2.loli.net/2022/02/15/nX2uet4WBZEpqib.png" alt="约瑟夫环.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jos</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,  jos(<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jos</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//边界条件</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * jos(n / <span class="number">2</span>) - <span class="number">1</span>; <span class="comment">//输入偶数的规模与编号关系</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * jos((n - <span class="number">1</span>) / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//隔一个杀一个的Joseph环，推导一定次数之后  得出规律</span></span><br></pre></td></tr></table></figure><p><strong>结论：递归是一种考虑问题的思想，可以降低问题的复杂度</strong></p><p><strong>使用递归时，不要用脑向下展开模拟，站在较高的角度，抽象的考虑当前这步：</strong></p><p><strong><code>hanoi</code>比较典型</strong></p><p><strong>当前这步将最大的圆盘n从 start –&gt; end而为了实现这步，需要将其上的n-1个盘从start –&gt; end –&gt; middle</strong></p><p><strong>当最大盘到end之后，将此时在middle上的n-1个盘 middle –&gt; start –&gt; end</strong></p><p><strong>anyway：中间的具体实现不去管它，交给计算机去一层层分解。</strong></p><h3 id="4-指针"><a href="#4-指针" class="headerlink" title="4.指针"></a>4.指针</h3><blockquote><p>在本次回顾与重学的过程中，改用了<code>Visual Studio</code>，相比于之前使用的<code>VsCode+MinGW</code>的方案，它的各种检查更加严格，使用起来没有之前那么间接方便，但是也帮助发现了不少之前没注意的细节问题。</p></blockquote><blockquote><p>1<br>野指针问题(没有初始化)但是对它解引用赋值了(属于未定义的行为)<br>注意 <code>int *p = 0x100;</code> 也是野指针，虽然初始化了，但是指向的区域不可控。<br>野指针指向未知(不可控)产生未定义的行为<br>空指针(“不指向任何地方的指针”)实现为指向<code>NULL(0x00000000)</code>但对其指向访问也是未定义的行为,可看做野指针的一种</p><p>2<br>由指针的算数运算特性，可以使用指针控制访问数组<br><code>char str[N] = &#123;0&#125;</code><br><code>for(char *p = str + N; p &gt; str; --p)&#123;&#125;</code> //使用指针而不是整数控制访问数组</p><p>3<br>数组名作为指向数组第一个元素的指针(数组名是个常量指针不能改其值)<br>反过来也能把指针当数组名用 <code>char *p = str; p[i] </code>编译器解释为<code>*(p + i)</code></p><p>4<br>字符串字面值是一个常量，使用指针指向它是不能用指针修改它的<br><code>*p = &quot;a string&quot;;</code> 使<code>p</code>指向字符串第一个字符<br><code>*p = &quot;b&quot; /*** WRONG ***/</code> 指向的字符串字面值是常量，不能修改</p><p>而<br><code>char data[9] = &quot;a string&quot;</code> 不是将字符串字面值给字符数组<br>其实是编译器帮我们做了一些工作，其本质为<br><code>char data[9] = &#123;&#39;a&#39;, &#39; &#39;, &#39;s&#39;, &#39;t&#39;, &#39;r&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;, &#39;\0&#39;&#125;   </code><br>所以其后<code>data[]</code>数组中的值是可以改变的</p><p>对比<br><code>char data[] = &quot;a string&quot;;</code>  字符数组 – 可修改data中字符           – data为数组名,不能改变指向<br><code>char *data  = &quot;a string&quot;;  </code>字符指针 – data指向字符串字面值,不可改  – data为指针变量,可改变指向<br>所以对要修改字符串的场景，使用字符数组存储。要使用指针的话，这个指针必须指向实际存在的字符数组。</p><p>5.<br>结构成员运算符 <code>“.”</code><br>结构指针运算符 <code>“-&gt;”</code><br><code>(*p).val = xx; &lt;=&gt; p-&gt;val = xx;</code></p><p>6.<br><code>free()</code>释放了分配的内存块但也引入了新的问题–悬空指针<br>显然<code>free(p)</code>释放内存后 p指向的空间被回收<br>这时试图由指针p访问或修改这片内存(野指针了属于是)也会导致未定义的行为。<br>同时，如果有多个指针指向同片内存空间，释放指针可能会导致这些指针都悬空</p></blockquote><h2 id="写在后面-想法"><a href="#写在后面-想法" class="headerlink" title="写在后面(想法)"></a>写在后面(想法)</h2><blockquote><p> 关于思考，学会思考是很重要的事情，之前总有这样的感觉:老师说什么就是什么，同时老师说到哪里就截止到哪里。感觉自己并没有向下深思，探究底层逻辑的想法。诚然，在这些年的学习过程中，我是体会到过 懂得底层逻辑，并在有较完善知识体系结构的基础上学习新知识的好处的。</p><p>但经常陷入两个误区：</p><p>一是抓住细枝末节后往其它细枝末节深究(感觉这样也不能说没用处，但是可能在没有足够好的基础的情况下深究这些效果不佳，同时对于此前的学习场景(在有限的时间内尽可能掌握固定范围的知识)这种学习思路对打好基础没有太多的益处，同时也耗费了相当多的时间，转移了有限的注意力。)</p><p>二是喜欢囤积知识，为了搭建好的知识体系，回去参考其他人分享的经验(书单，课程，视频…)但是收集到了这些信息不代表就是懂得了这些知识。</p></blockquote><blockquote><p>学习时不要用后续的”高深”知识点逆推基础，反而要思考作者的思路从基础推出高深(成体系)。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello New Worldhistory</title>
      <link href="/2022/01/22/3.Hello-New-Worldhistory/"/>
      <url>/2022/01/22/3.Hello-New-Worldhistory/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/60578464">参考</a><br><a href="https://ares-x.com/2019/12/29/freemind-bithack-readme-zh/">主题参考</a><br><a href="https://lacsscal.github.io/">实现效果</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>之前搭过一次，效果不是很好，写了一些可以说是废话的blog，并没有起到总结学习知识点的作用，此后尽量精简，减少引用，对能百度，Google到的知识点用自己的话整理总结。不要有大段的复制粘贴。<br>准备重新开始，blog不用实时更新，但每次写作尽量做到言之有物，至少能对学习成果做些总结内化以及沉淀的作用，再折腾这一次，后面尽量稳定下来。<br>原理：本地撰写MarkDown文档，Hexo解析渲染成具有主题样式的HTML静态网页，推送至GitHub完成发布。</p></blockquote><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li> 环境 nodejs, git</li><li> 连接GitHub</li><li> 添加Github SSH秘钥 并验证连接</li><li> 创建GitHub仓库</li><li> 本地安装Hexo博客并测试</li><li> <strong>部署</strong>注意分支名(main/master）到github上</li><li> 验证</li></ol><h2 id="本地Hexo"><a href="#本地Hexo" class="headerlink" title="本地Hexo"></a>本地Hexo</h2><blockquote><p>前面的准备过程跳过，以前搭过，环境还在，环境配置也不难<br>下面从Hexo本地安装开始<br>因为Hexo是基于Node.js的静态博客框架，可以经由npm一键安装</p></blockquote><pre><code>npm install -g hexo-cli #安装命令</code></pre><p>安装好后初始化即可，选一个空文件夹初始化并安装所需组件</p><pre><code>hexo init      # 初始化npm install    # 安装组件</code></pre><p>生成页面并启动，本地安装完成 可访问 <a href="http://localhost:4000/%E9%AA%8C%E8%AF%81">http://localhost:4000/验证</a></p><pre><code>hexo g   # 生成页面hexo s   # 启动预览(本地，Ctrl+C结束)</code></pre><p>​<br>后面要更新，删除博客方案类似</p><pre><code>hexo g   # 生成页面(增删都是)先渲染？大概hexo d   # 发布[注]自行添加一段名字与时间戳方便归档，或者使用命令生成自行添加：---title: 给个名字date: 2022-01-22 14:16:19tags:---命令生成：hexo new &quot;给个名字&quot;</code></pre><p>​    </p><h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><p>一般来说<a href="http://localhost:4000能访问成功说明本地安装完成，之后部署到Github上即可，此前已经建好仓库并且配置好SSH秘钥">http://localhost:4000能访问成功说明本地安装完成，之后部署到Github上即可，此前已经建好仓库并且配置好SSH秘钥</a><br>再安装组件</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>​<br>并修改  _config.yml 配置文件末尾的 Deployment 部分，<br>修改成如下：</p><pre><code>deploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: master/main</code></pre><p>完成后执行</p><pre><code>hexo d</code></pre><p>访问https://用户名.github.io 验证，一般要等待几分钟到十几分钟不等<em>我在搭建时先在本地置换了主题并验证成功后部署，但是在经过15以上页面才渲染成功</em></p><h3 id="关于主题更换"><a href="#关于主题更换" class="headerlink" title="关于主题更换"></a>关于主题更换</h3><blockquote><p>可以放在部署之前进行，也能在部署之后进行<br>我找了个FREEMIND-BITHACK主题，参考<a href="https://ares-x.com/2019/12/29/freemind-bithack-readme-zh/">主题参考</a>，<br>下载好的主题放在X:\blog\themes文件夹下并修改配置主题文件夹名与配置文件_config.yml中主题名一致。</p></blockquote><h1 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h1><p>后续还有一些细节，暂时不想折腾了，后续完善再说吧<br>目前简单使用可行</p><p>1.post文件夹下新增 .md文件<br>2.git bash here<br>3.hexo g 生成页面<br>4.hexo d 同步发布</p>]]></content>
      
      
      
        <tags>
            
            <tag> xxxx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test2</title>
      <link href="/2022/01/22/2.test2/"/>
      <url>/2022/01/22/2.test2/</url>
      
        <content type="html"><![CDATA[<p>test 2 <em>version2.0</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> xxxx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/21/1.hello-world/"/>
      <url>/2022/01/21/1.hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> xxxx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
