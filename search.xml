<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unix/Linux-file-management</title>
      <link href="/2022/02/26/Unix-Linux-file-management/"/>
      <url>/2022/02/26/Unix-Linux-file-management/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote><p>对于Linux的学习很早就开始了，但是直到现在才稍微有了一点比较深刻的感受。之前可能偏运维方向的Linux知识学的多一点，一直没有深入的学习，同时也没有接触到工作环境以得到更多的使用机会。所以所学习的知识大都浮于表面。并且有过了几次学了就忘的糟糕经历，反复多次学习，始终不曾从入门到熟练。只能说对这个系统稍有熟悉。最近的一次学习是当时准备找一份运维相关的工作，所以在网上找了视频准备系统学习。基本完整的走了一次从基础知识-&gt;脚本编程-&gt;系统管理-&gt;服务管理-&gt;Linux集群的流程。知识点很多，学到Linux集群时没能成功完成当时的项目，同时发现前期所学的知识遗忘太多，感觉十分挫败，同时由于一些其他的原因，最终没有走这个方向。但是我觉得与Linux的缘分不止于此 :)</p><p>最近在整理复盘C的知识时，在Linux环境下学习，有些和此前不同的感受，回顾C和Unix的历史，是否从稍微深入的研究Linux方向学习更适合我，近期在做这件事情，并将一些收获记录如下。</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-一点历史"><a href="#0-一点历史" class="headerlink" title="0 .一点历史"></a>0 .一点历史</h3><blockquote><p>还是从一点历史引入，感觉了解一些历史缘由，会更好地理解采用某种特定实现技术的原因</p><p>看了一点《The art of Unix Programming》 序中有一句话挺吸引我</p><p><em>Unix is not so much an operating system as an oral history.  —-Neal Stephenson</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-&gt;(早期)批处理OS</span><br><span class="line">-&gt;(1960)MIT分时OS:多终端+大型机</span><br><span class="line">-&gt;(1965)AT&amp;T:Bell+MIT+GE(通用电气):Multics计划(全面通用分时OS:bye)</span><br><span class="line">-&gt;(1969)Bell认为该计划GG,退出 (不算失败，有些成果) ：Ken Thompson 写了 Space Travle, PDP-7小型机移植，对它重写OS内核并移植 称Unics</span><br><span class="line">-&gt;Unics(核心哲学:一切皆文件, 程序的目的只有一个-有效的完成目标 : 与Multics理念不同《The Art of Unix Programming》)</span><br><span class="line">-&gt;(1969)Linus Torvalds 在芬兰诞生</span><br><span class="line">-&gt;尝试用高级语言解决移植问题BCPL, PASCAL-&gt;编译出的内核性能不够好-&gt;根据BCPL发明C</span><br><span class="line">-&gt;(1973)Deneish Richie(C的主要发明者)用C重写了Unics系统(提供了管道等重要功能),更名为Unix</span><br><span class="line">-&gt;(1977)AT&amp;T将Unix源代码(用C写的,高可移植性)发给学术界-&gt;UC Berkeley-&gt;Bill Joy professor 编译成适合自己机器的系统，增减一些功能:命名为BSD(Berkeley Software Distribution)</span><br><span class="line">-&gt;(1979)AT&amp;T:推出System V(five(Sun - Solaris)):第七版(不再开源:商业纠纷开始):特性:可以支持x86架构的个人计算机</span><br><span class="line">-&gt;(1984)不再开源对教授OS的professor产生了影响:Andrew TannenBaum-&gt;自己写个Mini Unix -&gt; Minix</span><br><span class="line">-&gt;(1986)完成Minix, 并出版《Operating System : Design and Implementation》附带Minix的源代码</span><br><span class="line">        《Modern Operating System》也是他写的</span><br><span class="line">-&gt;同期 Richard Stallman 发起了GNU计划:GNU:Gnu is not Unix!(GCC, Emacs, Bash Shell, GDB...)目标创建一套完全自由的Unix OS(当时的Unix与硬件捆绑销售)但是缺少Unix内核()</span><br><span class="line">-&gt;草拟 GPL协议(General Publilc License | 🙂 copyleft &lt;!-&gt; copyright:著作权) 开源 != 免费(维护可以收费)</span><br><span class="line">-&gt;(1988)IEEE:POSIX标准(旨在:保证各个OS间的兼容性) (IEEE-IX-&gt;POSIX:Portable Operating System Interface X:(Unix))可移植...</span><br><span class="line">-&gt;(1993)Linus:宏内核构造的Linux内核面世</span><br></pre></td></tr></table></figure><h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><blockquote><p>感觉之前学过很多次，并且每次学习也有用纸质或者文档记录，博客记录学到，使用过的命令，但大多情况学过不用就忘了，不是长久之计，这次就不记录这些。尽量多用以熟练。同时，本文的侧重点不在使用这方面，想要更深入的学习一些东西。</p></blockquote><blockquote><p>如果有不会的熟练使用 <code>$man</code></p><p>一点准备工作，环境使用的Ubuntu18.04 帮助手册不全<code>sudo apt install manpages-posix-dev</code></p></blockquote><h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3><blockquote><p>这是一张来自《Advanced Programing in the UNIX Environment》的图</p></blockquote><p><img src="!%5BUnix%E6%9E%B6%E6%9E%84.png%5D(https://s2.loli.net/2022/02/26/C9K4lRans1u6hU7.png" alt="架构图"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Kernel：OS内核：管理硬件资源，给上层程序提供运行环境(所以有很多驱动，提供很多接口，服务)</span><br><span class="line">System calls：系统调用：内核给上层程序提供的接口(有些繁琐复杂，做些封装-&gt;系统库)程序由系统调用使用内核提供的功能</span><br><span class="line">Library routines:库函数 (printf, scanf:对系统调用做一次封装)上层程序不能直接与硬件交互，需调用底层接口(对System calls封装)</span><br><span class="line">Shell：命令行解释器(bash:Bourne-again shell:/bin/bash):命令，脚本(命令的集合)， 访问内核资源</span><br><span class="line">Applications:应用程序:可以直接使用系统调用调用内核功能，也能使用系统库提供内核功能</span><br></pre></td></tr></table></figure><blockquote><p>在学习C的过程中，用到过不少库函数，按照这幅图从 库函数-&gt;System call-&gt;Kernel 由外层到里层深入的学习确实是此前没有接触过的全新思路，当然，任务也很艰巨《APUE》《内核源码》都是大部头，希望后面有毅力能啃完吧 : )</p></blockquote><blockquote><p>接下来按照OS的功能划分，以文件管理,进程管理,内存管理,IO管理 来分块学习。</p></blockquote><h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><blockquote><p>关于一切皆文件这个理念</p><p>对于这个Unix设计哲学，之前是知道这个名词，但是要具体来说可能说不出什么，结合一些文件操作来理解可能更为清晰。(图画的丑: ))在程序的运行过程中，计算机是怎样去操作磁盘上的文件的? 在一个程序运行时，由CPU去代码段取一条条指令，并将指令执行生成的数据放入堆栈等数据区。那么指令的操作数在哪？在内存上，内存的数据是从磁盘上取出的，最终也会持久化的存储在磁盘上。从中取，往回存这两个操作是怎么做到的，把磁盘看做程序运行时的外部设备，它在内存上建立了映射区—称作文件缓冲区。文件缓冲区在内存上，但是影响外部设备。</p></blockquote><p><img src="https://s2.loli.net/2022/02/26/MzSmKBfTk9Zp5WI.jpg" alt="文件_操作"></p><blockquote><p>以此类推，目录文件，设备文件，管道文件等等，理念是一致的。文件操作操作的是内存上的数据，影响的是外部设备。对于Linux而言存在内核态与用户态，当文件操作涉及外部硬件时，用户态将这些操作委托给内核态去完成，就离不开系统调用。</p><p>理解了这一点，就可以通过学习文件操作更深入的理解(操作文件会影响外部硬件，这个函数就不是普通的函数而是系统调用)。从库函数–&gt;系统调用。</p></blockquote><h4 id="3-1-文件的打开与操作"><a href="#3-1-文件的打开与操作" class="headerlink" title="3.1 文件的打开与操作"></a>3.1 文件的打开与操作</h4><h4 id="3-2-目录的打开与操作"><a href="#3-2-目录的打开与操作" class="headerlink" title="3.2 目录的打开与操作"></a>3.2 目录的打开与操作</h4><h4 id="3-3-基于文件描述符操作文件"><a href="#3-3-基于文件描述符操作文件" class="headerlink" title="3.3 基于文件描述符操作文件"></a>3.3 基于文件描述符操作文件</h4><h4 id="3-4-IO多路转接模型"><a href="#3-4-IO多路转接模型" class="headerlink" title="3.4 IO多路转接模型"></a>3.4 IO多路转接模型</h4><h2 id="写在后面-结"><a href="#写在后面-结" class="headerlink" title="写在后面(结)"></a>写在后面(结)</h2><blockquote><p>还是太菜，任重而道远</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C_Summarize_with_code</title>
      <link href="/2022/02/17/C-Summarize-with-code/"/>
      <url>/2022/02/17/C-Summarize-with-code/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote><p>接上篇<a href="https://lacsscal.github.io/2022/02/10/C-Summarize/">总结1</a> 上篇更多偏向文字叙述，以及一些概念方面的整理与思考，本篇结合一些常用的数据结构以及算法，换一个论述点再做一些整理</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1.基本数据结构"></a>1.基本数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="2-常见排序算法"><a href="#2-常见排序算法" class="headerlink" title="2. 常见排序算法"></a>2. 常见排序算法</h3><blockquote><p>关于排序算法分析</p><p>1.时间复杂度</p><p>冒泡排序，插入排序，简单选择排序无法突破<code>O(n2)</code>时间复杂度，因为其有序化过程中都是一个一个来减少逆序度的，当逆序度为0时整个序列有序，相对的希尔，并归，快排，堆排能突破是因为其不依赖相邻元素逐个排序。</p><ul><li><p>最好，最坏，平均   </p><p>分析时间复杂度，要给出 最好，最坏，平均情况下的时间复杂度(给出最好，最坏情况下对应要排序的原始数据情况)</p><ul><li><p>平均时间复杂度分析</p><p>n个元素有n!种排序，然后统计比较和交换的次数，再计算平均值。想想就十分复杂。</p><p>这里我们采用逆序对的方式来分析。</p><p>有序元素对：<code>arr[i] &lt;= arr[j], i &lt; j  </code></p><p>逆序元素对：<code>arr[i] &gt; arr[j], i &lt; j</code></p><p>有序度：数组中有序元素对的个数</p><p>逆序度：数组中逆序元素对的个数</p><p>满有序度：数组排好序后的有序度。</p><p>假设数组有n个元素，满有序度 =  <code>n(n-1)/2</code></p><p>公式： 满有序度 = 有序度 + 逆序度排序过程就是增加有序度，减少逆序度，最终达到满有序度的过程。</p></li></ul></li><li><p>常数，系数，低阶  </p><p>时间复杂度反应规模n很大时的增长趋势，忽略常数，系数，低阶(考虑规模小的数据时考虑这些因素)</p></li><li><p>比较， 交换  </p><p>基于比较的排序算法涉及元素的比较，交换，分析效率要考虑这些</p></li></ul><p>2.空间复杂度  </p><p>是否是原地算法</p><p>3.稳定性  </p><p>待排序列中存在值相等的元素，排序后这些元素间的前后关系是否不变</p></blockquote><p><code>bubble</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// i 表示冒泡的次数，也就是比较的趟数</span></span><br><span class="line">        <span class="keyword">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//每趟比较中，j从0开始取相邻两个元素比较(交换),每趟一定有一个元素有序排好，可以利用i</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;<span class="comment">//做点优化，使得有序(这趟没执行交换)之后结束排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有序度是数组中具有有序关系的元素对的个数。如果一个数组完全有序，有序度就是<code>Cn2 = n(n-1)/2</code>，这种叫做满有序度。</p><p>对于冒泡排序来说，交换会导致：有序度+1， 逆序度-1.</p><p>所以 交换的次数 = 逆序度。可以简单的认为平均情况下，逆序度 = <code> n(n-1)/4</code> 比较的次数肯定比交换的次数多，但少于 <code>n(n-1)/2</code>所以平均情况下，时间复杂度为<code>O(n2)</code></p></blockquote><p><code>selection</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// i表示选择元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = i;<span class="comment">//先预设当前索引所指数为最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//j从后一个元素开始向后找有无更小的</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每趟先假定本趟开头为最小元素，记录其索引，从其后一个元素开始向后遍历，找到更小的，更新最小元索引记录一趟走完交换本趟开头与最小<br>发生长距离的交换 所以不稳定</p><p>[5, 5, 1, 2, 3, 0, ]第一个5换到第二个5后面</p><p><code>O(n2) </code>不存在最好最坏，都是<code>O(n2)</code></p></blockquote><p><code>insertion</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">// i代表待插入元素的索引，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">int</span> val = arr[i];<span class="comment">//先记录，如果要插到前面的话需要前方元素后移，可能会覆盖它</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">//找到待插元素的前一个元素</span></span><br><span class="line">        <span class="comment">// 元素(比记录的待插元素大)往后移(凡比ta大的都后移，留出ta的位置)</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从第二个元素开始，每趟排序使当前遍历元素变得有序，取出元素值后先记录，往前找，凡前前面的元素(认为是有序序列)比ta大的，都后移，留出ta的位置，把它插入</p><p>最好<code>O(n) </code>比较n-1此，序列有序，不做交换</p><p>最坏O(n2)</p><p>逆序度分析平均时间复杂度 </p><p>稳定</p></blockquote><blockquote><p>选择排序一般不使用，冒泡排序一般也不用，</p><p>可能会用到的是插入排序为什么选择插入而不选择冒泡选择O()表示法省略了系数项和低阶项</p></blockquote><p><code>shell</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 组间插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123; <span class="comment">//还是插入排序的特性，先取后面的元素，只是这里用增量序列分组</span></span><br><span class="line">                                        <span class="comment">//i = gap 以 n = 10 个数为例 每轮 gap /= 2;  </span></span><br><span class="line">                                        <span class="comment">// 8 9 1 7 2 3 5 4 6 0  gap = 5</span></span><br><span class="line">                                        <span class="comment">// |         |</span></span><br><span class="line">                                                     i</span><br><span class="line">            <span class="keyword">int</span> val = arr[i];    <span class="comment">//组内比大小交换</span></span><br><span class="line">            <span class="keyword">int</span> j = i - gap;    </span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];<span class="comment">//每组前面的值先赋值给后面的值</span></span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = val; <span class="comment">//先减掉后加上用于交换赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缩小gap</span></span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(缩小增量排序)插入排序的优化版本 (第一批突破<code>O(n^2))</code>基于插入排序的性质提出改进方法  </p><ul><li><p>插入排序对基本有序的数据操作时，效率高。  </p></li><li><p>插入排序的缺点:每次比较相邻两个元素:对于基本有序的数组，一直比较相邻元素若有插入距离远的将比较多次，不适合</p></li></ul><p>希尔有先比较 距离远的(使得数据基本有序)基本有序的元素交换距离短</p><p>选择一个增量序列gap:(希尔推荐:n/2, n/4, …, 1)，分组，然后组间插入排序缩小增量 再分组 组间插入排序</p><p>插入排序:当数组基本有序，性能好(利用这一点)的有限，并解决不能长距离交换元素的缺点</p><p>长距离交换元素 不稳定</p><p>时间复杂度小于<code>O(n^2),</code>与增量序列有关</p></blockquote><p><code>merge</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//所给的接口感觉不好实现，在函数内部做一层封装委托出去</span></span><br><span class="line">    merge_sort1(arr, <span class="number">0</span>, n - <span class="number">1</span>);       <span class="comment">//知道数组的长度，把头当左界，尾当右界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;<span class="comment">//采用分治的思想，假定已有部分子序列有序，把他们合并</span></span><br><span class="line">                                                  <span class="comment">//至于怎么得到有序的子序列anyway，先不管，交个计算机，我只考虑这一层</span></span><br><span class="line">    <span class="comment">// 边界条件                                      //使用递归来做</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 递归公式</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);       <span class="comment">//使用已知的左右界求得中间节点，作为下层的右界，左界</span></span><br><span class="line">    merge_sort1(arr, left, mid);                  <span class="comment">//下层将要给我的是有序的左半边子序列 右半边子序列，实现合并即可</span></span><br><span class="line">    merge_sort1(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(arr, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;<span class="comment">//关键 实现归并操作</span></span><br><span class="line">    <span class="keyword">int</span>* temp = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>((right - left + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//先分配长度为n的辅助数组，排序过程中先将数据存入辅助序列</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;  <span class="comment">//两半有序子序列合并成整个有序序列</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;       <span class="comment">//Caution: 不能是 arr[i] &lt; arr[j] 相等的左边仍在前面 保证稳定性</span></span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;                  <span class="comment">//如果有一边的数据未取完，剩余的全复制过去</span></span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[left + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(nlog n)</code>的时间复杂度。代价是需要额外的内存空间<code>O(n) </code> tmp数组辅助。</p><p>稳定</p><p>建立在归并操作上的一种有效的排序算法是采用分治法（Divide and Conquer）(一种算法设计思想，策略)的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；</p><p>即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p></blockquote><p><code>Quick</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//同样，给定的接口不太好实现，可以利用已有的信息构建自己的内部接口委托实现</span></span><br><span class="line">    quick_sort1(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; <span class="comment">// pivot 枢 基准 定标点， 从数列中挑出元素做基准定标点</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)                               </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = partition(arr, left, right);         <span class="comment">// 这个pivot的选取由分区函数实现，可以认为它有序了</span></span><br><span class="line">                                                   <span class="comment">// 接下来下层函数实现 pivot左边和右边的排序</span></span><br><span class="line">    quick_sort1(arr, left, idx - <span class="number">1</span>);</span><br><span class="line">    quick_sort1(arr, idx + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;    <span class="comment">//那么怎么找到这个定标点，使得比它小的在它左边，大的在它右边</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];                         <span class="comment">//定标的过程中也完成了局部的排序， 先选定pivot在最左侧(有不同选法)</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123;           <span class="comment">//本例做法:标定在左边，先判右边，在右边找到比pivot小的，</span></span><br><span class="line">            j--;        </span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[j];                           <span class="comment">//填入pivot的位置，而这个位置的值暂存在pivot中也不会丢失</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123;           <span class="comment">//再判断左边，此时arr[i]为新填入，一定会向右走，当遇到比pivot大的</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = arr[i];                           <span class="comment">//填到刚才换走数据的位置中</span></span><br><span class="line">    &#125;<span class="comment">//当i, j 相遇，此时比pivot小的已经全部换去左边，比pivot大的已经全部换去右边，这里是pivot的正确位置，填入并返回</span></span><br><span class="line"></span><br><span class="line">    arr[i] = pivot;    <span class="comment">//来回交换，但一次始终只交换一个，由pivot暂存有一个值，所以不会有数据丢失</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>实现简答，变种多，性能好(桶排序和计数排序不基于比较 所以能突破<code>O(nlog(n))</code>)</p><p>算法思路：</p><ol><li>从数列中挑出一个元素，称为 “基准”<code>（pivot）</code>；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置(也是它最终的位置)。这个操作我们称之为分区<code>(partition)</code>；</li><li>递归地<code>(recursive)</code>把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>最坏情况：<code>O(n^2) </code>每次分区，基准都位于最右边或者最左边<code> T(n) = T(n-1) + O(n) = T(n-2) + O(n-1) + O(n) =.....</code>.;  <code>partition</code> 为<code>O(n)</code> 两个指针 i, j 分别遍历<br>最好情况：<code>O(nlogn)</code>每次分区，基准值都位于中间， <code>T(n) = 2T(n/2) + n; </code>每次问题规模折半</p></blockquote><p><code>heap</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;     <span class="comment">//先构建大顶堆，使堆顶最大，左右子树也是大顶堆</span></span><br><span class="line">    build_heap(arr, n);             <span class="comment">//传入序列与长度完成构建,取最大值做顶</span></span><br><span class="line">    <span class="keyword">int</span> length = n;                 <span class="comment">//此时还没进行排序，认为 无序区的长度为 n</span></span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">1</span>) &#123;            <span class="comment">//单个节点为最小大顶堆</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, length - <span class="number">1</span>);   <span class="comment">//将此时的顶换至末尾，减少序列长度-&gt;认为最大(顶)排序完成</span></span><br><span class="line">        length--;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, length);    <span class="comment">//将长度减少的序列重新调整成大顶堆，实际最大数据已经填在数组正确位置不再对它操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到最后一个有孩子的结点         //分析数组，先把无序的数组认为是一个完全二叉树，要让这个数组满足大顶堆的性质</span></span><br><span class="line">                                    <span class="comment">//无序的完全二叉树不是堆，需要调整</span></span><br><span class="line">                                    <span class="comment">//调整从数组的末尾开始做起，找到最后一个有孩子的节点，认为它的孩子是大顶堆</span></span><br><span class="line">                                    <span class="comment">//把这个节点和它的孩子们这棵子树调整成大顶堆</span></span><br><span class="line">                                    <span class="comment">//往数组的前面继续...</span></span><br><span class="line">    <span class="comment">// 数组从0 开始编号 左孩子为2i+1 右孩子为 2i+2</span></span><br><span class="line">    <span class="comment">// i:  leftChild=2i + 1, rightChild = 2i + 2;</span></span><br><span class="line">    <span class="comment">// 找最后一个有孩子的节点序号i 判断有孩子，只要有左孩子就行</span></span><br><span class="line">    <span class="comment">// 2i + 1 &lt;= n - 1 --&gt; i &lt;= (n - 2) / 2;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//从最后一个有孩子的节点开始调整，调整完后下一个调整的是数组中排在它前面的</span></span><br><span class="line">        heapify(arr, i, n);                     <span class="comment">//依次完成调整，构建大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//从上往下调整为大顶堆</span></span><br><span class="line">                                         <span class="comment">//记录并与左右孩子比较</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = i;</span><br><span class="line">        <span class="keyword">int</span> leftChild = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightChild = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftChild &lt; n &amp;&amp; arr[leftChild] &gt; arr[maxIdx]) <span class="comment">//限制避免数组越界再比较</span></span><br><span class="line">            maxIdx = leftChild;</span><br><span class="line">        <span class="keyword">if</span> (rightChild &lt; n &amp;&amp; arr[rightChild] &gt; arr[maxIdx])</span><br><span class="line">            maxIdx = rightChild;</span><br><span class="line">        <span class="keyword">if</span> (maxIdx == i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i, maxIdx);</span><br><span class="line">        i = maxIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>二叉堆 完全二叉树</p><p>大顶堆：堆顶元素最大，左右子树也是大顶堆</p><p>小顶堆：堆顶元素最小，左右子树也是小顶堆</p><p>堆:近似完全二叉树:性质:子节点的键值或索引总是小于（或者大于）它的父节点 </p><p><em>Wikipedia</em></p><p>以升序排序说明，把数组转换成最大堆(Max-Heap Heap)，这是一种满足最大堆性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。</p><p>思路：</p><ol><li>构建大顶堆</li><li>交换堆顶和无序区最后一个元素 此后 无序区元素个数-1，有序区元素个数+1</li><li>把无序区重新调整成大顶堆O(log(n))重复步骤2</li></ol><p>完全二叉树可以用数组去做-&gt;把待排序数组看成堆</p><p>先把待排序数组看做无序的完全二叉树 数组从前到后对应树的层序 ： 这个无序的完全二叉树不是堆，需要调整</p><p><strong>定义：单个节点的树是大顶堆</strong>找到第一个有孩子的节点 它的左右孩子一定是大顶堆然后把第一个有孩子的这棵树构建成大顶堆(做法:这个有孩子的节点与其左右孩子比较，大的改为父亲节点) –&gt;获得了第一个是大顶堆的子树以此类推-&gt;从后往前找，判，变      </p><p>大顶堆构建完成<br>由构建的过程知，堆顶元素为数组中最大元素，堆顶元素位于数组中索引为0的位置，交换它与数组的末尾</p></blockquote><p><code>二叉搜索与其变种</code></p><p><code>递归实现</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 递归公式</span></span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line"><span class="keyword">return</span> binary_search1(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)</span><br><span class="line"><span class="keyword">return</span> binary_search1(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">return</span> binary_search1(arr, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>循环实现</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>变种 </code>查找第一个与target相等的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid == left || arr[mid - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找最后一个小于等于target值的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt;= target) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == right || arr[mid + <span class="number">1</span>] &gt; target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找最后一个与key相等的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找3</span></span><br><span class="line"><span class="comment">//&#123; 0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 4, 5, 6, 7, 8, 9 &#125;;</span></span><br><span class="line"><span class="comment">//                             |</span></span><br><span class="line"><span class="comment">//     返回9</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; target) &#123;<span class="comment">//向右缩小范围</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;<span class="comment">//向左缩小范围</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (mid == right || arr[mid+<span class="number">1</span>] &gt; target) &#123;<span class="comment">//处理相等，走到末尾(此时右边界)或者下个大于target可返回</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找第一个大于等于key值的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; target) &#123;<span class="comment">//向右缩小范围</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid == left || arr[mid<span class="number">-1</span>] &lt; target) &#123;<span class="comment">//当前arr[mid]&gt;= target 向左走到边界 或者遇见小的</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="写在后面-结"><a href="#写在后面-结" class="headerlink" title="写在后面(结)"></a>写在后面(结)</h2><blockquote><p>本次关于C的整理梳理工作暂时告一段落，总的来说，起初的基础知识方面的整理有些浮躁，不耐烦，但是在重看过程中发现了不少之前未注意到的点，多对自己提问，试图站在作者的角度思考这个问题的产生与解决，分析需求并给出解决办法是有好处的，新的视角会带来一些未曾有过的思考。</p><p>同时也发现学过或者说学过不止一遍不代表就是懂得，就是精通。越发感觉此前的学习方式存在不少问题。<strong>Talk is cheap. Show me the code.</strong></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C Summarize</title>
      <link href="/2022/02/10/C-Summarize/"/>
      <url>/2022/02/10/C-Summarize/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote><p>  对于C的学习，已经反复好多次了，前面一直想要做个系统的梳理，但总是会出各种状况。之前有过跟着视频学习，自己对着书看写例程写课后题等等，最完整的一次梳理是在2020年的寒假，那次花了比较多的时间，从重看翁恺老师的视频开始，后续继续看了《K&amp;R》《C陷阱与缺陷》《C和指针》《C专家编程》等书。前期跟视频以及看《K&amp;R》可能算是做到了专注，精读，但后面有完成任务式的阅读，最终感觉效果不佳。当然，那段时间确实感觉有较大的提升，可后面因为一些事情耽误，很长一段时间没有再碰过。</p><p>最近打算重新系统梳理相关知识。这次打算配合最近捡起的知识点及写的程序，对C做大致的总结梳理。(总结自用，可能不甚严谨)</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-历史"><a href="#0-历史" class="headerlink" title="0.历史"></a>0.历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ken Thompson为了游戏(Space Travel)</span><br><span class="line">Multics -&gt; Unics(最初汇编PDP-7,移植性问题-&gt;发明BCPL:B语言)-&gt;</span><br><span class="line">Dennis Ritchie加入</span><br><span class="line">Dennis Ritchie-&gt;B不适合Unics(内核)开发:发明C -&gt; 用C重写Unics更名为Unix</span><br></pre></td></tr></table></figure><blockquote><p>结论： C用来<strong>开发系统软件</strong> (重写Unics系统,而此系统是K为了发挥PDP-7的全部性能以玩游戏而产生的)：       </p><p>所以C没有try-catch机制(耗费性能)       C与汇编有强对应关系</p></blockquote><h3 id="1-虚拟内存空间"><a href="#1-虚拟内存空间" class="headerlink" title="1.虚拟内存空间"></a>1.虚拟内存空间</h3><blockquote><p>源码经-&gt;预处理-&gt;编译-&gt;汇编-&gt;链接  程序-静态</p></blockquote><blockquote><p>变成了可执行文件，而可执行文件加载进内存变为进程，用于独立的虚拟内存空间 进程-动态</p></blockquote><p><img src="https://s2.loli.net/2022/02/15/fDxObctmSZCYWNM.png" alt="虚拟内存空间.png"></p><p>每个进程有自己的虚拟内存空间，而这个图可以辅助理解一些语言以及程序的相关特性。</p><blockquote><p>如：</p><ol><li>0x00000000 NULL 预留出不能访问 再将其定义为宏 #define 0x00000000 NULL (减少magic number)</li><li>HEAP 向上增长，结构体之类，程序员自行管理(如何申请，如何释放)</li><li>STACK 向下增长 存栈帧(活动记录：编译器实现过程调用的数据结构),存局部变量，运行函数</li><li>虚拟地址空间分区:高地址-&gt;低地址：OS区, 栈, 堆, 代码段数据段, NULL;</li><li>大端小端: 多字节数据布局问题<br>little-endian: 低地址存低位:小端: 0a 00 00 00(存10(0a)， 低–&gt;高)<br>big-endian   : 低地址存高位:大端: 00 00 00 0a<br>多字节间(00 00 00 0a)数据顺序相反，字节内(0a)不变</li><li>为什么OS存放在高地址:几乎所有OS都这么设计，编程要计算内存资源做地址分配，从低地址开始比较合理<br>OS为用户程序服务，映射到高地址<br>放在高地址用户程序很难碰到，在实模式时期也能最大程度兼容用户程序(使之保有原地址而不是后移)</li></ol></blockquote><h3 id="2-未曾想过并认为理所当然的问题"><a href="#2-未曾想过并认为理所当然的问题" class="headerlink" title="2. 未曾想过并认为理所当然的问题"></a>2. 未曾想过并认为理所当然的问题</h3><blockquote><p>关于之前没有关注过的认为理所当然的问题 辅助理解编译器给出的一些信息<br>1.<br>什么是表达式，语句，表达式语句<br>表达式(计算某值的公式)有值 按C的语言规定，很多地方需要给一个表达式 比如 while(…){}括号中需要一个表达式<br>所以<code>while(int i)&#123;&#125;</code>报错 <code>int i</code>不是一个表达式(是初始化语句?)<br>表达式以;结尾变成表达式语句<br>为什么编译器有时提示xxx不做 左值(一片存储空间)<br>表达式就不能做左值(它是计算某个值的公式)这个值应该是固定的不能让它改变也就不能做左值<br><code>&#123;...&#125;</code>是复合语句，让编译器将{}内的语句理解为一条语句</p><p>2.<br>为什么宏定义不用分号做结尾 <code>#define N 10</code><br>ta是预处理指令，是指令而不是语句，因此不用;结尾<br>预处理时是直接把它复制做文本替换的</p><p>3.<br>为什么<code>scanf()</code>, <code>printf()</code>函数能处理不定参数，这是怎么做到的?<br>可以输出输入多个参数的值，但又不知道多个几个</p><p>4.<br>知道优先级这个概念与内容<br>但是编译器是怎么理解并解析优先级的?</p><p>5.<br>为什么 <code>switch-case</code> 中 <code>case:</code> 后不需要加花括号{}<br>case是标签</p><p>6.<br><code>while do-while for</code> 之间的替换问题<br>由于<code>for(int i = 0; i &lt; n; ++i)</code>//将循环条件的改变放在语句中 所以在使用continue;时不要用它做替换</p><p>7.<br>为什么数组元素需要类型相同(一片连续内存，并且它被划分为大小相等的小空间)<br>为了随机访问-&gt;寻址公式:<code> address_i = base_address + i * sizeof(type);</code><br>为什么数组下标从0开始？<br>也是为了实现寻址公式。从1开始寻址会变为<code>address_i = base_address + (i-1) * sizeof(type); </code><br>或者不用第一个空间(浪费)则公式不变<code>address_i = base_address + i * sizeof(type);</code></p><ol start="8"><li>为什么函数不返回数组(做参数带出是可以的)<br> 要让它做返回值，说明是在这个函数周期内声明的?函数返回时，本地变量生存期结束，回收返回野指针?</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findMinMax</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="comment">/*** WRONG ***/</span></span><br><span class="line"> <span class="keyword">int</span> result[<span class="number">2</span>];</span><br><span class="line"> result[<span class="number">0</span>] = result[<span class="number">1</span>] = arr[<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (arr[i] &lt; result[<span class="number">0</span>])</span><br><span class="line">         result[<span class="number">0</span>] = arr[i];</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; result[<span class="number">1</span>])</span><br><span class="line">         result[<span class="number">1</span>] = arr[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样返回的指针也是指向当前函数的栈帧区域的，函数返回，这片区域不可控，变为野指针</p><p>9.<br>带参宏 <code>#define SIZE(a) (sizeof(a) / sizeof(a[0]))</code>挺好用的 </p><p>10.<br>为什么数组名在传递给函数时被视为指针？<br>C只有值传递，早期考虑传递数组整个copy耗时耗内存<br>所以使传递数组为参数时退化为指针(为什么会用“退化”–&gt;与隐式类型转化相似)<br><code>int find_largest(int a[], int n)&#123;&#125;</code><br><code>int find_largest(int *a, int n)&#123;&#125;</code>这样写可读性差，但更接近本质</p><p>11.<br>编译器帮忙补全的main()的参数<code>int main(int argc, char const *argv[])</code><br>命令行参数<br>OS调用<code>main(int argc, char const *argv[]) </code>并传参给它<br><code>argc   </code> : 参数计数<br><code>*argv[] </code>: 参数组，第一条参数为 函数名<br>有了这个特性<br>传递给<code>main()</code>不同的参数，可以产生不同的行为(.e.g:文件操作不再需要写死文件地址)“由命令行参数改变函数行为”</p><p>12.<br>使用free()函数时，参数只是给了一个 指针(指向某片内存的首地址)，free怎么知道要释放多少内存?<br>在之前分配内存时就给出了此块内存占多少字节 (关于这点可以看《CS:APP》free_list空闲链表)(free为程序员减负)?</p></blockquote><p><img src="https://s2.loli.net/2022/02/15/7G4lhe9OjHZXMig.png" alt="优先级表.png"></p><p><img src="https://s2.loli.net/2022/02/15/One4RJdaDyXchmp.png" alt="ASCII表.png"></p><h3 id="3-递归-recursion"><a href="#3-递归-recursion" class="headerlink" title="3. 递归 recursion"></a>3. <strong>递归 recursion</strong></h3><p>定义时调用本身 (传统引例为:斐波那契数列求和，其实这并不是一个很好的例子(画出递归树可知有<strong>太多重复计算</strong>性能差))</p><p><strong>但作为分析案例是合适的</strong></p><p>它满足以下条件：</p><ul><li>大问题分解为小问题</li><li>大小问题求解方式一致，只是规模不同</li><li>小问题的解可合成大问题的解</li></ul><p>可是使用递归，但注意在递归代码书写时，一定要有:</p><ul><li><p>边界条件(没有的话会调用下去直到Stack Overflow)</p></li><li><p>递归公式要考虑重复计算问题:</p></li></ul><p>以斐波那契为例，由于存在重复计算问题，其实效率不高</p><p>总结：<strong>得出递归公式，知道边界条件且解决重复计算问题可用递归</strong></p><p>更经典的例子:</p><p><strong>汉诺塔问题 Hanoi</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> start, <span class="keyword">char</span> middle, <span class="keyword">char</span> end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hanoi(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> start, <span class="keyword">char</span> middle, <span class="keyword">char</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, start, end); <span class="comment">//记得设置边界条件，不然会一直递归下去</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        hanoi(n<span class="number">-1</span>, start, end, middle);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, start, end);</span><br><span class="line">        hanoi(n<span class="number">-1</span>, middle, start, end);</span><br><span class="line">    &#125;<span class="comment">//抽象的思考问题，不要考虑具体实现细节，交个计算机来做，只想这一步该完成什么(这里即:将前n-1个经end移至middle)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>约瑟夫问题 Joseph (只是其中一种，隔一个杀一个的情况)</strong></p><p><img src="https://s2.loli.net/2022/02/15/nX2uet4WBZEpqib.png" alt="约瑟夫环.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jos</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,  jos(<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jos</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//边界条件</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * jos(n / <span class="number">2</span>) - <span class="number">1</span>; <span class="comment">//输入偶数的规模与编号关系</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * jos((n - <span class="number">1</span>) / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//隔一个杀一个的Joseph环，推导一定次数之后  得出规律</span></span><br></pre></td></tr></table></figure><p><strong>结论：递归是一种考虑问题的思想，可以降低问题的复杂度</strong></p><p><strong>使用递归时，不要用脑向下展开模拟，站在较高的角度，抽象的考虑当前这步：</strong></p><p><strong><code>hanoi</code>比较典型</strong></p><p><strong>当前这步将最大的圆盘n从 start –&gt; end而为了实现这步，需要将其上的n-1个盘从start –&gt; end –&gt; middle</strong></p><p><strong>当最大盘到end之后，将此时在middle上的n-1个盘 middle –&gt; start –&gt; end</strong></p><p><strong>anyway：中间的具体实现不去管它，交给计算机去一层层分解。</strong></p><h3 id="4-指针"><a href="#4-指针" class="headerlink" title="4.指针"></a>4.指针</h3><blockquote><p>在本次回顾与重学的过程中，改用了<code>Visual Studio</code>，相比于之前使用的<code>VsCode+MinGW</code>的方案，它的各种检查更加严格，使用起来没有之前那么间接方便，但是也帮助发现了不少之前没注意的细节问题。</p></blockquote><blockquote><p>1<br>野指针问题(没有初始化)但是对它解引用赋值了(属于未定义的行为)<br>注意 <code>int *p = 0x100;</code> 也是野指针，虽然初始化了，但是指向的区域不可控。<br>野指针指向未知(不可控)产生未定义的行为<br>空指针(“不指向任何地方的指针”)实现为指向<code>NULL(0x00000000)</code>但对其指向访问也是未定义的行为,可看做野指针的一种</p><p>2<br>由指针的算数运算特性，可以使用指针控制访问数组<br><code>char str[N] = &#123;0&#125;</code><br><code>for(char *p = str + N; p &gt; str; --p)&#123;&#125;</code> //使用指针而不是整数控制访问数组</p><p>3<br>数组名作为指向数组第一个元素的指针(数组名是个常量指针不能改其值)<br>反过来也能把指针当数组名用 <code>char *p = str; p[i] </code>编译器解释为<code>*(p + i)</code></p><p>4<br>字符串字面值是一个常量，使用指针指向它是不能用指针修改它的<br><code>*p = &quot;a string&quot;;</code> 使<code>p</code>指向字符串第一个字符<br><code>*p = &quot;b&quot; /*** WRONG ***/</code> 指向的字符串字面值是常量，不能修改</p><p>而<br><code>char data[9] = &quot;a string&quot;</code> 不是将字符串字面值给字符数组<br>其实是编译器帮我们做了一些工作，其本质为<br><code>char data[9] = &#123;&#39;a&#39;, &#39; &#39;, &#39;s&#39;, &#39;t&#39;, &#39;r&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;, &#39;\0&#39;&#125;   </code><br>所以其后<code>data[]</code>数组中的值是可以改变的</p><p>对比<br><code>char data[] = &quot;a string&quot;;</code>  字符数组 – 可修改data中字符           – data为数组名,不能改变指向<br><code>char *data  = &quot;a string&quot;;  </code>字符指针 – data指向字符串字面值,不可改  – data为指针变量,可改变指向<br>所以对要修改字符串的场景，使用字符数组存储。要使用指针的话，这个指针必须指向实际存在的字符数组。</p><p>5.<br>结构成员运算符 <code>“.”</code><br>结构指针运算符 <code>“-&gt;”</code><br><code>(*p).val = xx; &lt;=&gt; p-&gt;val = xx;</code></p><p>6.<br><code>free()</code>释放了分配的内存块但也引入了新的问题–悬空指针<br>显然<code>free(p)</code>释放内存后 p指向的空间被回收<br>这时试图由指针p访问或修改这片内存(野指针了属于是)也会导致未定义的行为。<br>同时，如果有多个指针指向同片内存空间，释放指针可能会导致这些指针都悬空</p></blockquote><h2 id="写在后面-想法"><a href="#写在后面-想法" class="headerlink" title="写在后面(想法)"></a>写在后面(想法)</h2><blockquote><p> 关于思考，学会思考是很重要的事情，之前总有这样的感觉:老师说什么就是什么，同时老师说到哪里就截止到哪里。感觉自己并没有向下深思，探究底层逻辑的想法。诚然，在这些年的学习过程中，我是体会到过 懂得底层逻辑，并在有较完善知识体系结构的基础上学习新知识的好处的。</p><p>但经常陷入两个误区：</p><p>一是抓住细枝末节后往其它细枝末节深究(感觉这样也不能说没用处，但是可能在没有足够好的基础的情况下深究这些效果不佳，同时对于此前的学习场景(在有限的时间内尽可能掌握固定范围的知识)这种学习思路对打好基础没有太多的益处，同时也耗费了相当多的时间，转移了有限的注意力。)</p><p>二是喜欢囤积知识，为了搭建好的知识体系，回去参考其他人分享的经验(书单，课程，视频…)但是收集到了这些信息不代表就是懂得了这些知识。</p></blockquote><blockquote><p>学习时不要用后续的”高深”知识点逆推基础，反而要思考作者的思路从基础推出高深(成体系)。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello New Worldhistory</title>
      <link href="/2022/01/22/Hello-New-Worldhistory/"/>
      <url>/2022/01/22/Hello-New-Worldhistory/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/60578464">参考</a><br><a href="https://ares-x.com/2019/12/29/freemind-bithack-readme-zh/">主题参考</a><br><a href="https://lacsscal.github.io/">实现效果</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>之前搭过一次，效果不是很好，写了一些可以说是废话的blog，并没有起到总结学习知识点的作用，此后尽量精简，减少引用，对能百度，Google到的知识点用自己的话整理总结。不要有大段的复制粘贴。<br>准备重新开始，blog不用实时更新，但每次写作尽量做到言之有物，至少能对学习成果做些总结内化以及沉淀的作用，再折腾这一次，后面尽量稳定下来。<br>原理：本地撰写MarkDown文档，Hexo解析渲染成具有主题样式的HTML静态网页，推送至GitHub完成发布。</p></blockquote><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li> 环境 nodejs, git</li><li> 连接GitHub</li><li> 添加Github SSH秘钥 并验证连接</li><li> 创建GitHub仓库</li><li> 本地安装Hexo博客并测试</li><li> <strong>部署</strong>注意分支名(main/master）到github上</li><li> 验证</li></ol><h2 id="本地Hexo"><a href="#本地Hexo" class="headerlink" title="本地Hexo"></a>本地Hexo</h2><blockquote><p>前面的准备过程跳过，以前搭过，环境还在，环境配置也不难<br>下面从Hexo本地安装开始<br>因为Hexo是基于Node.js的静态博客框架，可以经由npm一键安装</p></blockquote><pre><code>npm install -g hexo-cli #安装命令</code></pre><p>安装好后初始化即可，选一个空文件夹初始化并安装所需组件</p><pre><code>hexo init      # 初始化npm install    # 安装组件</code></pre><p>生成页面并启动，本地安装完成 可访问 <a href="http://localhost:4000/%E9%AA%8C%E8%AF%81">http://localhost:4000/验证</a></p><pre><code>hexo g   # 生成页面hexo s   # 启动预览(本地，Ctrl+C结束)</code></pre><p>后面要更新，删除博客方案类似</p><pre><code>hexo g   # 生成页面(增删都是)先渲染？大概hexo d   # 发布[注]自行添加一段名字与时间戳方便归档，或者使用命令生成自行添加：---title: 给个名字date: 2022-01-22 14:16:19tags:---命令生成：hexo new &quot;给个名字&quot;</code></pre><h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><p>一般来说<a href="http://localhost:4000能访问成功说明本地安装完成，之后部署到Github上即可，此前已经建好仓库并且配置好SSH秘钥">http://localhost:4000能访问成功说明本地安装完成，之后部署到Github上即可，此前已经建好仓库并且配置好SSH秘钥</a><br>再安装组件</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>并修改  _config.yml 配置文件末尾的 Deployment 部分，<br>修改成如下：</p><pre><code>deploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: master/main</code></pre><p>完成后执行</p><pre><code>hexo d</code></pre><p>访问https://用户名.github.io 验证，一般要等待几分钟到十几分钟不等<em>我在搭建时先在本地置换了主题并验证成功后部署，但是在经过15以上页面才渲染成功</em></p><h3 id="关于主题更换"><a href="#关于主题更换" class="headerlink" title="关于主题更换"></a>关于主题更换</h3><blockquote><p>可以放在部署之前进行，也能在部署之后进行<br>我找了个FREEMIND-BITHACK主题，参考<a href="https://ares-x.com/2019/12/29/freemind-bithack-readme-zh/">主题参考</a>，<br>下载好的主题放在X:\blog\themes文件夹下并修改配置主题文件夹名与配置文件_config.yml中主题名一致。</p></blockquote><h1 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h1><p>后续还有一些细节，暂时不想折腾了，后续完善再说吧<br>目前简单实用可以</p><p>1.post文件夹下新增 .md文件<br>2.git bash here<br>3.hexo g 生成页面<br>4.hexo d 同步发布</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test2</title>
      <link href="/2022/01/22/2.test2/"/>
      <url>/2022/01/22/2.test2/</url>
      
        <content type="html"><![CDATA[<p>test 2 <em>version2.0</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/22/1.hello-world/"/>
      <url>/2022/01/22/1.hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
