<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>12.regex</title>
      <link href="/2022/04/24/12-regex/"/>
      <url>/2022/04/24/12-regex/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>最初是由Unix 的grep 和sed等工具软件普及开的。</p><p>使用单个(模式)字符串描述，匹配一系列匹配某句法规则的字符串</p><p>一个学习的GitHub项目<a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">learn_regex</a></p><p>一个练习题库<a href="https://regex101.com/">在线题库</a></p><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220422200036382.png" alt="POSIX字符组"></p><blockquote><p>正则表达式的POSIX规范，分为:</p><p>基本型正则表达式（Basic Regular Expression，BRE）<br>和扩展型正则表达式（Extended Regular Expression，ERE）两大流派。<br>前者的元字符需要转义，后者的不需要(包括egrep awk)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">基本正则表达式的元字符：</span><br><span class="line">字符匹配：</span><br><span class="line">.: 匹配任意单个字符</span><br><span class="line">[]: 匹配指定范围内的任意单个字符</span><br><span class="line">[0-9], [[:digit:]]</span><br><span class="line">[a-z], [[:lower:]]</span><br><span class="line">[A-Z], [[:upper:]]</span><br><span class="line">[[:space:]]</span><br><span class="line">[[:punct:]]</span><br><span class="line">[[:alpha:]]</span><br><span class="line">[[:alnum:]]</span><br><span class="line">[^]:</span><br><span class="line">次数匹配元字符：用于实现指定其前面的字符所能够出现的次数</span><br><span class="line">*: 任意长度，它前面的字符可以出现任意次</span><br><span class="line">例如：x*y</span><br><span class="line">xxy, xyy, y, </span><br><span class="line">\\?: 0次或1次，它前面的字符是可有可无的</span><br><span class="line">例如：x\\?y</span><br><span class="line">xy, y, ay</span><br><span class="line">\\&#123;m\\&#125;: m次，它前的字符要出现m次</span><br><span class="line">例如：x\\&#123;2\\&#125;y</span><br><span class="line">xy, xxy, y, xxxxy, xyy</span><br><span class="line">\\&#123;m,n\\&#125;: 至少m次，至多n次</span><br><span class="line">例如：x\\&#123;2,5\\&#125;y</span><br><span class="line">xy, y, xxy</span><br><span class="line">\\&#123;m,\\&#125;：至少m次</span><br><span class="line">\\&#123;0,n\\&#125;: 至多n次</span><br><span class="line"></span><br><span class="line">.*：任意长度的任意字符</span><br><span class="line"></span><br><span class="line">位置锚定：</span><br><span class="line">^: 行首锚定；</span><br><span class="line">写在模式最左侧</span><br><span class="line">$: 行尾锚定：</span><br><span class="line">写在模式最右侧</span><br><span class="line">^$: 空白行</span><br><span class="line"></span><br><span class="line">不包含特殊字符的连续字符组成的串叫单词：</span><br><span class="line">\\&lt;: 词首，出现于单词左侧</span><br><span class="line">\\&lt;char</span><br><span class="line">\\&gt;: 词尾，出现于单词右侧</span><br><span class="line">char\\&gt;</span><br><span class="line"></span><br><span class="line">分组...</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">扩展正则表达式：</span><br><span class="line">字符匹配：</span><br><span class="line">.</span><br><span class="line">[]</span><br><span class="line">[^]</span><br><span class="line">次数匹配：</span><br><span class="line">*：任意次</span><br><span class="line">?: 0次或1次</span><br><span class="line">+: 至少1次；</span><br><span class="line">&#123;m&#125;: 精确匹配m次</span><br><span class="line">&#123;m,n&#125;: 至少m次，至多n次</span><br><span class="line">&#123;m,&#125;</span><br><span class="line">&#123;0,n&#125;</span><br><span class="line">位置锚定：</span><br><span class="line">^</span><br><span class="line">$</span><br><span class="line">\&lt;, </span><br><span class="line">\&gt;, </span><br><span class="line">^$, ^[[:space:]]*$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="应用到grep"><a href="#应用到grep" class="headerlink" title="应用到grep"></a>应用到grep</h1><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p><code>grep == Global search REgular expression and Print out the line.</code></p><p>grep 会对目标文件进行搜索，显示匹配到的行</p><p>之前大家都用过，不过使用方式比较简单 一般是<code>ps -elf | grep xxx</code></p><p>结合正则表达式可以发挥出更强大的功能。</p><pre><code>语法格式：    grep [option]... &#39;PATTERN&#39; FILE...        --color=auto 命令选项：        -v: 反向选取        -o: 仅显示匹配的字串，而非字串所在的行        -i: ignore-case，忽略字符大小写        -E: 支持使用扩展正则表达式</code></pre><h2 id="grep-egrep-fgrep"><a href="#grep-egrep-fgrep" class="headerlink" title="grep, egrep, fgrep"></a>grep, egrep, fgrep</h2><blockquote><p>基本正则表达式：grep<br>扩展正则表达式: egrep, grep -E<br>fgrep: fast, 不支持使用正则表达式</p><p>这里介绍前两种,  举几个例子看一下</p></blockquote><pre><code>    1、显示/proc/meminfo文件中以大写或小写S开头的行；    # grep -i &#39;^s&#39; /proc/meminfo    # grep &#39;^[Ss]&#39; /proc/meminfo    # grep -E &#39;^(S|s)&#39; /proc/meminfo    2、显示/etc/passwd文件中其默认shell为非/sbin/nologin的用户；    # grep -v &quot;/sbin/nologin$&quot; /etc/passwd | cut -d: -f1    3、显示/etc/passwd文件中其默认shell为/bin/bash的用户；        进一步：仅显示上述结果中其ID号最大的用户；    # grep &quot;/bin/bash$&quot; /etc/passwd | sort -t: -k3 -n | tail -1 | cut -d: -f1                    4、找出/etc/passwd文件中的一位数或两位数；    # grep &quot;\\&lt;[0-9][0-9]\\?\\&gt;&quot; /etc/passwd    # grep &quot;\\&lt;[0-9]\\&#123;1,2\\&#125;\\&gt;&quot; /etc/passwd    5、显示~/.vimrc中以至少一个空白字符开头的行；    # grep &quot;^[[:space:]]\\&#123;1,\\&#125;&quot; ~/.vimrc    6、显示~/.bashrc文件中，以#开头，后面跟至少一个空白字符，而后又有至少一个非空白字符的行；    # grep &quot;^#[[:space:]]\\&#123;1,\\&#125;[^[:space:]]\\&#123;1,\\&#125;&quot;  ~/.bashrc    7、找出netstat -tan命令执行结果中以&#39;LISTEN&#39;结尾的行；    # netstat -tan | grep &quot;LISTEN[[:space:]]*$&quot;    </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">grep -E  &#x27;PATTERN&#x27; FILE...</span><br><span class="line">egrep &#x27;PATTERN&#x27; FILE...</span><br><span class="line"></span><br><span class="line">使用扩展的正则表达式</span><br><span class="line">1、显示当前系统上root、scallacs或test用户的默认shell；</span><br><span class="line"># grep -E &quot;^(root|scallacs|test)&quot; /etc/passwd | cut -d: -f7</span><br><span class="line"></span><br><span class="line">2、找出/home/scallacs/cpp/log4cpp/test.cc文件中某单词后跟一组小括号“()”行；</span><br><span class="line"># grep -o -E &quot;\&lt;[[:alnum:]]+\&gt;\(\)&quot; /home/scallacs/cpp/log4cpp/test.cc</span><br><span class="line"></span><br><span class="line">3、使用echo命令输出一个路径，而后使用grep取出路径中各个字段；</span><br><span class="line">echo &quot;/home/scallacs/cpp/log4cpp&quot; | grep -o -E &quot;[[:alnum:]]+/?&quot;</span><br><span class="line"></span><br><span class="line">4、找出ifconfig命令结果中的1-255之间的数字；</span><br><span class="line"># ifconfig | grep -o -E &quot;\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&quot;</span><br><span class="line"></span><br><span class="line">5、匹配ipv4地址；</span><br><span class="line"># ifconfig | grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上规则在vim中 使用 <code>:%s/xxx/xxx/g</code> 长命令做替换时也适用, 一堆///看得眼花可以其他字符替换比如@</p><h1 id="应用到C"><a href="#应用到C" class="headerlink" title="应用到C++"></a>应用到C++</h1><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220424133608994.png" alt="image-20220424133608994"></p><p>选择使用的正则表达式文法</p><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220422214628903.png" alt="选择正则文法"></p><p>例子1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::regex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string qq;</span><br><span class="line">    cin &gt;&gt; qq;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 判断位数是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (qq.<span class="built_in">length</span>() &gt;= <span class="number">5</span> &amp;&amp; qq.<span class="built_in">length</span>() &lt;= <span class="number">11</span>)&#123;</span><br><span class="line">    <span class="comment">// 2. 判断是否非&#x27;0&#x27;开头</span></span><br><span class="line">    <span class="keyword">if</span> (qq[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">// 3. 判断是否为纯数字</span></span><br><span class="line">    <span class="keyword">auto</span> pos = std::<span class="built_in">find_if</span>(qq.<span class="built_in">begin</span>(), qq.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">char</span>&amp; ch) &#123;</span><br><span class="line">    <span class="keyword">return</span> ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">            <span class="keyword">if</span> (pos == qq.<span class="built_in">end</span>())&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;valid&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;invalid.&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt; <span class="string">&quot;invalid.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;invalid.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">qq_reg</span><span class="params">(<span class="string">&quot;[0-9]&#123;4,11&#125;&quot;</span>, std::regex::egrep)</span></span>;</span><br><span class="line">    string qq = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="comment">/* string qq = &quot;qwer12345&quot;; */</span></span><br><span class="line">    <span class="comment">/* string qq = &quot;0000qe345&quot;; */</span></span><br><span class="line">    <span class="comment">/* regex qq_reg(&quot;[1-9]\\d&#123;4,11&#125;&quot;); */</span></span><br><span class="line">    <span class="keyword">bool</span> ret = std::<span class="built_in">regex_match</span>(qq, qq_reg);</span><br><span class="line">    cout &lt;&lt; (ret ? <span class="string">&quot;valid&quot;</span> : <span class="string">&quot;invalid&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test0</span>();</span><br><span class="line">    <span class="comment">/* test1(); */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h2><p>基本用法：匹配字符串，字符串符合匹配规则，返回bool值，主要用于if条件表达式中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">regex_match</span><span class="params">( <span class="keyword">const</span> CharT* str,</span></span></span><br><span class="line"><span class="params"><span class="function">                  regex 模式串对象,</span></span></span><br><span class="line"><span class="params"><span class="function">                )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>基本用法：搜索匹配子串，搜索字符串中存在符合规则的子字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">regex_search</span><span class="params">( <span class="keyword">const</span> CharT* str,</span></span></span><br><span class="line"><span class="params"><span class="function">                   regex 模式串对象,</span></span></span><br><span class="line"><span class="params"><span class="function">                )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h2><p>是替换匹配，可以将符合匹配规则的子字符串替换为其他字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::basic_string&lt;CharT&gt;</span></span><br><span class="line"><span class="function">    <span class="title">regex_replace</span><span class="params">( <span class="keyword">const</span> CharT* s,</span></span></span><br><span class="line"><span class="params"><span class="function">                   regex 模式串对象,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> CharT* fmt)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* regex reg(&quot;[0-9]&#123;4,11&#125;&quot;, std::regex::egrep);//egrep regex */</span></span><br><span class="line">    <span class="comment">/* string num = &quot;123456789&quot;; */</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;123&quot;</span>, <span class="built_in">regex</span>(<span class="string">&quot;[[:digit:]]&quot;</span>, std::regex::egrep)) &lt;&lt; endl;<span class="comment">//结果为0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;123&quot;</span>, <span class="built_in">regex</span>(<span class="string">&quot;[[:digit:]]&#123;3&#125;&quot;</span>, std::regex::egrep)) &lt;&lt; endl;<span class="comment">//结果为1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_search</span>(<span class="string">&quot;123&quot;</span>, <span class="built_in">regex</span>(<span class="string">&quot;[[:digit:]]&quot;</span>, std::regex::egrep)) &lt;&lt; endl;<span class="comment">//结果为1</span></span><br><span class="line"></span><br><span class="line">    string str = <span class="string">&quot;Hell$%R%%&amp;%o World&quot;</span>;</span><br><span class="line">    <span class="comment">/* regex src_pattern(&quot;^[[:lower:]]*$&quot;, std::regex::egrep); */</span></span><br><span class="line">    <span class="comment">/* regex dst_pattern(&quot;[[[:punct:]]]*&quot;, std::regex::egrep); */</span></span><br><span class="line">    <span class="function">regex <span class="title">dst_pattern</span><span class="params">(<span class="string">&quot;[^[:alnum:][:space:]]&quot;</span>, std::regex::egrep)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_replace</span>(str, dst_pattern, <span class="string">&quot;&quot;</span> ) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* regex xml_pattern(&quot;/&lt;&lt;.*&gt;/&gt;&quot;, std::regex::egrep); */</span></span><br><span class="line">    <span class="function">regex <span class="title">xml_pattern</span><span class="params">(<span class="string">&quot;&lt;[^&gt;]*&gt;&quot;</span>, std::regex::egrep)</span></span>;</span><br><span class="line">    string xml = <span class="string">&quot;&lt;p&gt;另外，一些公司还使用了生物密码来进行用户的身份验证，&quot;</span>\</span><br><span class="line">                  <span class="string">&quot;比如人脸识别,但是，我个人觉得人脸识别或是生物识别是比较糟糕的方式，&quot;</span>\</span><br><span class="line">                  <span class="string">&quot;因为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;目前能被验证的生物信息（如人脸和指纹）太容易被别人获得和伪造了。&quot;</span>\</span><br><span class="line">                  <span class="string">&quot;&lt;/li&gt;&lt;li&gt;这样东西不能被变更和吊销，密码可以被吊销和重置，人脸则不能。&lt;/li&gt;&lt;/ul&gt; &lt;h4&gt;密钥对和证书&lt;/h4&gt;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_replace</span>(xml, xml_pattern, <span class="string">&quot;&quot;</span> ) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考： </p><p><a href="https://www.cnblogs.com/coolcpp/p/cpp-regex.html">https://www.cnblogs.com/coolcpp/p/cpp-regex.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> xxxx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix-Linux-proj-netDsic-II</title>
      <link href="/2022/03/26/Unix-Linux-proj-netDsic-II/"/>
      <url>/2022/03/26/Unix-Linux-proj-netDsic-II/</url>
      
        <content type="html"><![CDATA[<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Proj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>database</title>
      <link href="/2022/03/14/database/"/>
      <url>/2022/03/14/database/</url>
      
        <content type="html"><![CDATA[<h1 id="Navicat-连接mysql"><a href="#Navicat-连接mysql" class="headerlink" title="Navicat 连接mysql"></a>Navicat 连接mysql</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装C-sql依赖的dev</span></span><br><span class="line"></span><br><span class="line">[scallacs@scallacs ~\ []$ sudo apt install libmysqlclient-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改配置文件</span></span><br><span class="line">[scallacs@scallacs ~\ []$ <span class="built_in">cd</span> /etc/mysql/mysql.conf.d/</span><br><span class="line">[scallacs@scallacs /etc/mysql/mysql.conf.d\ []$ sudo vim mysqld.cnf </span><br><span class="line">[sudo] password <span class="keyword">for</span> scallacs: </span><br><span class="line">[scallacs@scallacs /etc/mysql/mysql.conf.d\ []$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220326150818014.png" alt="image-20220326150818014"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 修改mysql配置</span></span><br><span class="line">$ mysql -u root -p</span><br><span class="line">&gt; use mysql;</span><br><span class="line">&gt; select host, user from user;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 将表项  localhost 改为 % , 重启服务，或者刷新权限</span></span><br><span class="line">&gt; flush privileges;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220323171238791.png" alt="image-20220323171238791" style="zoom: 80%;" /><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220323171301807.png" alt="image-20220323171301807" style="zoom: 80%;" />]]></content>
      
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix-Linux-NetworkProgramming-II</title>
      <link href="/2022/03/14/11.Unix-Linux-NetworkProgramming-II/"/>
      <url>/2022/03/14/11.Unix-Linux-NetworkProgramming-II/</url>
      
        <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、select-epoll对比"><a href="#一、select-epoll对比" class="headerlink" title="一、select epoll对比"></a>一、select epoll对比</h2><p>?不需询问没就绪的 网络连接高并发 <strong>epoll原理</strong></p><p><strong>触发方式</strong></p><h2 id="二、-进程池-amp-线程池"><a href="#二、-进程池-amp-线程池" class="headerlink" title="二、 进程池&amp;线程池"></a>二、 进程池&amp;线程池</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><h4 id="0-makefile"><a href="#0-makefile" class="headerlink" title="0.makefile"></a>0.makefile</h4><blockquote><p>复杂的应用重新写一下makefile</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SRCS:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJS:=$(SRCS:%.c=%.o)</span><br><span class="line">CC:=gcc</span><br><span class="line"><span class="section">server:<span class="variable">$(OBJS)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span> -lpthread</span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span> -g</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean rebuild</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(RM)</span> <span class="variable">$(OBJS)</span> server</span><br><span class="line"><span class="section">rebuild:clean server</span></span><br></pre></td></tr></table></figure><h4 id="1-初始化进程，网络"><a href="#1-初始化进程，网络" class="headerlink" title="1.初始化进程，网络"></a>1.初始化进程，网络</h4><p>先做进程池再过度到线程池</p><blockquote><p>需求分析</p><p>主进程要负责接收客户端的连接请求，而TCP的初始化工作是一套流程可以封装成函数(在主进程中调用的接口可以先不实现具体内部细节，定义好这些接口，先思考调用这些接口的调用逻辑)</p><p>编码时采用增量编写，写一点测一点，先理清调用逻辑在写具体实现细节。直观的分析服务端需求，应该能够有一个主进程做管理进程，它创建多个子进程，主进程接受来自客户端的连接建立TCP通信，同时管理所有子进程，子进程有空闲将这个子进程用来处理客户端需求(工作派发，但和直觉上的派发不太一样)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 进程池的主进程与客户端通信建立连接，管理多个子进程负责分派任务，</span></span><br><span class="line"><span class="comment">    *  ./server 192.168.73.133 1234 [wokerNum] 需要四个参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">4</span>);</span><br><span class="line"><span class="comment">/*step 1:创建多个子进程*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*step 2:作为服务端初始服务端网络连接所需*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现多进程可以考虑使用<code>fork()</code></p><blockquote><p>fork的原理，会将父进程的所有用户态信息拷贝一份，同时共享内核态文件对象。而按这个项目的业务逻辑，子进程不应该在创建之初就能够获取与客户端的通信连接(而应该等到主进程的派发)</p><p>因此建立网络连接初始化之前应该创建子进程</p><p>编码时可以先大致确定接口，并先定好接口调用关系，再去实现具体细节</p></blockquote><p>理清逻辑，首先实现主进程创建多个子进程，其次实现主进程作为服务端的TCP相关初始化</p><p>主进程会需要管理多个子进程，可以设计子进程信息的数据结构,多个子进程连成线性表，设计创建子进程的接口时，将这个数据结构作为参数传入。同时后期有需求加入，直接写在这个数据结构中，增加了可读性与可维护性。</p><blockquote><p>为子进程worker设计如下属性</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    FREE,</span><br><span class="line">    BUSY</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">workerData_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;<span class="comment">//BUSY or FREE</span></span><br><span class="line">&#125; workerData_t;</span><br><span class="line"><span class="comment">// 为主进程提供一次创建多个子进程的接口，参数是子进程信息的数组和子进程数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeWorker</span><span class="params">(workerData_t *workerDataArr, <span class="keyword">int</span> workerNum)</span></span>;</span><br></pre></td></tr></table></figure><p>主进程将调用这个接口创建多个子进程管理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./server 192.168.73.133 1234 [wokerNum]</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> workerNum = atoi(argv[<span class="number">3</span>]);<span class="comment">//创建传入参数个数的子进程</span></span><br><span class="line">    workerData_t *workerDataArr = (workerData_t*)<span class="built_in">calloc</span>(workerNum, <span class="keyword">sizeof</span>(workerData_t));</span><br><span class="line">    makeWorker(workerDataArr, workerNum);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//ps -elf |grep server 可以查看这些进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想好了接口的调用关系，有了大致的接口设计思路再去实现这个接口</p><blockquote><p>创建子进程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主进程需要调用以实现创建多个子进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeWorker</span><span class="params">(workerData_t *workerDataArr, <span class="keyword">int</span> workerNum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;workerNum; ++i)&#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="comment">// 调用fork()返回值是0的为子进程，调函数工作</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//子进程做事，封装一个函数</span></span><br><span class="line">            handleEvent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父进程，或者说主进程将其返回值(子进程ID)</span></span><br><span class="line">        <span class="comment">//放入做传入传出参数的数组中,方便后续在主进程中管理这些子进程</span></span><br><span class="line">        workerDataArr[i].pid = pid;</span><br><span class="line">        workerDataArr[i].status = FREE;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让主进程阻塞，查看一下<code>ps -elf | grep server</code></p><blockquote><p>$ ps -elf | grep server</p><p>0 R scallacs  44959  43907 19  80   0 -  1129 -      20:34 pts/3    00:00:01 ./server 192.168.37.133 1234 4<br>1 R scallacs  44960  44959 19  80   0 -  1129 -      20:34 pts/3    00:00:01 ./server 192.168.37.133 1234 4<br>1 R scallacs  44961  44959 19  80   0 -  1129 -      20:34 pts/3    00:00:01 ./server 192.168.37.133 1234 4<br>1 R scallacs  44962  44959 19  80   0 -  1129 -      20:34 pts/3    00:00:01 ./server 192.168.37.133 1234 4<br>1 R scallacs  44963  44959 19  80   0 -  1129 -      20:34 pts/3    00:00:01 ./server 192.168.37.133 1234 4</p></blockquote><p>目前来说完成了主进程创建多个子进程的工作，这些子进程的文件描述符放在了一个结构体数组中待用，该结构体数组中还有子进程状态信息，并且还能继续添加其他信息。</p><blockquote><p>编码时为普通功能函数统一创建一个头文件放它们的函数声明，为带结构体设计的函数写单独头的文件，方便管理。保证代码逻辑清晰</p></blockquote><p>接下来，实现主进程作为TCP服务端的连接所需，步骤很固定，可以封装成功能函数移动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="comment">// 套接字文件描述符作为传入传出参数,封装作为服务端TCP初始化的一套流程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcpInit</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">char</span> *port, <span class="keyword">int</span> *pSocket)</span></span>&#123;</span><br><span class="line">    *pSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = hton(atoi(port));</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = setsockopt(*pSocket, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    ret = bind(*pSocket, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    listen(*pSocket, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再使用while(1)阻塞，看一下是否监听成功(增量编写)</p></blockquote><blockquote><p>$ ./server 192.168.73.133 1234 4</p><p>$ netstat -an | grep 1234<br>tcp        0      0 192.168.73.133:1234     0.0.0.0:*               LISTEN  </p></blockquote><h4 id="2-服务端-任务下到子进程"><a href="#2-服务端-任务下到子进程" class="headerlink" title="2.服务端-任务下到子进程"></a>2.服务端-任务下到子进程</h4><p>再分析一下需求，整体需求大致结构模型如下</p><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/%E6%95%B4%E4%BD%93%E6%A8%A1%E5%9E%8B.jpg" alt="结构模型"></p><p>目前服务端主进程能够接受来自客户端的TCP连接，并且创建了多个子进程。接下来需要做的是主进程把来自客户端的需求分配给一个空闲的子进程。换言之，主进程只作为最初的连接口以及完成任务分发，它不应该负责真正的网络传输，这会大大拖累主进程的<strong>正事</strong>在主进程把任务下发之后断掉与客户端的连接也没有关系，接下来去由子进程全权负责与客户端对接。</p><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/%E4%B8%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84netfd%E4%BC%A0%E8%BE%93%EF%BC%8C%E8%AE%A9%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8E%BB%E5%AF%B9%E6%8E%A5%E5%AE%A2%E6%88%B7%E7%AB%AF.jpg" alt="子进程对接客户端"></p><p>如果能做到上图所示，那么接下来子进程与客户端通过<code>netfd</code>操作内核文件对象进行通信即可。但是为了实现一个主进程多个子进程的架构，设计之初是将子进程的<code>fork</code>创建放在TCP连接建立之前的，父子进程天生不共享内核文件对象<code>netFO</code> , 子进程也就不能通过<code>netfd</code>与客户端通信。</p><blockquote><p>那么有没有办法把主进程文件对象传给子进程</p></blockquote><h5 id="本地套接字-socketpair"><a href="#本地套接字-socketpair" class="headerlink" title="本地套接字 socketpair"></a>本地套接字 socketpair</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sv[<span class="number">2</span>])</span></span>;</span><br><span class="line">                   |             |         |                |</span><br><span class="line">             AF_LCOAL固定     流式|消息     <span class="number">0</span>不需要额外协议   管道两端全双工</span><br></pre></td></tr></table></figure><blockquote><p>父进程和子进程的地址空间是隔离的，如果两个进程之间需要进行通信，那就要选择一种合适的进程间通信的手段，比较合适的方法是管道。</p><p>除了之前所使用的 pipe 系统调用可以在父子进程间创建管道以外，还有一种方法是<strong>本地套接字</strong>。使用系统调用 socketpair 可以在父子进程间利用 socket 创建一个<strong>全双工</strong>的管道。除此以外，本地套接字可以在同一个操作系统的两个进程之间传递文件描述符。</p></blockquote><h5 id="新文件对象共享法-sendmsg"><a href="#新文件对象共享法-sendmsg" class="headerlink" title="新文件对象共享法 sendmsg"></a>新文件对象共享法 sendmsg</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>新的共享文件对象的方法sendmsg</strong> ，它可以发<strong>控制信息</strong>，使用时分作两支，既可传输普通信息msg_iov也能传输控制信息msg_comtrol</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span> </span><br><span class="line">    <span class="keyword">void</span> *msg_name; <span class="comment">/* optional address */</span> </span><br><span class="line">    <span class="keyword">socklen_t</span> msg_namelen; <span class="comment">/* size of address */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span> <span class="comment">/* scatter/gather array */</span> </span><br><span class="line">    <span class="keyword">size_t</span> msg_iovlen; <span class="comment">/* # elements in msg_iov */</span> </span><br><span class="line">    <span class="keyword">void</span> *msg_control; <span class="comment">/* ancillary data, see below */</span> </span><br><span class="line">    <span class="keyword">size_t</span> msg_controllen; <span class="comment">/* ancillary data buffer len */</span> </span><br><span class="line">    <span class="keyword">int</span> msg_flags; <span class="comment">/* flags on received message */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span> <span class="comment">/* Scatter/gather array items */</span></span><br><span class="line">    <span class="keyword">void</span> *iov_base; <span class="comment">/* Starting address */</span> </span><br><span class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">/* Number of bytes to transfer */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315114000645.png" alt="image-20220315114000645"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315114905870.png" alt="image-20220315114905870"></p><blockquote><p>接下来考虑具体实现(在主进程与子进程间传递netfd,)，同样先考虑调用关系与接口， 再实现接口的具体细节</p></blockquote><blockquote><p>确定调用关系，在worker中调用收(封装的接口，底层使用sendmsg，类似跨进程的dup共享文件对象)<em>——需要得到父进程与客户端通信的netFO的文件描述符netfd，只有这个整数是不够的需得共享文件对象</em>。</p><p>主进程调用发。</p><p>父子进程<code>socketpair</code>本地套接字通信，改造数据结构,添加接口(接口动态调整)</p></blockquote><p>为子进程worker的结构体中添加pipeFd字段，这样在fork创建多个子进程时，一并初始化父子进程通信所用本地套接字的文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">worker的结构体新增</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">workerData_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;<span class="comment">//BUSY or FREE</span></span><br><span class="line">    <span class="keyword">int</span> pipeFd;&lt;-------------------------------新增</span><br><span class="line">&#125; workerData_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主进程与子进程的新需求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">主<span class="function">main</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*step1.创建多个子进程*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*step2.初始化服务端网络通信*/</span></span><br><span class="line">    </span><br><span class="line">    新增</span><br><span class="line">    <span class="comment">/*step3.客户端连接到达，服务端创建新的netfd:用一定的手段转给子进程*/</span> &lt;----</span><br><span class="line"><span class="keyword">int</span> netFd = accept(sockFd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    sendFd(workerDataArr[<span class="number">0</span>].pipeFd, netFd);</span><br><span class="line">    <span class="comment">/*发来的用来与客户端交互的netfd放在新增的数据结构中*/</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">子worker</span><br><span class="line"><span class="comment">// 主进程需要调用以实现创建多个子进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeWorker</span><span class="params">(workerData_t *workerDataArr, <span class="keyword">int</span> workerNum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;workerNum; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> pipefds[<span class="number">2</span>];&lt;-----------------------------</span><br><span class="line">        socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, pipefds);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            close(pipefds[<span class="number">0</span>]);<span class="comment">//子进程关闭一端</span></span><br><span class="line">            handleEvent();</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipefds[<span class="number">1</span>]);</span><br><span class="line">        workerDataArr[i].pipeFd = pipefds[<span class="number">0</span>];<span class="comment">//父进程用这端与子进程通信</span></span><br><span class="line">        workerDataArr[i].pid = pid;</span><br><span class="line">        workerDataArr[i].status = FREE;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对称的，使用sendfd{底层封装sendmsg}发，就要用一个recvfd{底层用recvmsg}收</p></blockquote><blockquote><p>实现sendfd &amp; recvfd 固定用法</p></blockquote><p><code>sendFd.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendFd</span><span class="params">(<span class="keyword">int</span> pipeFd, <span class="keyword">int</span> fdToSend)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">    bzero(&amp;hdr, <span class="keyword">sizeof</span>(hdr));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    hdr.msg_iov = iov;</span><br><span class="line">    hdr.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">pcmsghdr</span> =</span> (struct cmsghdr *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct cmsghdr));</span><br><span class="line">    pcmsghdr-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    pcmsghdr-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    pcmsghdr-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line">    *(<span class="keyword">int</span> *)CMSG_DATA(pcmsghdr) = fdToSend;</span><br><span class="line">    hdr.msg_control = pcmsghdr;</span><br><span class="line">    hdr.msg_controllen = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> ret = sendmsg(pipeFd, &amp;hdr, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;sendmsg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>recvFd.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvFd</span><span class="params">(<span class="keyword">int</span> pipeFd, <span class="keyword">int</span> *pFd)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">hdr</span>;</span></span><br><span class="line">    bzero(&amp;hdr, <span class="keyword">sizeof</span>(struct msghdr));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">5</span>;</span><br><span class="line">    hdr.msg_iov = iov;</span><br><span class="line">    hdr.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">pcmsghdr</span> =</span> (struct cmsghdr *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>))));</span><br><span class="line">    pcmsghdr-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    pcmsghdr-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    pcmsghdr-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line">    hdr.msg_control = pcmsghdr;</span><br><span class="line">    hdr.msg_controllen = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> ret = recvmsg(pipeFd, &amp;hdr, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;resvmsg&quot;</span>);</span><br><span class="line">    *pFd = *(<span class="keyword">int</span> *)CMSG_DATA(pcmsghdr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>………</p><blockquote><p>测试以上程序做了什么</p></blockquote><blockquote><p>测试好组件再接入项目，写一个小的main测试</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">用read,write传递文件描述符的话，实际传递的只是一个整数，</span><br><span class="line">文件对象没有共享，所以不能用传递所得的文件描述符操作文件对象</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line">    socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, pipefds);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> recvFd;</span><br><span class="line">        read(pipefds[<span class="number">1</span>], &amp;recvFd, <span class="keyword">sizeof</span>(recvFd));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recvFd = %d\n&quot;</span>, recvFd);</span><br><span class="line">        <span class="keyword">int</span> ret = write(recvFd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">&quot;file1&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, fd);</span><br><span class="line">        write(pipefds[<span class="number">0</span>], &amp;fd, <span class="keyword">sizeof</span>(fd));</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$ ./sendfd </span><br><span class="line">fd = <span class="number">5</span></span><br><span class="line">recvFd = <span class="number">5</span></span><br><span class="line">write: Bad file descriptor</span><br></pre></td></tr></table></figure><blockquote><p>用这个整数write的话，对应的文件对象没传递过来，只是一个整数</p></blockquote><p>改用recvfd的话，父进程使用sendfd(sengmsg函数)发送，父进程中文件描述符数字为5，发过去变成6.因为子进程中打开了一个文件占位占用了5号文件描述符，所以发的不是数字，是对应的文件对象。此时以这个文件描述符是可以操作对应的文件对象的，比如对它写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line">    socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, pipefds);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        open(<span class="string">&quot;file2&quot;</span>, O_RDWR);<span class="comment">//在开一个文件，什么都不做，只是占一个文件描述符</span></span><br><span class="line">        recvFd(pipefds[<span class="number">1</span>], &amp;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, fd);</span><br><span class="line">        <span class="keyword">int</span> ret = write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">&quot;file1&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, fd);</span><br><span class="line">        write(fd, <span class="string">&quot;world&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        sendFd(pipefds[<span class="number">0</span>], fd);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ ./sendfd </span><br><span class="line">fd = <span class="number">5</span></span><br><span class="line">hello</span><br><span class="line">fd = <span class="number">6</span></span><br><span class="line">$ cat file1</span><br><span class="line">worldhello</span><br></pre></td></tr></table></figure><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315144239612.png" alt="image-20220315144239612"></p><p>因为是文件对象，所以可以往里写。父子共享文件对象偏移，实现了<strong>跨进程的dup</strong></p><p>走到这一步，父子进程之间可以用新的方式共享文件对象，父进程将与客户端建立的netfd发给子进程，由子进程与客户端对接。而在此之后，即便父进程关掉与客户端的netfd也不影响，类似dup的引用计数，此后文件传输工作全权交由子进程进行即可。</p><p>…………………………………..</p><blockquote><p>再解析一下这两个封装的接口<code>sendfd, recvfd</code></p></blockquote><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315145444571.png" alt="image-20220315145444571"></p><p>载荷由四字节算出</p><p>提供了两种通信机制，普通信息，控制信息红黄两端</p><p>为什么要用sendfd&amp;recvfd???</p><p>回到架构</p><p>netfd子进程天生看不到，无法直接与客户通信，给它发</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315145647040.png" alt="image-20220315145647040"></p><p>引入sendfd </p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315145928715.png" alt="image-20220315145928715"></p><blockquote><p>现在可以更改worker的handleEvent接口，真正的让子进程做一些事了</p></blockquote><p>子进程等，等任务到了做，当主进程将netfd发来说明有任务到了，子进程开始做事</p><p>主进程怎么分配，子进程干完怎么通知?用write走普通信息那端通知</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315150105886.png" alt="image-20220315150105886"></p><blockquote><p>现在主进程会读子进程的任务反馈(任务完成回一个pid)，读客户端的TCP连接，采用IO多路复用将主进程的读行为管理起来。</p></blockquote><p>所以考虑主进程设计</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315150606204.png" alt="image-20220315150606204"></p><blockquote><p>主进程监听两种读行为</p><p>1.sockfd:客户端与服务端的连接建立，建立后将netfd交给子进程，与客户端的连接建立之后将具体传输任务交给子进程去做</p><p>2.pipefd:子进程将任务完成后的反馈，收到后主进程将这个子进程的状态置为FREE</p></blockquote><blockquote><p>使用前先封装epoll</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用IO多路复用监听网络socket和每个子进程本地socket的一端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epollAdd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> epfd)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    <span class="keyword">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;epoll_ctl add&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epollDel</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> epfd)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    <span class="keyword">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &amp;event);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;epoll_ctl del&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主进程go on</p><p>之前将子进程通信预留的管道文件描述符保存到了数组中</p><p>加入监听</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*step1.创建子进程*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*step2.初始化TCP*/</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 连接建立 &amp; 子进程做事返回， 两种读行为IO多路复用epoll管理</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">10</span>);</span><br><span class="line">    ERROR_CHECK(epfd, <span class="number">-1</span>, <span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">    epollAdd(sockFd, epfd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerNum; ++i)&#123;</span><br><span class="line">        epollAdd(workerDataArr[i].pipeFd, epfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> listenSize = workerNum + <span class="number">1</span>;<span class="comment">//子进程+监听套接字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">readyList</span> =</span> (struct epoll_event *)</span><br><span class="line">        <span class="built_in">calloc</span>(listenSize, <span class="keyword">sizeof</span>(struct epoll_event));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阻塞epoll等待，先分配就绪队列空间，内部分类讨论会发生的事情</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> readyNum = epoll_wait(epfd, readyList, listenSize, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;readyNum = %d\n&quot;, readyNum);</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;epoll ready!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; readyNum; ++i)&#123;</span><br><span class="line">            <span class="comment">//情况1.分配任务sockFd就绪</span></span><br><span class="line">            <span class="keyword">if</span>(readyList[i].data.fd == sockFd)&#123;<span class="comment">//监听套接字就绪</span></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;a client is comming!&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> netFd = accept(sockFd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">//客户端由网络连接父进程，父进程得到一个已连接socket</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;netfd 1:%d\n&quot;</span>, netFd);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; workerNum; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(workerDataArr[j].status == FREE)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;No.%d worker got his job, pid = %d\n&quot;</span>,</span><br><span class="line">                               j, workerDataArr[j].pid);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;netfd 2:%d\n&quot;</span>, netFd);</span><br><span class="line">                        sendFd(workerDataArr[j].pipeFd, netFd);</span><br><span class="line">                        <span class="comment">//选一个空闲子进程把这个已连接socket:netfd传给它</span></span><br><span class="line">                        <span class="comment">// close(netFd);//父进程交给子进程了可关掉，放后面也可</span></span><br><span class="line">                        workerDataArr[j].status = BUSY;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                close(netFd);</span><br><span class="line">            <span class="comment">//情况2.子进程工作完成，回送消息(会把自己的pid发过去)，管道就绪</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//子进程工作完成就绪</span></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;One worker finish his job&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; workerNum; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(workerDataArr[j].pipeFd == readyList[i].data.fd)&#123;</span><br><span class="line">                        <span class="keyword">pid_t</span> pid;</span><br><span class="line">                        <span class="keyword">int</span> ret = recv(workerDataArr[j].pipeFd, &amp;pid, <span class="keyword">sizeof</span>(pid), <span class="number">0</span>);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%d worker finish his job, pid = %d\n&quot;</span>, j, pid);</span><br><span class="line">                        workerDataArr[j].status = FREE;</span><br><span class="line">                        <span class="comment">//子进程完成任务通知父进程，并设置自己为FREE</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315153224840.png" alt="image-20220315153224840"></p><p>大致完成，结构分析，整体流程</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315155616905.png" alt="image-20220315155616905"></p><p>main</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315155852520.png" alt="image-20220315155852520"></p><p>worker</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315160154097.png" alt="image-20220315160154097"></p><h3 id="第二版-支持更多的逻辑，给子进程加工作量-文件下载功能"><a href="#第二版-支持更多的逻辑，给子进程加工作量-文件下载功能" class="headerlink" title="第二版 支持更多的逻辑，给子进程加工作量 (文件下载功能)"></a>第二版 支持更多的逻辑，给子进程加工作量 (文件下载功能)</h3><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315160329018.png" alt="image-20220315160329018"></p><p>这段换成处理文件的函数(<strong>服务端</strong>子进程transfile,客户端加一个recvfile)</p><p>truncate -s 200 file1</p><p>服务端的调用</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315161035012.png" alt="image-20220315161035012"></p><p>客户端改造一下</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315161352720.png" alt="image-20220315161352720"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315161424270.png" alt="image-20220315161424270"></p><p>client卡住了</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315161551675.png" alt="image-20220315161551675"></p><p>先发文件名再发文件内容，TCP流式协议，收的时候全收了，不知道消息边界</p><p>把文件内容当文件名收了，<strong>粘包-小文件传输解决粘包</strong></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315161829536.png" alt="image-20220315161829536"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315161757451.png" alt="image-20220315161757451"></p><p>传输层无法解决这个问题，<strong>设计应用层私有协议</strong>小火车</p><p>车头为整数描述内容长度</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315162237780.png" alt="image-20220315162237780"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315162711061.png" alt="image-20220315162711061"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315162821405.png" alt="image-20220315162821405"></p><p>用小火车协议改造后</p><p>两个部分信息都从收一次到收两次</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315163122977.png" alt="image-20220315163122977"></p><p>发送方把信息包装，文件名先发，重新装填为文件内容</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315163553643.png" alt="image-20220315163553643"></p><p>以上，实现小文件传输</p><p>那么大文件(一次发不完的文件)传输怎么做?小文件传输改成循环?</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315164216786.png" alt="image-20220315164216786"></p><p>客户端做对称的事</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315164329858.png" alt="image-20220315164329858"></p><p>truncate -s 100M file1</p><p>简单改造成循环传输大文件</p><p>出错</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220317201341018.png" alt="image-20220317201341018"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315164534282.png" alt="image-20220315164534282"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315164553677.png" alt="image-20220315164553677"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220317201446160.png" alt="image-20220317201446160"></p><p>有一个子进程成为僵尸，子终止父未回收，管道一端终止，另一端无限读</p><p>死因</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315165006273.png" alt="image-20220315165006273"></p><p>不触发信号</p><p>1.改变信号递送行为</p><p>2.给send加属性<img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315171652200.png" alt="image-20220315171652200"></p><p>但没有解决问题根源(sigpipe信号不应该产生)</p><p>这个问题是怎么出现的</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315172255196.png" alt="image-20220315172255196"></p><p>网络设备中不一定有稳定网络传输(磁盘传输稳定)，传输层只保证数据不丢(不保证什么时候到)。因此不保证recv到多少时返回(此时剩余的还没送到){不保证把数据填满你再接受}TCP保证剩余数据还过来，但此时recv已经出问题。如下图所示。recv只指定最大长度</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315172941584.png" alt="image-20220315172941584"></p><p>让recv总是能收完的方案 <strong>解决半包问题-大文件传输</strong>最核心的两个问题 粘包半包</p><p>1.属性MSG_WAITALL<img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315174440936.png" alt="image-20220315174440936"></p><p>2.自行实现MSG_WAITALL的功能 </p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315175210469.png" alt="image-20220315175210469"></p><p>指针偏移 pTmp+total</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315174819332.png" alt="image-20220315174819332"></p><p>怎么判断传输到的文件是否相同？</p><p>使用md5码，摘要散列算法</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315173902444.png" alt="image-20220315173902444"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315174009641.png" alt="image-20220315174009641"></p><p>以上最基本功能实现</p><h3 id="第三版-进度条bar"><a href="#第三版-进度条bar" class="headerlink" title="第三版 + 进度条bar"></a>第三版 + 进度条bar</h3><p>+功能，客户端下载时打印进度条额外传输一个文件大小</p><p>发整个文件大小，不要打印太频繁</p><p>fstat 获取文件大小</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315180001361.png" alt="image-20220315180001361"></p><p>客户端</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315180558203.png" alt="image-20220315180558203"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315180756430.png" alt="image-20220315180756430"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315180926726.png" alt="image-20220315180926726"></p><p>显示在一行怎么做</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220315181135382.png" alt="image-20220315181135382"></p><p>退出时打印个100%</p><h3 id="第四版-提升传输速度"><a href="#第四版-提升传输速度" class="headerlink" title="第四版-提升传输速度"></a>第四版-提升传输速度</h3><p>数据存在用户态到内核态，内核态到用户态拷贝</p><p>mmap零拷贝技术</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316100221247.png" alt="image-20220316100221247"></p><p>mmap不超过2GB</p><p>transfile不再直接发，改用mmap零拷贝</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316100815653.png" alt="image-20220316100815653"></p><p>建立映射，把读写文件看成读写内存</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316100839446.png" alt="image-20220316100839446"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316101910243.png" alt="image-20220316101910243"></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316101550956.png" alt="image-20220316101550956"></p><p>统计效率</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316102603927.png" alt="image-20220316102603927"></p><p>小火车解决粘包，不使用小火车怎么做</p><p>文件内容不使用小火车，直接send， 使用mmap(已经把文件全加载进内存)一次全发完</p><p>接收方，客户端也一次性收完，客户端也使用mmap</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316102939527.png" alt="image-20220316102939527"></p><p>怎么做?</p><p>去掉进度条，一次全收完</p><p>sendfile只能从磁盘到网络</p><p>网络IO是瓶颈</p><p>先写出来再优化，优化时考虑瓶颈</p><h5 id="有序退出"><a href="#有序退出" class="headerlink" title="有序退出"></a>有序退出</h5><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316112751020.png" alt="image-20220316112751020"></p><p>注册10号信号(默认递送行为：终止)来做这个事情</p><p>粗暴的有序退出，文件还在传输也退出</p><p>优雅的有序退出，等文件传完</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316113025168.png" alt="image-20220316113025168"></p><p>signal与fork的顺序</p><p>子可以继承父的信号递送行为</p><p>子不会继承父的pending集合 man 7 signal</p><p>不希望子继承：先fork再signal</p><p><strong>异步拉起同步策略</strong></p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316114118726.png" alt="image-20220316114118726"></p><p>全局变量不涉及业务数据，只有专用于退出的管道</p><p>父子进程间不用信号，使用退出标志位</p><p>进程池的缺陷</p><p>优势，进程崩溃不会影响其他进程</p><p>劣势 内存空间隔离，依赖IPC机制传递文件对象，非常困难，开销大</p><h2 id="三、线程池"><a href="#三、线程池" class="headerlink" title="三、线程池"></a>三、线程池</h2><p>引入线程池</p><p>线程天生共享文件对象，线程间沟通频率高，更注重性能</p><p>有虚拟机的JVM这样的不能用进程池</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316144503127.png" alt="image-20220316144503127"></p><p>线程数在1~2倍CPU核心数之间</p><p>1倍为CPU密集型，2倍为IO密集型（经验公式）</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316145338571.png" alt="image-20220316145338571"></p><p>之前是主进程加，主进程发，没有竞争条件，现在是主线程加，子线程去取，有</p><p><img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220316145815852.png" alt="image-20220316145815852"></p><p>先写小版本再往上加功能-敏捷开发</p><h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Unix/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netdisk</title>
      <link href="/2022/03/14/Unix-Linux-proj-netdisc/"/>
      <url>/2022/03/14/Unix-Linux-proj-netdisc/</url>
      
        <content type="html"><![CDATA[<h1 id="v1"><a href="#v1" class="headerlink" title="v1"></a>v1</h1><blockquote><p>目标：写客户端，服务端，服务端响应客户端命令请求 + 密码验证，登录，日志，断点续传，大文件<code>mmap</code></p></blockquote><blockquote><p>整合此前的各个库函数与系统调用实现的<strong>命令</strong>，搭建基本的服务端框架和客户端雏形，使得客户端发出指令，服务端能够解析他们并做出对应的功能响应。</p><p>命令包括<code> cd, ls, pwd, mkdir, rm, puts, gets...</code></p></blockquote><h2 id="1-搭建服务端框架"><a href="#1-搭建服务端框架" class="headerlink" title="1.搭建服务端框架"></a>1.搭建服务端框架</h2><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/%E6%95%B4%E4%BD%93%E6%A8%A1%E5%9E%8B.jpg" alt="大致线程池模型"></p><blockquote><p>服务端需要维护一个线程池做业务处理</p></blockquote><p><code>整体代码结构</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">## 最终定下的代码结构如下</span><br><span class="line">.</span><br><span class="line">├── client</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   ├── head<span class="selector-class">.h</span></span><br><span class="line">│   │   └── train<span class="selector-class">.h</span></span><br><span class="line">│   ├── obj</span><br><span class="line">│   └── <span class="attribute">src</span></span><br><span class="line">│       ├── client<span class="selector-class">.c</span></span><br><span class="line">│       ├── download<span class="selector-class">.c</span></span><br><span class="line">│       ├── recv<span class="selector-class">.c</span></span><br><span class="line">│       ├── send<span class="selector-class">.c</span></span><br><span class="line">│       └── upload<span class="selector-class">.c</span></span><br><span class="line">├── Makefile</span><br><span class="line">└── server</span><br><span class="line">    ├── server</span><br><span class="line">    │   ├── include</span><br><span class="line">    │   │   ├── factory<span class="selector-class">.h</span>       - 整个线程池的共享资源信息</span><br><span class="line">    │   │   ├── head<span class="selector-class">.h</span>          - 项目头文件，封装好，其余程序只需引用此文件即可</span><br><span class="line">    │   │   ├── netList<span class="selector-class">.h</span>       - !用户连接成功加入，为什么一个任务完成就要移除? </span><br><span class="line">    │   │   ├── taskQueue<span class="selector-class">.h</span>     - 每个功能的对应函数要执行时建立一个!task，主线程专用一个线程来调!parse</span><br><span class="line">    │   │   └── train<span class="selector-class">.h</span>         - 封装的火车头文件传输协议</span><br><span class="line">    ├── repository              - 资源仓库</span><br><span class="line">    │   ├── dir1</span><br><span class="line">    │   │   ├── file2</span><br><span class="line">    │   │   └── file3</span><br><span class="line">    │   ├── dir2</span><br><span class="line">    │   │   └── file4</span><br><span class="line">    │   └── file1</span><br><span class="line">    └── <span class="attribute">src</span></span><br><span class="line">        ├── epollFunc<span class="selector-class">.c</span>         - 封装多路复用</span><br><span class="line">        ├── factoryInit<span class="selector-class">.c</span>       - 封装共享资源初始化</span><br><span class="line">        ├── freeTask<span class="selector-class">.c</span>          - !在线程创建函数中，线程执行结束调用，释放分配的堆区内存，!mallocTaskArg</span><br><span class="line">        ├── getTaskArg<span class="selector-class">.c</span>        - !strtok涉及二级指针和内存分配</span><br><span class="line">        ├── mallocTaskArg<span class="selector-class">.c</span>     - !strtok涉及二级指针和内存分配</span><br><span class="line">        ├── makeWorker<span class="selector-class">.c</span>        - 创建子线程</span><br><span class="line">        ├── netInsert<span class="selector-class">.c</span>         - 链表节点入队操作</span><br><span class="line">        ├── netRemove<span class="selector-class">.c</span>         - 链表节点出队操作 思路要清晰</span><br><span class="line">        ├── parse<span class="selector-class">.c</span>             - 主线程调用的专用于解析命令的功能函数，取参数把对应功能加入任务队列</span><br><span class="line">        ├── get<span class="selector-class">.c</span>               - 服务端发送文件给客户端</span><br><span class="line">        ├── put<span class="selector-class">.c</span>               - 服务端接收文件，对应客户端的功能</span><br><span class="line">        ├── mkDir<span class="selector-class">.c</span>             - 目录流,...</span><br><span class="line">        ├── cd<span class="selector-class">.c</span>                - 目录流,考虑正常切换，错误切换，在根往前切换...</span><br><span class="line">        ├── rm<span class="selector-class">.c</span>                - 目录流,...</span><br><span class="line">        ├── ls<span class="selector-class">.c</span>                - 目录流,注意统一客户端与服务端的信息传输</span><br><span class="line">        ├── pwd<span class="selector-class">.c</span>               - 理论上不需要服务端做什么</span><br><span class="line">        ├── enter<span class="selector-class">.c</span>             - 登录注册</span><br><span class="line">        ├── quit<span class="selector-class">.c</span>   - 退出</span><br><span class="line">        ├── recv<span class="selector-class">.c</span>              - 封装的收发信息接口</span><br><span class="line">        ├── send<span class="selector-class">.c</span>              - 封装的收发信息接口</span><br><span class="line">        ├── server<span class="selector-class">.c</span>            - 线程池主要逻辑，将此前的事件处理封装成结构体， 再理一下思路</span><br><span class="line">        ├── taskDequeue<span class="selector-class">.c</span>       - 线程被唤醒，会从任务队列中出队一个任务， 执行完释放</span><br><span class="line">        ├── taskEnqueue<span class="selector-class">.c</span>       - 有功能函数要调用时，将它入队，在这个函数中分配内存，创建任务</span><br><span class="line">        ├── tcpInit<span class="selector-class">.c</span>           - 封装服务端网络初始化操作</span><br><span class="line">        └── threadFunc<span class="selector-class">.c</span>        - 线程创建函数，涉及条件变量，锁的使用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>server</code></p><blockquote><p>服务端关于<code>netFd </code>与<code> netList</code>的设计 </p><p>对于<code>netFd</code>，用户连接成功时加入<code>netList</code>，为什么在<code>epoll</code>监听的新命令就绪即有用户指令到达时要将<code>netFd</code>移出<code>netList?</code><br>因为主线程监听到<code>netFd</code>(已登录套接字就绪)有命令到，会调用<code>taskEnque</code>让专用于解析命令的功能函数<code>parse</code>作为一个任务入队。执行<code>parse</code>的线程走完，会让一个命令(用户想要执行的)作为一个任务加入任务队列。而加入任务队列的这些命令(功能函数，包括<code>parse</code>解析到非系统命令的情况)末尾的代码逻辑是让<code>netFd</code>重新加入监听。<br>所以在<code>server</code>主线程中需要在命令执行前将<code>netFd</code>移除，它将在任务执行完毕时加入，而处理任务时出队，处理完再入队是符合逻辑的。</p></blockquote><blockquote><pre><code>`freeTask.c          !在线程创建函数中，线程执行结束调用，释放分配的堆区内存，!mallocTaskArg``getTaskArg.c        !strtok涉及二级指针和内存分配``mallocTaskArg.c     !strtok涉及二级指针和内存分配`这几个涉及功能函数参数的内存分配与释放</code></pre></blockquote><blockquote><p>解决粘包问题，封装“火车头”传输协议<code>send.c, recv.c</code></p></blockquote><blockquote><p>文件上传下载</p></blockquote><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220327214949923.png" alt="send&recv" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220327215204477.png" alt="mmap" style="zoom:80%;" /><h1 id="v2"><a href="#v2" class="headerlink" title="v2"></a>v2</h1><blockquote><p>数据库实现用户登录注册，结合数据库用一张表实现虚拟文件系统并由sql语句实现此前的基础命令</p><p>文件传输</p></blockquote><h1 id="v3"><a href="#v3" class="headerlink" title="v3"></a>v3</h1><blockquote><p>长短命令分离(文件传输为长命令) + 超时断开连接</p></blockquote><p>​                    </p>]]></content>
      
      
      
        <tags>
            
            <tag> Proj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix-Linux-Network-Programming</title>
      <link href="/2022/03/13/10.Unix-Linux-Network-Programming/"/>
      <url>/2022/03/13/10.Unix-Linux-Network-Programming/</url>
      
        <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><blockquote><p>Berkeley socket 伯克利套接字，网络编程的实施标准</p><p>socket是网络中用来建立连接，网络通信的设备，用户创建socket可以通过其发起或接受TCP连接，可以向TCP的<strong>发送和接收缓冲区中读写TCP数据段</strong>，或者UCP文本</p><p>大小端问题(一个源于商业的历史遗留问题)一般主机使用小端法(主机字节序)，而用于网络传输，使用大端法(网络字节序) 判断方式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *c=(<span class="keyword">char</span> *)&amp;i; </span><br><span class="line">    <span class="keyword">if</span>(*c == <span class="number">0x12</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;big ending!&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;little ending!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/testendong ./isBigEnding </span><br><span class="line">little ending!</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><blockquote><p>设计网络需要的几个结构体(设置地址信息)</p><p>通用的地址结构 <code>struct sockadd</code> 但是过于通用导致设置复杂，惯用法是通过以下两个结构体来构造地址，利用其<strong>内存布局一致的特点</strong>强转为<code>struct sockaddr </code>作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//man 7 ip </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* address family: AF_INET */</span> </span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port; <span class="comment">/* port in network byte order */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* internet address */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Internet address. */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_addr; <span class="comment">/* address in network byte order */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整数大小端转化接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><p>网络字节序IP与点分十进制IP转化接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><p>使用域名获取IP的接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name; <span class="comment">/* official name of host */</span> </span><br><span class="line">    <span class="keyword">char</span> **h_aliases; <span class="comment">/* alias list */</span> </span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">/* host address type */</span> </span><br><span class="line">    <span class="keyword">int</span> h_length; <span class="comment">/* length of address */</span> </span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">/* list of addresses */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把TCP的通信机制看做两条管道，通信双方为A和B，三次握手分别做了一下几件事</span><br><span class="line">第一次握手A-&gt;B : 现在B知道了A-&gt;B 的通信是正常的  即B知道:A的发送B的接收正常</span><br><span class="line">第二次握手B-&gt;A : 现在A知道了A-&gt;B 与 B-&gt;A的通信是正常的 即A知道:A与B的收发都正常，但B不能确定A的收正常</span><br><span class="line">第三次握手A-&gt;B : 现在A知道自己的收发和B的收发都没有问题，而B还需确认A的接收能力。</span><br><span class="line"></span><br><span class="line">如果只有两次握手，那么B是没能确认A的接收能力的，如果认为两次握手后通信无误，那么A可能只是发了连接请求就关闭了此时认为连接建立成功的B只能永久等待</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">把TCP的通信机制看做两条管道，通信双方为A和B，断开二者的连接需要四次挥手</span><br><span class="line">在一开始，通信双方处于established状态</span><br><span class="line">第一次挥手：如果A先想要主动断开连接，那么它会发送一个FIN报文，报文中会指定一个序列，此时A会处于FIN_WAIT1状态</span><br><span class="line">第二次挥手：B收到来自A的断开请求后会回复一个ACK报文，并回复A所给出的序列值+1作为ACK的序列值。此后B会处于CLOSE_WAIT状态，在CLOSE_WAIT状态的这段时间，B可以发送残余数据。与此同时A处于FIN_WAIT_2状态。</span><br><span class="line">第三次挥手：B的残余数据发送完，当B想要断开连接时，发送一个FIN报文也指定一个序列，此后B处于LAST_ACK状态</span><br><span class="line">第四次挥手：A收到来自B的FIN，发送一个ACK作为应答，也用B给出的序列值+1作为ACK的序列值。此时A将处于TIME_WAIT状态，等待2MSL时间之后才进入CLOSED状态。而B在收到ACK后将处于CLOSED转态。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">主动断开的一方要经历TIME_WAIT状态</span><br><span class="line">这么做的原因是确保B收到ACK的报文，如果没收到的话B会重发FIN报文给A。而A再收到FIN会知道此前的ACK报文丢失，会再重发一次ACK报文给B，设置2MSL即ACK的发送与再发一次FIN的时间。如果2MSL内没有收到FIN说明对方成功接受ACK，A可以顺利进入CLOSED状态。另外2MSL的时间可以确保就连接的包一定消逝。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/NET/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpg" alt="TCP状态转换"></p><blockquote><p>把这些理论应用到网络编程中有如下对应关系图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/NET/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B.jpg" alt="网络编程流程"></p><blockquote><p>这些流程涉及的接口</p><p><code>1.socket</code>创建“socket设备”，一切皆文件，在内核创建socket文件对象(拥有两个文件缓冲区)返回一个文件描述符          </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">                |            |              |</span><br><span class="line">         AF_INET:IPv4     SOCK_STREAM:TCP   弃用填<span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>2.connect</code>客户端向服务端发起连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">                  |                             |</span><br><span class="line">         自己的socket文件描述符           目标的IP地址:如上述构造结构体强转做参数</span><br></pre></td></tr></table></figure><p>使用tcpdump抓包<img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/NET/tcpdump%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B.jpg" alt="tcpdump">在服务端未开或者对应端口未监听的情况，抓包得到上述结果”Connection refused”圈出的两个标志分别表示[S]发出第一次握手， [R.]包收到了，没有丢但是Rst了，无需重传，说明是服务端的问题。</p><p><code>3.bind</code>给套接字赋予一个本地协议地址(IP+Port)之前的操作都在客户端做，客户端已发起连接，服务端需能处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">              |                             |</span><br><span class="line">         自己的socket文件描述符           绑给自己的本地协议地址</span><br><span class="line">参数与客户端的connect一致，但是客户端connect目标地址:服务端的，服务端提供服务，绑的地址是自己用的</span><br></pre></td></tr></table></figure><p><code>4.listen</code>使服务端程序开始监听，此后才能接受服务端的连接。启用<code>listen</code>操作系统知道此套接字是服务端套接字，故<strong>不再启用其收发缓冲区，转而在内核中维护两个队列</strong>(全连接ACCEPT/半连接SYN队列)如下图所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line">                |             |</span><br><span class="line">                |   本用来表示半连接队列与全连接队列长度和，后发展，填个大于<span class="number">0</span>的数即可</span><br><span class="line">                |</span><br><span class="line">    此后sockfd文件描述符所指的套接字专门用来管理连接队列:做监听套接字</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/NET/%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97.jpg" alt="示意图"></p><p>利用这点，可以做SYN泛洪攻击</p><p><strong>到此为止，由上图可知，三次握手全部完成</strong>其中第一次握手由客户端的<code>connect</code>发出而第二三次握手均在<code>listen</code>处。所有完成握手的TCP连接均在内核的全连接队列中。</p><p><code>5.accept</code>服务端调用<code>accept</code>从全连接队列中取出一个TCP连接(全连接队列为空，<code>accept</code>阻塞，有全连接入队，<code>accept</code>就绪(读操作就绪:可以使用<code>select</code>的读集合监听:本质:读全连接队列))。执行<code>accept</code><strong>内核会创建新的套接字文件对象:做已连接套接字；原sockfd文件描述符所指的套接字专门用来管理连接队列:做监听套接字</strong>(其文件描述符是<code>accept</code>的返回值)<strong>这个新的文件对象将用来和客户端通信</strong>(通过TCP连接收发TCP段)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">                 |                      |</span><br><span class="line">                 |              不获取客户端信息填<span class="literal">NULL</span></span><br><span class="line">             监听套接字</span><br></pre></td></tr></table></figure><p><code>6.close</code>客户端或服务端使用<code>close</code>关闭套接字即主动发起断开连接的四次挥手<code>FIN</code></p><p><code>7.send &amp; recv</code>二者用于将数据在内核态空间和内核态缓冲区之间进行传输(只用于TCP)<em>数据拷至内核态并不意味着马上传输，会根据时机再由内核协议栈按规范进行分节(MSS大小:如上图tcpdump抓到的)再根据窗口条件传输至网络层</em>:chicken:实际发送由内核协议栈完成(不去管它)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>[注]使用read, write能达到相同的效果,将flags置为0, 本质是将数据在缓冲区拷入拷出<br>[注]send, recv次数与网络上的TCP段数没有关系:多次send, recv可能只需一次TCP传输<br>[注]TCP是一种流式的通信协议，消息间没有边界:粘包(多个消息一次接受)半包(一个消息多次传输)，而边界问题只靠TCP无法解决，需要由应用层去区分(比如设置额外字段表示有效长度；比如参考字符串设计:标记一个特殊字符\0它不在正文中出现,但它区分边界)</p></blockquote><h2 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h2><h3 id="1-即时聊天"><a href="#1-即时聊天" class="headerlink" title="1.即时聊天"></a>1.即时聊天</h3><blockquote><p>使用TCP + select实现即时聊天，关于select见这篇<a href="https://lacsscal.github.io/2022/02/26/6.Unix-Linux-file-management/">file-management/3.4/IO多路转接模型</a></p></blockquote><p><code>client</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./client xxx.xxx.xxx.xxx xxx</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(sfd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sokAddr</span>;</span></span><br><span class="line">    bzero(&amp;sokAddr, <span class="keyword">sizeof</span>(sokAddr));</span><br><span class="line">    sokAddr.sin_family = AF_INET;</span><br><span class="line">    sokAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    sokAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">int</span> ret = connect(sfd, (struct sockaddr*)&amp;sokAddr, <span class="keyword">sizeof</span>(sokAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;connect&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> total[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用select IO多路复用监听读行为</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(sfd, &amp;rdset);</span><br><span class="line">        select(sfd+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;<span class="comment">//读标准输入发给服务端</span></span><br><span class="line">            bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//拼接一下本人姓名 及本地时间</span></span><br><span class="line">            <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(total, <span class="string">&quot;user1  &quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(total, ctime(&amp;now));</span><br><span class="line">            <span class="built_in">strcat</span>(total, buf);</span><br><span class="line">            send(sfd, total, <span class="built_in">strlen</span>(total)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            bzero(&amp;total, <span class="keyword">sizeof</span>(total));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(sfd, &amp;rdset))&#123;<span class="comment">//读来自tcp通信另一端的数据</span></span><br><span class="line">            bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = recv(sfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>server</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./client xxx.xxx.xxx.xxx xxx 行为类似但是服务端需要多一些操作</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(sfd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">// bind-&gt;listen-&gt;accept</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;<span class="comment">//修改属性让bind无视TIME_WAIT方便调试</span></span><br><span class="line">    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line">    <span class="keyword">int</span> ret = bind(sfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    ret = listen(sfd, <span class="number">10</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;listen&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> netfd = accept(sfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(netfd, <span class="number">-1</span>, <span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> total[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用select IO多路复用监听读行为</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(netfd, &amp;rdset);<span class="comment">//这里监听的是从全连接队列中取出后新建立的</span></span><br><span class="line">        select(netfd+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">strcat</span>(total, <span class="string">&quot;user1  &quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(total, ctime(&amp;now));</span><br><span class="line">            <span class="built_in">strcat</span>(total, buf);</span><br><span class="line">            send(netfd, total, <span class="built_in">strlen</span>(total)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            bzero(&amp;total, <span class="keyword">sizeof</span>(total));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(netfd, &amp;rdset))&#123;<span class="comment">//读来自tcp通信另一端的数据</span></span><br><span class="line">            bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = recv(netfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">                close(sfd);</span><br><span class="line">                close(netfd);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(buf); <span class="comment">//使用printf()更好调试</span></span><br><span class="line">            <span class="comment">// printf(&quot;buf = %s\n&quot;, buf);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(netfd);</span><br><span class="line">    close(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码中有两行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;<span class="comment">//修改属性让bind无视TIME_WAIT方便调试</span></span><br><span class="line">setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br></pre></td></tr></table></figure><p>如果不这么干，当主动关闭服务端时会有</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./server_tcpchat1 192.168.xxx.xxx xxx </span><br><span class="line"><span class="built_in">bind</span>: Address already <span class="keyword">in</span> use </span><br><span class="line">$ netstat -an|grep xxx</span><br><span class="line">tcp 0 0 192.168.xxx.xxx:xxx 192.168.xxx.xxx:xxx TIME_WAIT</span><br></pre></td></tr></table></figure><p>因为服务端作为主动关闭方，在四次回收的最后阶段会处于TIME_WAIT状态，将等待2MSL时间(60s),在此期间再试图<code>bind</code>会报错。因此使用<code>setsockopt</code>修改监听套接字的属性(在<code>bind</code>前执行)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen</span><br><span class="line">这种接口设计方式对设计支持任何类型的参数有参考价值</span><br><span class="line">任何类型的参数都可以，传参时强转为<span class="keyword">void</span> *, 一并给出参数的长度</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-实现聊天室-使服务端支持断开重连"><a href="#2-实现聊天室-使服务端支持断开重连" class="headerlink" title="2.实现聊天室:使服务端支持断开重连"></a>2.实现聊天室:使服务端支持断开重连</h3><blockquote><p>前面讲到<code>accept</code>本质是读全连接队列，因此，也是一个会造成读阻塞的行为，故可以用<code>select</code>监听。而这个特性可以使得服务端可以用<code>select</code>管理监听套接字，检查其全连接队列是否有建好的连接，存在连接则<strong>读事件<code>accept</code>就绪</strong></p><p>要这么用需要对此前代码的逻辑做些调整</p><p><code>server_plus</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*准备工作略去， 去掉一些在这里相对无用的逻辑*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> netfd = <span class="number">-1</span>;<span class="comment">//初始化为-1,注意accept放在了后面做</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    fd_set monitorset;<span class="comment">//监听集合蓝本，新加入的已连接套接字先加入它，每轮循环开头复制给rdset读事件集</span></span><br><span class="line">    FD_ZERO(&amp;monitorset);</span><br><span class="line">    FD_SET(sockfd, &amp;monitorset);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *select前准备要监听的文件描述符,</span></span><br><span class="line"><span class="comment">        *每轮循环更新一次(有新的已连接套接字的文件描述符加入)</span></span><br><span class="line"><span class="comment">        *select第一个参数尽量大一点(避免无法监听到新的已连接套接字文件描述符)</span></span><br><span class="line"><span class="comment">        */</span>         </span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;rdset, &amp;monitorset, <span class="keyword">sizeof</span>(fd_set));</span><br><span class="line">        select(<span class="number">10</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(sockfd, &amp;rdset))&#123;</span><br><span class="line">            netfd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ERROR_CHECK(netfd, <span class="number">-1</span>, <span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;new client is comming ! newfd = %d\n&quot;</span>, netfd);</span><br><span class="line">            FD_SET(netfd, &amp;monitorset);<span class="comment">//有新连接将它加入监听集(蓝本)循环开头更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(netfd, &amp;rdset))&#123;</span><br><span class="line">            bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret = recv(netfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;<span class="comment">//收到对端关闭的信号,从蓝本中清除这个套接字的描述符</span></span><br><span class="line">                close(netfd);</span><br><span class="line">                FD_CLR(netfd, &amp;monitorset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(netfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><code>chatroom-server</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./client xxx.xxx.xxx.xxx xxx </span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(sfd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sokAddr</span>;</span></span><br><span class="line">    bzero(&amp;sokAddr, <span class="keyword">sizeof</span>(sokAddr));</span><br><span class="line">    sokAddr.sin_family = AF_INET;</span><br><span class="line">    sokAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    sokAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">// bind-&gt;listen-&gt;accept</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line">    <span class="keyword">int</span> ret = bind(sfd, (struct sockaddr*)&amp;sokAddr, <span class="keyword">sizeof</span>(sokAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    ret = listen(sfd, <span class="number">10</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;listen&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用select IO多路复用监听读行为</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    fd_set monitorset;</span><br><span class="line">    <span class="comment">// int netfd  = -1;</span></span><br><span class="line">    <span class="keyword">int</span> netfd[<span class="number">20</span>], idx = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)&#123;</span><br><span class="line">        netfd[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FD_ZERO(&amp;monitorset);</span><br><span class="line">    FD_SET(sfd, &amp;monitorset);<span class="comment">//select 管理监听套接字</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;rdset, &amp;monitorset, <span class="keyword">sizeof</span>(fd_set));</span><br><span class="line">        select(<span class="number">10</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(sfd, &amp;rdset))&#123;<span class="comment">//监听套接字的读行为accept</span></span><br><span class="line">            netfd[idx] = accept(sfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ERROR_CHECK(netfd[idx], <span class="number">-1</span>, <span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;new client join, netfd = %d\n&quot;</span>, netfd[idx]);</span><br><span class="line">            FD_SET(netfd[idx], &amp;monitorset);</span><br><span class="line">            idx++;<span class="comment">//有新连接加入监听集，索引后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 监听每个建立的netfd 的信号如果收到，将它转发给所有在监听的窗口。每轮遍历    </span></span><br><span class="line">        <span class="keyword">for</span>(cnt = <span class="number">0</span>; cnt &lt; idx; ++cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(netfd[cnt], &amp;rdset))&#123;<span class="comment">//读来自tcp通信另一端的数据</span></span><br><span class="line">                bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                ret = recv(netfd[cnt], buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;netfd[%d] is leave&quot;</span>, netfd[cnt]);<span class="comment">//调试用</span></span><br><span class="line">                    close(netfd[cnt]);</span><br><span class="line">                    FD_CLR(netfd[cnt], &amp;monitorset);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; idx; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j != cnt)&#123;</span><br><span class="line">                        send(netfd[j], buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);     </span><br><span class="line">                    &#125;        </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>chatroom-client</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./client xxx.xxx.xxx.xxx xxx</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(sfd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sokAddr</span>;</span></span><br><span class="line">    bzero(&amp;sokAddr, <span class="keyword">sizeof</span>(sokAddr));</span><br><span class="line">    sokAddr.sin_family = AF_INET;</span><br><span class="line">    sokAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    sokAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="keyword">int</span> ret = connect(sfd, (struct sockaddr*)&amp;sokAddr, <span class="keyword">sizeof</span>(sokAddr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;connect&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> total[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用select IO多路复用监听读行为</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(sfd, &amp;rdset);</span><br><span class="line">        select(sfd+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;<span class="comment">//读标准输入发给服务端，由服务端转发给通信的对端</span></span><br><span class="line">            bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            send(sfd, buf, <span class="built_in">strlen</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*问题： 客户端break直接close(sfd)*/</span> </span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(sfd, &amp;rdset))&#123;<span class="comment">//读来自tcp通信另一端的数据(服务端转发的)</span></span><br><span class="line">            bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            ret = recv(sfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Unix/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APUE_1_Overview</title>
      <link href="/2022/03/09/9.APUE-1-Overview/"/>
      <url>/2022/03/09/9.APUE-1-Overview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不同版本UNIX操作系统提供的服务</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/APUE/Unix%E6%9E%B6%E6%9E%84.png" alt="架构图"></p><blockquote><p>一些概念摘抄</p><p>逻辑上可以认为每个目录项包含一个文件名，以及说明该文件属性的信息</p><p>登录时，工作目录设置为起始目录，从口令文件<code>/etc/passwd</code>中相应用户登录项获取</p><p>文件描述符<code>file discriptor</code>内核用以标识特定进程正在访问的文件,对内核而言，所有打开的文件都用文件描述符引用</p><p>标准I/O 不带缓冲I/O<code>unbuffered I/O</code></p><p>程序是存储在磁盘上某个目录中的可执行文件，内核使用<code>exec</code>函数将程序读入内存</p><p>之所以使用用户ID和组ID是历史原因，存储两个值4字节，存储完整的用户名和组名需要更多磁盘空间，检查权限时，比较字符串比比较整型数更耗时间</p><p>从实现者的角度看，系统调用和库函数之间有根本的区别，但从用户的角度看，其区别并不重要；系统调用通常提供一种最小接口，而库函数则提供比较复杂的功能。</p><p><code>POSIX : Portable Operating System Interface</code></p><p>每个打开的文件都有一个与其相关联的”当前文件偏移量”(<code>current file offset</code>)通常，读写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。</p><p>文件偏移量可以大于文件的当前长度，在此情况下对该文件的下一次写将加长该文件并在文件中构成文件空洞(文件空洞不要求在磁盘上占存储区，只做定位具体处理方式看文件系统的实现)</p></blockquote><blockquote><p>文件操作</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/APUE/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="打开文件的内核数据结构"></p><blockquote><p>Linux 采用一个与文件系统无关的i节点和一个与文件系统相关的i节点</p><p>任何多于一个函数调用的操作都不是原子操作，因为在两个函数调用之间，内核可能临时挂起进程。</p><p><code>/dev/fd</code>目录中，目录项为0， 1， 2等文件， 打开<code>/dev/fd/n</code>等效于复制描述符n</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[scallacs@VM-16-8-ubuntu /dev/fd\ []$ ls</span><br><span class="line">0  1  2  255</span><br><span class="line">[scallacs@VM-16-8-ubuntu /dev/fd\ []$ ll</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 scallacs scallacs  0 Mar 10 14:47 ./</span><br><span class="line">dr-xr-xr-x 9 scallacs scallacs  0 Mar 10 14:26 ../</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 0 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 1 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 2 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 255 -&gt; /dev/pts/4</span><br></pre></td></tr></table></figure><p>它把文件描述符映射为指向底层物理文件的符号链接</p><p><code>read, write</code>都在内核执行，所以成为不带缓冲的I/O函数</p><p>为了执行程序，内核必须理解二进制可执行文件的格式，所有二进制可执行文件都遵循一种标准化的格式，这种格式使内核能确定程序文本和数据的加载位置。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> UNIX APUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.Unix-Linux-Thread</title>
      <link href="/2022/03/07/8.Unix-Linux-Thread/"/>
      <url>/2022/03/07/8.Unix-Linux-Thread/</url>
      
        <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、线程基础"><a href="#一、线程基础" class="headerlink" title="一、线程基础"></a>一、线程基础</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote><p>在Linux中线程是轻量级的进程(LWP:Low-weight-Process)减少进程切换的开销,它也拥有独立的task_struct作为独立的动态执行流(同属于一个进程的多个线程task_struct中有大量字段相同或共享)方便CPU进行调度。</p><p>进程除了作为独立的执行流外，还是资源分配的基本单位，使用线程并非要取代进程，而是让一个进程中存在多个线程，它们共享内存资源(线程有独立的栈但堆，数据段，代码段，文件描述符，信号屏蔽字等共享)，同时把CPU的调度单位细化为线程。</p><p>分析性能时，计算机将大量的时间花费在进程切换上(上下文切换:CPU寄存器中大量信息:堆栈，代码段…:寄存器与内存间的保存与载入工作；进程切换虚拟内存页表切换)</p></blockquote><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/进程管理/线程模型.jpg" alt="线程" style="zoom:80%;" /><blockquote><p>同一个进程的多个线程各自拥有自己的栈，这些栈虽然是独立的，但是都位于同一个地址空间中，所以一个线程可以通过地址去访问另一个线程的栈区。</p></blockquote><blockquote><p>多线程天生就能利用多核的CPU架构，此前的进程都可以认为是单线程进程</p><p>使用线程库NPTL(Native Posix Threads Library)</p></blockquote><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><blockquote><p>接口</p></blockquote><p><code>pthread_creat 创建一个线程</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">传指针</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *parg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)parg;<span class="comment">//用时再强转回来，这样void*的参数能传递所有类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am child, p = %s\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello&quot;</span>);                 <span class="comment">//|-&gt;线程入口函数     |-&gt;线程函数所用参数, 传参时强转</span></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, threadFunc, (<span class="keyword">void</span> *)p);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am main, p = %s\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">传长整型为*惯用法* 长整型与指针型都是<span class="number">8B</span>，不会有信息丢失，传递时用<span class="keyword">void</span>*,实际上并不指向任何地址空间，使用时再强转回<span class="keyword">long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> val = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am child, val = %ld\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">long</span> val = <span class="number">1001</span>;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,threadFunc,(<span class="keyword">void</span> *)val);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_exit 线程的主动退出</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure><p><code>pthread_join 捕获另一线程的退出状态</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br><span class="line">                                        |</span><br><span class="line">             在一个线程中调用此函数，获取目标tid线程的终止状态，因为终止状态(返回值)是<span class="keyword">void</span>*型的指针</span><br><span class="line">             调用此函数的线程需在自己的栈帧中开辟一块<span class="keyword">void</span>*存储这个终止状态值</span><br><span class="line">             而pthread_join作为被调函数，想要把这个终止状态值写入主调的栈帧中需要使用二重指针</span><br><span class="line">             所以主调定义<span class="keyword">void</span> *retval 传参时使用 &amp;<span class="function">retval</span></span><br><span class="line"><span class="function">             <span class="title">pthread_join</span><span class="params">(tid, &amp;ret)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %ld\n&quot;</span>, (<span class="keyword">long</span>)ret); 打印输出时强转一下(<span class="keyword">long</span> 与 vod* 同八字节不会损耗)</span><br></pre></td></tr></table></figure><p><code>pthread_cancel 线程的取消-将取消标志位置为真，直到遇到一些特殊函数(取消点)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I still alive!\n&quot;</span>);</span><br><span class="line">        <span class="comment">//printf底层使用write，属于cancellation point, 所以当取消标志为真时，遇到它会退出</span></span><br><span class="line">        <span class="comment">// pthread_testcancel();//或者自行设置取消点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//让子线程跑一会儿;</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line">    pthread_join(tid, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You dies, ret = %ld\n&quot;</span>, (<span class="keyword">long</span>)ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ubuntu@VM<span class="number">-16</span><span class="number">-8</span>-ubuntu ~/linux/\ []$ make</span><br><span class="line">gcc cancel.c -o cancel -g -lpthread</span><br><span class="line">[ubuntu@VM<span class="number">-16</span><span class="number">-8</span>-ubuntu ~/linux/\ []$ ./cancel </span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">.............</span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">I still alive!</span><br><span class="line">You dies, ret = <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><code>资源清理函数一组</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pthread_cleanup_push</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function">pthread_cleanup_pop</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br><span class="line"></span><br><span class="line">底层实现是 <span class="keyword">do</span>&#123;....       ....&#125;<span class="keyword">while</span>();</span><br><span class="line">           |                   |</span><br><span class="line">pthread_cleanup_push        pthread_cleanup_pop</span><br><span class="line">所以必须成对出现，否则括号不能匹配，编译不通过。</span><br></pre></td></tr></table></figure><h2 id="二-互斥锁与条件变量-同步"><a href="#二-互斥锁与条件变量-同步" class="headerlink" title="二.互斥锁与条件变量(同步)"></a>二.互斥锁与条件变量(同步)</h2><blockquote><p>互斥锁初探</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">shareRes_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125; shareRes_t;</span><br><span class="line"><span class="comment">// 共享资源只有一把锁，测试一下,不对共享资源操作的线程加不加锁是无所谓的</span></span><br><span class="line"><span class="comment">// 但是只有一把锁做共享资源可以保证同一时间只有持有锁的线程能够运行并且在解锁前不被打断</span></span><br><span class="line"><span class="comment">// 无论运行过程中此线程睡了多久。当然线程的执行顺序是随机的。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadB</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    shareRes_t *pshared = (shareRes_t *)arg;</span><br><span class="line">    pthread_mutex_lock(&amp;pshared-&gt;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B tid = %lu, is running...\n&quot;</span>, pthread_self()); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B says:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;pshared-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadA</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    shareRes_t *pshared = (shareRes_t *)arg;</span><br><span class="line">    pthread_mutex_lock(&amp;pshared-&gt;mutex);</span><br><span class="line">    usleep(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;A says:hello&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2 sec sleeping, A want to do ...&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;pshared-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shareRes_t shared;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_mutex_init(&amp;shared.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, threadA, (<span class="keyword">void</span>*)&amp;shared);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, threadB, (<span class="keyword">void</span>*)&amp;shared);</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[scallacs@VM<span class="number">-16</span><span class="number">-8</span>-ubuntu ~/linux/mutex\ []$ ./testlock </span><br><span class="line">A says:hello</span><br><span class="line"><span class="number">2</span> sec sleeping, A want to <span class="keyword">do</span> ...</span><br><span class="line">B tid = <span class="number">140015543969536</span>, is running...</span><br><span class="line">B says:</span><br><span class="line">world</span><br><span class="line">[scallacs@VM<span class="number">-16</span><span class="number">-8</span>-ubuntu ~/linux/mutex\ []$ ./testlock </span><br><span class="line">B tid = <span class="number">140180205360896</span>, is running...</span><br><span class="line">B says:</span><br><span class="line">world</span><br><span class="line">A says:hello</span><br><span class="line"><span class="number">2</span> sec sleeping, A want to <span class="keyword">do</span> ...</span><br></pre></td></tr></table></figure><blockquote><p>条件变量的使用</p><p>上半部<br>    1.会检查当前线程是否持有锁<br>    2.若是持有锁将此线程加入该条件变量的唤醒队列<br>    3.当前线程会解锁并陷入阻塞(原子操作)<br>    4.持续等待signal到来<br>下半部<br>    1.当收到signal后，唤醒后会先加锁(原子操作)<br>    2.执行后续代码。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%90%8C%E6%AD%A5cond_waitA%E5%9C%A8B%E5%89%8D.png" alt="同步A在B前"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">shareRes_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">    </span><br><span class="line">&#125; shareRes_t;</span><br><span class="line"><span class="comment">//使用pthread_cond_wait 实现A线程先执行B线程后执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadB</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    shareRes_t *pshared = (shareRes_t *)arg;</span><br><span class="line">    pthread_mutex_lock(&amp;pshared-&gt;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B tid = %lu, is waiting...\n&quot;</span>, pthread_self()); </span><br><span class="line">    pthread_cond_wait(&amp;pshared-&gt;cond, &amp;pshared-&gt;mutex);</span><br><span class="line">    <span class="comment">//线程运行，检测到持有锁，走到这里先解锁再阻塞等待信号</span></span><br><span class="line">    <span class="comment">// 当收到信号则继续执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B is signaled\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;pshared-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现A线程在B线程前运行完，在A做完想做的事后向B发signal</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadA</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    shareRes_t *pshared = (shareRes_t *)arg;</span><br><span class="line">    usleep(<span class="number">30</span>);<span class="comment">//让B线程先wait阻塞, 做完想做的事情再signal</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;A says:hello&quot;</span>);</span><br><span class="line">    pthread_cond_signal(&amp;pshared-&gt;cond);<span class="comment">//B线程收到信号到抢到锁是需要时间的</span></span><br><span class="line">    usleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;after signal A want to do ...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shareRes_t shared;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_mutex_init(&amp;shared.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;shared.cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, threadA, (<span class="keyword">void</span>*)&amp;shared);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, threadB, (<span class="keyword">void</span>*)&amp;shared);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特殊的例子，条件变量-加锁阻塞</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%90%8C%E6%AD%A5A%E5%9C%A8B%E5%89%8D%E4%B8%94A%E5%8A%A0%E9%94%81B%E9%9C%80%E9%99%B7%E5%85%A5%E5%8A%A0%E9%94%81%E9%98%BB%E5%A1%9E-%E6%94%B9.png" alt="加锁阻塞"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">shareRes_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">    </span><br><span class="line">&#125; shareRes_t;</span><br><span class="line"><span class="comment">//使用pthread_cond_wait 实现A线程先执行B线程后执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadB</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    shareRes_t *pshared = (shareRes_t *)arg;</span><br><span class="line">    pthread_mutex_lock(&amp;pshared-&gt;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B tid = %lu, is waiting...\n&quot;</span>, pthread_self()); </span><br><span class="line">    pthread_cond_wait(&amp;pshared-&gt;cond, &amp;pshared-&gt;mutex);</span><br><span class="line">    <span class="comment">//线程运行，检测到持有锁，走到这里先解锁再阻塞等待信号</span></span><br><span class="line">    <span class="comment">// 当收到信号则继续执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B is signaled\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;pshared-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现A线程在B线程前运行完，在A做完想做的事后向B发signal</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadA</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    shareRes_t *pshared = (shareRes_t *)arg;</span><br><span class="line">    usleep(<span class="number">30</span>);<span class="comment">//让B线程先wait阻塞, 做完想做的事情再signal</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;A says:hello&quot;</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;pshared-&gt;mutex);<span class="comment">//发信号唤醒B前先加锁，B醒来发现加锁失败会再陷入阻塞</span></span><br><span class="line">    pthread_cond_signal(&amp;pshared-&gt;cond);<span class="comment">//B线程收到信号到抢到锁是需要时间的</span></span><br><span class="line">    usleep(<span class="number">5</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;after signal A want to do ...&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;pshared-&gt;mutex);<span class="comment">//直到A解锁B才会执行，这样B的输出永远在A的输出后面，不论A等了多久</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shareRes_t shared;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_mutex_init(&amp;shared.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;shared.cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, threadA, (<span class="keyword">void</span>*)&amp;shared);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, threadB, (<span class="keyword">void</span>*)&amp;shared);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>互斥锁与条件变量同步的应用——生产者消费者问题再探</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAPACITY 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">elem_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">shareRes_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">elem_t</span> <span class="built_in">queue</span>[CAPACITY];</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;shareRes_t;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    shareRes_t *pshareRes = (shareRes_t*)arg;</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//让消费者先行, 访问共享资源前加锁</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pshareRes-&gt;mutex);</span><br><span class="line">        <span class="keyword">while</span>(pshareRes-&gt;size == CAPACITY)&#123;<span class="comment">//使用broadcast广播的话，预防虚假唤醒,判断资源不够再睡一会儿</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Producer %lu still wait.\n&quot;</span>, pthread_self()%<span class="number">100</span>);</span><br><span class="line">            pthread_cond_wait(&amp;pshareRes-&gt;cond, &amp;pshareRes-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pshareRes-&gt;size &lt; CAPACITY)&#123;<span class="comment">//未生产满继续入队</span></span><br><span class="line">            pshareRes-&gt;<span class="built_in">queue</span>[pshareRes-&gt;rear++] = num++;</span><br><span class="line">            ++pshareRes-&gt;size;</span><br><span class="line">            pshareRes-&gt;rear %= CAPACITY;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Produce %lu ! : fornt = %d, rear = %d, size = %d\n&quot;</span>, </span><br><span class="line">                pthread_self()%<span class="number">100</span>,</span><br><span class="line">                pshareRes-&gt;<span class="built_in">queue</span>[pshareRes-&gt;front] ,</span><br><span class="line">                pshareRes-&gt;<span class="built_in">queue</span>[pshareRes-&gt;rear<span class="number">-1</span> &gt;= <span class="number">0</span> ? pshareRes-&gt;rear<span class="number">-1</span> : CAPACITY<span class="number">-1</span>],<span class="comment">//循环队列</span></span><br><span class="line">                pshareRes-&gt;size);</span><br><span class="line">            <span class="comment">// 产出第一个商品可以发信号唤醒消费者</span></span><br><span class="line">            <span class="keyword">if</span>(pshareRes-&gt;size == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;signaled consumer!&quot;</span>);</span><br><span class="line">                pthread_cond_signal(&amp;pshareRes-&gt;cond);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//生产满了，阻塞</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;producer wait...&quot;</span>);</span><br><span class="line">            pthread_cond_wait(&amp;pshareRes-&gt;cond, &amp;pshareRes-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;pshareRes-&gt;mutex);</span><br><span class="line">        sleep(<span class="number">1</span>);<span class="comment">//停一会儿，放置立刻抢占,空转</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    shareRes_t *pshareRes = (shareRes_t*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pshareRes-&gt;mutex);</span><br><span class="line">        <span class="keyword">if</span>(pshareRes-&gt;size &gt; <span class="number">0</span>)&#123;<span class="comment">//有货消费出队</span></span><br><span class="line">            pshareRes-&gt;front++;</span><br><span class="line">            pshareRes-&gt;front %= CAPACITY;</span><br><span class="line">            --pshareRes-&gt;size;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Consume ! : fornt = %d, rear = %d, size = %d\n&quot;</span>, </span><br><span class="line">                pshareRes-&gt;<span class="built_in">queue</span>[pshareRes-&gt;front] ,</span><br><span class="line">                pshareRes-&gt;<span class="built_in">queue</span>[pshareRes-&gt;rear<span class="number">-1</span> &gt;= <span class="number">0</span> ? pshareRes-&gt;rear<span class="number">-1</span> : CAPACITY<span class="number">-1</span>],<span class="comment">//循环队列</span></span><br><span class="line">                pshareRes-&gt;size);</span><br><span class="line">            <span class="comment">// 对于生产者阻塞的，消费一个把它唤醒,两个消费者广播</span></span><br><span class="line">            <span class="keyword">if</span>(pshareRes-&gt;size == CAPACITY<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;signaled producer!&quot;</span>);</span><br><span class="line">                pthread_cond_broadcast(&amp;pshareRes-&gt;cond);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;consumer wait...&quot;</span>);</span><br><span class="line">            pthread_cond_wait(&amp;pshareRes-&gt;cond, &amp;pshareRes-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;pshareRes-&gt;mutex);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个生产者(共用一个创建函数)一个消费者,主线程做控制线程只完成初始化和回收等工作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shareRes_t shareRes;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;shareRes, <span class="number">0</span>, <span class="keyword">sizeof</span>(shareRes_t));</span><br><span class="line">    pthread_cond_init(&amp;shareRes.cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;shareRes.mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> producer1, producer2, consumer;</span><br><span class="line">    pthread_create(&amp;producer1, <span class="literal">NULL</span>, Producer, (<span class="keyword">void</span>*)&amp;shareRes);</span><br><span class="line">    pthread_create(&amp;producer2, <span class="literal">NULL</span>, Producer, (<span class="keyword">void</span>*)&amp;shareRes);</span><br><span class="line">    pthread_create(&amp;consumer, <span class="literal">NULL</span>, Consumer, (<span class="keyword">void</span>*)&amp;shareRes);</span><br><span class="line">    pthread_join(producer1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(producer2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Unix/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix-Linux-Process-management</title>
      <link href="/2022/03/02/7.Unix-Linux-Process-management/"/>
      <url>/2022/03/02/7.Unix-Linux-Process-management/</url>
      
        <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、进程基础"><a href="#一、进程基础" class="headerlink" title="一、进程基础"></a>一、进程基础</h2><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0.概念"></a>0.概念</h3><blockquote><p>程序：静态文件，二进制指令和数据的集合，存储在磁盘中</p><p>进程：程序的动态执行过程，资源分配的基本单位(占CPU资源以执行程序指令，占存储资源以保存状态(数据段，代码段，堆…))，进程是处于执行器的程序和相关资源的总称。(同一份静态程序，可以启动多个不同进程).以进程的视角来看，它是独占CPU的，同时它也是独占内存空间的。以进程视角看到的内存空间称为虚拟内存空间。如下图所示。</p><p>[注]在内核态空间里面，与进程相关的数据结构是每个进程都不同的，物理存储器和内核代码数据是所有进程共享的。内核进程通常被成为内核线程，因为它们没有自己的独立地址空间，它们永远运行在内核态空间或者说它们本身就是内核的一部分。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%9B%B4%E7%BB%86%E5%8C%96%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.jpg" alt="更细化恶虚拟内存空间"></p><blockquote><p>Linux开机:(ROM中存有自举程序，计算机加电，CPU的PC置为自举程序的第一条指令，这个程序的唯一职责是把OS本身(至少是启动计算机的那部分)装入内存)主要关注进程的话，略过这些细节，在所有硬件配置好的情况下，<strong>这时bootloader程序会启动0号进程。0号进程会配置实时时钟，它的主要工作是启动1号进程(init,新版中被systemd取代)和2号进程(页面守护进程)</strong>,0号进程在启动完1号2号进程后终止(后面OS会再重启一个0号进程，但功能完全不同，它是idel空闲进程PID:0, 因为CPU总要选择一个进程运行，所以没活干的时候让CPU运行idel进程以省电。<strong>1号进程是其他所有用户进程的祖先, 2号进程是其他内核线程的祖先</strong>内核进程不占用户虚拟地址，也称做用户线程</p></blockquote><h3 id="1-一些库函数和系统调用"><a href="#1-一些库函数和系统调用" class="headerlink" title="1.一些库函数和系统调用"></a>1.一些库函数和系统调用</h3><p><code>GETPID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GETPPID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GETUID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GETEUID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GETGID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>GETEGID(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>在这些信息的基础上，要清晰一些概念，进程是动态的，当进程启动后，<strong>启动者的权限和属性</strong>以及程序的指令和数据会加载到内存中，为了方便普通用户定位进程，操作系统会为进程分配唯一正整数标识符PID，进程之间存在亲缘关系(pid, ppid)。为了方便内核进行进程的权限管理，默认进程拥有启动用户的身份(uid, gid)。<strong>内核对进程进行访问权限检查是，检查的是euid, egid</strong>默认与uid,gid相同。</p><p>下面用这些基础概念和系统调用探究一下<code>$passwd</code>的实现原理</p></blockquote><h3 id="2-passwd的实现原理与特殊权限管理"><a href="#2-passwd的实现原理与特殊权限管理" class="headerlink" title="2. $passwd的实现原理与特殊权限管理"></a>2. <code>$passwd</code>的实现原理与特殊权限管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scallacs@scallacs$ ll /etc/shadow </span><br><span class="line">-rw-r----- 1 root shadow 1.5K Feb 28 19:51 /etc/shadow</span><br></pre></td></tr></table></figure><blockquote><p>密码存在/etc/shadow 中，该文件的所有者为root,所属组为shadow，照这样用常规思路来想，用户在不是root或b不在shadow组的情况下是不能修改shadow的，甚至在shadow组中也只有读权限。</p><p>Q：那么：为什么普通用户使用passwd命令能成功修改密码?</p><p>A：显然普通用户在执行passwd时，获取了/etc/shadow的写权限，也就是说此时普通用户的euid是root。（前文讲到:内核对进程进行访问权限检查是，检查的是euid)。也就是说，存在这样一种机制，使得用户在运行某进程时修改自己的euid或egid.</p><p>Q：想一想还有没有类似的命令，运行时可以做到本身权限不能做到的事情</p><p>A：sudo</p><p>那么，获取一下这两个命令可执行文件的信息，看看有无什么特殊之处</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scallacs@scallacs$ <span class="built_in">which</span> sudo</span><br><span class="line">/usr/bin/sudo</span><br><span class="line">scallacs@scallacs$ ll /usr/bin/sudo</span><br><span class="line">-rwsr-xr-x 1 root root 146K Jan 19  2021 /usr/bin/sudo</span><br><span class="line">scallacs@scallacs$ ll /usr/bin/passwd  </span><br><span class="line">-rwsr-xr-x 1 root root 59K Jan 26 00:26 /usr/bin/passwd</span><br><span class="line">   |</span><br><span class="line">  s权限</span><br></pre></td></tr></table></figure><blockquote><p>它们都有s权限</p></blockquote><blockquote><p>文件的特殊权限：</p><p>在此前的9位普通权限的基础上，还有三位特殊权限，</p><p>针对所有者权限有SUID，用于在程序运行中修改自己的euid为文件所有者。</p><p>类似的针对所属组有SGID，用于修改自己的egid为文件所属组。</p><p>对于目录文件，可以使用sticky bit(SBIT)权限限制用户协同工作时的一些操作。比如/tmp</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxrwt  18 root root  12K Mar  2 20:28 tmp </span><br><span class="line">         |</span><br><span class="line">       sticky bit 对目录有写权限，但不能删除其他用户的文件</span><br></pre></td></tr></table></figure><p><code>应用举例：SUID SGID</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">A用户编写一个程序，用来往file文件中写入内容hello，然后编译后，增加s权限，这时B用户执行该程序，能够往file文件中写入hello。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./write file</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用户A执行</span><br><span class="line">scallacs@scallacs:~/test/$ ./write file</span><br><span class="line">scallacs@scallacs:~/test/$ cat file </span><br><span class="line">hello</span><br><span class="line">用户A为程序增加suid权限</span><br><span class="line">scallacs@scallacs:~/test/$ chmod u+s write</span><br><span class="line">scallacs@scallacs:~/test/$ ls -l write</span><br><span class="line">-rwsrwxr-x <span class="number">1</span> scallacs scallacs <span class="number">8496</span> Feb <span class="number">28</span> <span class="number">20</span>:<span class="number">23</span> write</span><br><span class="line">   |</span><br><span class="line">  所有者有s权限</span><br><span class="line">先把文件清空</span><br><span class="line">scallacs@scallacs:~/test/$ echo -n &gt; file </span><br><span class="line">    </span><br><span class="line">切到用户B 执行</span><br><span class="line">scallacs@scallacs:~/test/$ su test</span><br><span class="line">Password: </span><br><span class="line">[test@scallacs /home/scallacs/test/\[]$ ./write file</span><br></pre></td></tr></table></figure><h3 id="3-使用系统调用创建进程-由可执行程序启动多个进程"><a href="#3-使用系统调用创建进程-由可执行程序启动多个进程" class="headerlink" title="3.使用系统调用创建进程(由可执行程序启动多个进程)"></a>3.使用系统调用创建进程(由可执行程序启动多个进程)</h3><p><code>system(3)</code></p><blockquote><p>之前使用过这个库函数，它是可以执行系统命令的比如<code>system(&quot;cls&quot;);</code>，也就是说它启动了另外的进程，可以使用<code>ps</code>命令看一下。会发现它创建了3个进程，并且3个进程之间存在父子亲缘关系。那么它的原理是什么，man一下它的手册</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The  <span class="title">system</span><span class="params">()</span>  library  function  uses <span class="title">fork</span><span class="params">(<span class="number">2</span>)</span> to create a child process</span></span><br><span class="line"><span class="function">that executes the shell command specified in command <span class="keyword">using</span>  <span class="title">execl</span><span class="params">(<span class="number">3</span>)</span>  as follows:</span></span><br><span class="line"><span class="function">   <span class="title">execl</span><span class="params">(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, (<span class="keyword">char</span> *) <span class="number">0</span>)</span></span>;</span><br><span class="line">system() returns after the command has been completed.</span><br></pre></td></tr></table></figure><blockquote><p><code>system()</code> 使用 <code>fork()</code>和<code>execl()</code>实现</p></blockquote><p><code>fork(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>fork的原理(先引入几个概念)</p><p>中断：硬件发送信息给CPU，CPU通知OS处理中断事宜.</p><p>异常：类似中断的概念，进程主动给CPU发消息(软件中断)，在x86体系,系统调用利用软中断实现(这个软中断叫<strong>陷入</strong>)</p><p>[注]OS对中断和异常的处理流程是一致的，除了信息的来源不同。</p><p>中断的上半部 下半部….</p></blockquote><blockquote><p>通过 fork 创建的子进程，它从父进程继承了进程的地址空间，包括进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设定、进程优先级、进程组ID、当前工作目录、根目录、资源限制、控制终端，而子进程所独有的只有它的进程ID、资源使用和计时器等。</p><p>子进程与父进程是clone与被clone的关系，在这种情况下，子进程可能会<em>认为自己</em>是**调用fork()**的那个人，因此以返回值区分子进程与父进程，子进程返回0，父进程返回子进程的PID。这样，用一个选择结构就可以让父子进程执行不同的操作。</p></blockquote><p><code>fork的基本用法</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child, pid = %d, ppid = %d\n&quot;</span>,</span><br><span class="line">            getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent, pid = %d, ppid = %d\n&quot;</span>,</span><br><span class="line">            getpid(),getppid());</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>fork()的写时复制</p><p>当执行了 fork 了以后，父子进程地址空间的内容是完全一致，所以完全可以共享同一片物理内存，也就是父子进程的同一个虚拟地址会对应同一个物理内存字节。通常来说，内存的分配单位是页，我们可以为每一个内存页维持一个引用计数。代码段的部分因为只读，所以完全可以多个进程同时共享。而对于地址空间的其他部分，当进程对某个内存页进行写入操作的时候，我们再真正执行被修改的虚拟内存页分配物理内存并拷贝数据，这就是所谓的<strong>写时复制</strong>。在执行拷贝以后，同样的虚拟地址就无法对应同样物理内存字节了。如下图所示</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/fork%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png"></p><blockquote><p>fork()刚创建出子进程以及父子进程只进行读操作都不会影响物理内存，二者共享同一片物理内存即可，但一旦有写操作发生，未改变的进程就需要拷贝原物理页，并分配新的物理页。* Copy On Write.*</p><p>[注]内核态地址空间拷贝和用户态会有所区别。 fork 产生的子进程会拷贝一份文件描述符数组，但是通过文件描述符所指向的文件对象是共享的。这种拷贝方式类似于 dup 系统调用，所以父子进程对同一个文件对象会共享读写位置</p><p>共享文件对象&lt;=&gt;共享内核文件缓冲区的偏移</p></blockquote><p><code>关于共享文件对象的思考</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">程序一共输出多少个“-”</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">共打印<span class="number">8</span>个，<span class="built_in">printf</span>()格式串中没有\n 输出放到<span class="built_in">stdout</span>:行缓冲</span><br><span class="line">第一次循环fork创建一个子进程 父子进程<span class="built_in">stdout</span>中各有一个 <span class="string">&#x27;-&#x27;</span></span><br><span class="line">第二次循环各自创建一个子进程 一个四个进程用户空间信息一致，再执行<span class="built_in">printf</span>各自放入一个<span class="string">&#x27;-&#x27;</span></span><br><span class="line">程序结束 全部打印 一共<span class="number">8</span>个</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">把<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>)换成<span class="built_in">printf</span>(<span class="string">&quot;-\n&quot;</span>)；程序会输出多少个“-”?思考一下为什么？</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-\n&quot;</span>);<span class="comment">//共打印6个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">共打印<span class="number">6</span>个</span><br><span class="line">第一次循环fork创建一个子进程 父子进程各向<span class="built_in">stdout</span>输出一个 <span class="string">&#x27;-&#x27;</span>，然后<span class="built_in">stdout</span>空了</span><br><span class="line">第二次循环各自创建一个子进程 一个四个进程用户空间信息一致都是空的，再执行<span class="built_in">printf</span>各自输出一个<span class="string">&#x27;-&#x27;</span></span><br><span class="line">程序结束 全部打印 一共<span class="number">6</span>个</span><br></pre></td></tr></table></figure><p><code>execl(3)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>exec(execute)用在 fork 之后，将子进程的指令部分进行替换修改。当进程执行到 exec* 系统调用的时候，它会将传入的指令来取代进程本身的代码段、数据段、栈和堆，然后将PC指针重置为新的代码段的入口。</p></blockquote><p><code>示例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过execl拉起来一个进程，传递两个数字，比如15和65。被拉起的进程创建一个随机数，该随机数的范围在15-65之间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    execl(<span class="string">&quot;random&quot;</span>, <span class="string">&quot;./random&quot;</span>, <span class="string">&quot;15&quot;</span>, <span class="string">&quot;56&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个随机数，该随机数的范围在15-65之间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./add 15 56</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> lhs = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> rhs = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> rand = random()%(rhs - lhs + <span class="number">1</span>);</span><br><span class="line">    rand += lhs;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the random num = %d\n&quot;</span>, rand);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>使用fork 与execl实现system</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个mysystem程序，实现跟system函数类似的功能（只需要创建一个子进程）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySystem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//解析command 以space分割</span></span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> *args[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, command); </span><br><span class="line">        <span class="comment">// puts(str);</span></span><br><span class="line">        <span class="keyword">char</span> *word = strtok(str, <span class="string">&quot; &quot;</span>); </span><br><span class="line">        <span class="comment">// puts(word); </span></span><br><span class="line">        args[<span class="number">0</span>] = word;<span class="comment">//之前试图用strcpy函数写，写不进去? 遇到没显示的地方可能是访问空指针导致段错误了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((word = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// puts(word);</span></span><br><span class="line">            args[i] = word;<span class="comment">//操作数组小心越界问题 对于子进程的gdb调试方法 set follow-fork-mode child</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// execl(&quot;random&quot;, &quot;./random&quot;, &quot;15&quot;, &quot;56&quot;, NULL);</span></span><br><span class="line">        execv(<span class="string">&quot;random&quot;</span>, args);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system(&quot;./random 15 56&quot;); //传进一个命令，起一个shell，执行它</span></span><br><span class="line">    mySystem(<span class="string">&quot;./random 15 56&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WAIT(2)</code></p><blockquote><p>进程结束后的资源回收问题 : 真正回收资源的系统调用</p><p>而由资源回收问题会引出–孤儿进程， 僵尸进程等概念</p><p>子进程资源一定由父进程回收，若是父进程在子进程终止前终止，此时的子进程是孤儿进程 <code>orphan</code>， 当子进程终止，父进程正忙，无法帮助子进程回收资源，或父进程一直没执行<code>wait</code>，此时子进程是僵尸进程</p><p>…….</p></blockquote><p><code>一堆多进程管理的概念........</code></p><h2 id="二、进程间通信-IPC-Inter-Process-Communication"><a href="#二、进程间通信-IPC-Inter-Process-Communication" class="headerlink" title="二、进程间通信 IPC:Inter Process Communication"></a>二、进程间通信 IPC:Inter Process Communication</h2><blockquote><p>分别从几种进程间通信机制总结，每个机制可能搭配几个相关函数或系统调用的手册信息和一个或几个小例程，分析一下各种机制的特点。</p></blockquote><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><blockquote><p>之前用过命令创建的有名管道, 也能在程序中创建管道。在<code>fork()</code>的基础上还能使用匿名管道。</p></blockquote><p><code>POPEN(3) PCLOSE(3)</code>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line">                         |</span><br><span class="line">                     底层实现是fork()+exec()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">用的不多，意义不大, fork+匿名管道pipe可能更常用一点</span><br></pre></td></tr></table></figure><p><code>PIPE(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line">                 |</span><br><span class="line">               传参时退化为指针，主要是提示去传入长度为<span class="number">2</span>的数组，这个数组会保存文件描述符返回，由此可操纵匿名管道</span><br><span class="line">The <span class="built_in">array</span> pipefd is used to <span class="keyword">return</span> two file descriptors referring to the ends of the pipe.</span><br><span class="line">pipefd[<span class="number">0</span>] refers to the read end of the pipe.  pipefd[<span class="number">1</span>] refers to the  write  end  of  the  pipe.</span><br><span class="line">Data  written  to  the  write  end of the pipe is buffered by the kernel until it is read from the read end of the pipe.     </span><br></pre></td></tr></table></figure><blockquote><p>配合<code>fork()</code>一起使用，<code>fork()</code>出的两个进程是共享文件对象的，而用户态资源又是全部拷贝的</p><p>这样父子进程分别拥有用于描述匿名管道读端，写端文件对象的文件描述符，各自关闭一端就能实现半双工通信，两根管道各自关闭一端就能实现全双工通信。(显然，这样的特性是依赖与fork()实现的)</p></blockquote><p><code>示例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让父进程打开文件file1，读取其内容，通过管道发送给子进程，而子进程将内容写入到文件file2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./pipe2 file1 file2</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> fds1[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> fds2[<span class="number">2</span>];</span><br><span class="line">    pipe(fds1);</span><br><span class="line">    pipe(fds2);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程 父读子写 关闭父的写子的读</span></span><br><span class="line">        close(fds1[<span class="number">1</span>]);</span><br><span class="line">        close(fds2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> fd2 = open(argv[<span class="number">2</span>], O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(read(fds1[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// puts(buf);</span></span><br><span class="line">            write(fd2, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// read(fds1[0], buf, sizeof(buf));</span></span><br><span class="line">        <span class="comment">// puts(buf);</span></span><br><span class="line">        <span class="comment">// write(fds2[1], &quot;hello i am child&quot;, 17);</span></span><br><span class="line">        close(fd2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程 父写子读 关闭父的读 子的写</span></span><br><span class="line">        close(fds1[<span class="number">0</span>]);</span><br><span class="line">        close(fds2[<span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">int</span> fd1 = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(read(fd1, buf, <span class="keyword">sizeof</span>(buf)) != <span class="number">0</span>)&#123;</span><br><span class="line">            write(fds1[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write(fds1[1], &quot;i am parent\n&quot;, 13);   </span></span><br><span class="line">        <span class="comment">// char buf[1024];</span></span><br><span class="line">        <span class="comment">// read(fds2[0], buf, sizeof(buf));</span></span><br><span class="line">        <span class="comment">// puts(buf);</span></span><br><span class="line">        close(fds1[<span class="number">1</span>]);</span><br><span class="line">        close(fd1);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MIFIFO(3)   创建有名管道</p><p>UNLINK(2)  删除文件(删除的本质是:接触数据与文件系统的连接—数据不一定被销毁)</p><p>RENAME(2)  移动文件</p><p>LINK(2) 创建硬链接</p></blockquote><h3 id="2-共享内存"><a href="#2-共享内存" class="headerlink" title="2. 共享内存"></a>2. 共享内存</h3><blockquote><p>基于system V 版本的系统调用  $ipcs </p></blockquote><blockquote><p>使用步骤 </p><p>——&gt;通过文件使用<code>FTOK(3)</code>得到一个shmid（是个数字）或者自定义一个数字也可(此数字识别不同的IPC机制?同一个数字可能串号冲突?)</p><p>——&gt; <code>SHMGET(2)</code>生成共享内存</p><p>——&gt; <code>SHMAT(2)</code>将共享内存映射到虚拟地址空间(申请到的共享内存是物理内存，但想要使用它必须先映射) </p><p>——&gt; 之后类似malloc申请到的空间一样操作它即可  </p><p>——&gt; 分配在堆区 用<code>SHMDT(2)</code>释放 并用·<code>shmctl(shmid,IPC_RMID,NULL);</code>删除</p></blockquote><p><code>FTOK(3)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SHMGET(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SHMOP(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SHMOP(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SHMCTL(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p><code>示例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./fhm file</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(argv[<span class="number">1</span>], <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;Hou are you&quot;</span>);</span><br><span class="line">    <span class="comment">// puts(p);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//创建并写入</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./shm_r file1 用同一个文件创建的key相同</span></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(argv[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>); </span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">int</span> ret = shmdt(p);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;shmadt&quot;</span>);</span><br><span class="line">    <span class="comment">// while(1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两个独立进程同时对一个共享内存去访问修改，可能造成竞争条件的出现race condition 由此可以引出信号量作为互斥机制</p></blockquote><blockquote><p>竞争条件:并发的执行流对共享资源的访问会导致竞争条件(进程是默认隔离的，所以出现概率比较低)</p></blockquote><p><code>竞争条件举例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">父子进程各自对共享内存变量加一千万，结果不是两千万</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(IPC_PRIVATE, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmid&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//取4字节存整数</span></span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span> *)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            ++*p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            ++*p;</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./shm_fork </span><br><span class="line">*p = <span class="number">18630024</span></span><br></pre></td></tr></table></figure><h3 id="3-信号量-以二元信号量为主"><a href="#3-信号量-以二元信号量为主" class="headerlink" title="3. 信号量(以二元信号量为主)"></a>3. 信号量(以二元信号量为主)</h3><blockquote><p>由上例中引出的竞争条件，分析其原因，<code>++*p;</code>这条指令在汇编层与机器层是更细化的 大概能分作三步(读取值，计算值，写回值)，如果中途被打断，可能会使得计算(访存)时所用的(得到的)并非最新值</p><p>想要解决这种情况需要有一种机制使的这三步要么不做，要么一次做完。比如原子操作，比如信号量。</p></blockquote><blockquote><p>信号量是描述资源数量的整数 &lt;= 0 : 资源不可用   &gt; 0 : 资源可用</p><p>PV操作 P:测试并加锁，V:释放并解锁 PV之间访问临界资源(这部分代码叫”临界区”)</p></blockquote><blockquote><p>使用步骤 </p><p>——&gt; <code>SEMGET(2)</code>获取信号量</p><p>——&gt;用·<code>semctl(semid, 数组下标, 行为, ....);</code>操作信号， 一般先设初值<code>semctl(semid, 0, SETVAL, 1);</code></p><p>——&gt;定义PV操作</p><p>——&gt;在需要加锁的地方调用<code>SEMOP(2)</code></p></blockquote><p><code>SEMGET(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SEMCTL(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SEMOP(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nsops)</span></span>;</span><br></pre></td></tr></table></figure><p><code>使用示例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用二元信号量，让两个进程对同一个数各加1千万次之后，最终每次执行结果都是2千万，看一下需要耗时多长时间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//准备共享内存,四个字节存加的数</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="comment">//准备二元信号量</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;semctl&quot;</span>);</span><br><span class="line">    <span class="comment">//设置PV操作 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>; <span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="comment">//计算耗时，使用gettimeofday</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">begTime</span>, <span class="title">endTime</span>;</span></span><br><span class="line">    gettimeofday(&amp;begTime, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//完成准备工作，生成两个进程</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            ++*p;</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            ++*p;</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        gettimeofday(&amp;endTime, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total microseconds = %ld\n&quot;</span>, (endTime.tv_sec - begTime.tv_sec)*<span class="number">1000000</span> + endTime.tv_usec - begTime.tv_usec);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/test$ ./pv</span><br><span class="line">*p = <span class="number">20000000</span></span><br><span class="line">Total microseconds = <span class="number">32416265</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>题外话 : dekker算法 伪代码与实现; 计数信号量; ......</code></p><p><code>伪代码</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># dekker算法的基本思路</span><br><span class="line">    variables</span><br><span class="line">        wants_to_enter : array of 2 booleans</span><br><span class="line">        turn : integer</span><br><span class="line"></span><br><span class="line">    wants_to_enter[0] ← false</span><br><span class="line">    wants_to_enter[1] ← false</span><br><span class="line">    turn ← 0   // or 1</span><br><span class="line"># p0</span><br><span class="line">p0:</span><br><span class="line">   wants_to_enter[0] ← true</span><br><span class="line">   while wants_to_enter[1] &#123;</span><br><span class="line">      if turn ≠ 0 &#123;</span><br><span class="line">         wants_to_enter[0] ← false</span><br><span class="line">         while turn ≠ 0 &#123;</span><br><span class="line">           // busy wait</span><br><span class="line">         &#125;</span><br><span class="line">         wants_to_enter[0] ← true</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // critical section</span><br><span class="line">   ...</span><br><span class="line">   turn ← 1</span><br><span class="line">   wants_to_enter[0] ← false</span><br><span class="line">   // remainder section</span><br><span class="line"># p1</span><br><span class="line">p1:</span><br><span class="line">   wants_to_enter[1] ← true</span><br><span class="line">   while wants_to_enter[0] &#123;</span><br><span class="line">      if turn ≠ 1 &#123;</span><br><span class="line">         wants_to_enter[1] ← false</span><br><span class="line">         while turn ≠ 1 &#123;</span><br><span class="line">           // busy wait</span><br><span class="line">         &#125;</span><br><span class="line">         wants_to_enter[1] ← true</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // critical section</span><br><span class="line">   ...</span><br><span class="line">   turn ← 0</span><br><span class="line">   wants_to_enter[1] ← false</span><br><span class="line">   // remainder section</span><br></pre></td></tr></table></figure><p><code>dekker 实现+20000000</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(IPC_PRIVATE, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmid&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//算值</span></span><br><span class="line">    p[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">//wants_to_enter[0] false 两个标志</span></span><br><span class="line">    p[<span class="number">2</span>] = <span class="literal">false</span>; <span class="comment">//wants_to_enter[1]</span></span><br><span class="line">    p[<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">//turn轮转</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            <span class="comment">//p0</span></span><br><span class="line">            p[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//子进程的flag</span></span><br><span class="line">            <span class="keyword">while</span>(p[<span class="number">2</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">3</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">                    p[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">//1号标志false</span></span><br><span class="line">                    <span class="keyword">while</span>(p[<span class="number">3</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//busy wait</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    p[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++*p;</span><br><span class="line">            p[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">            p[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//p1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            p[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(p[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">3</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                    p[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">while</span>(p[<span class="number">3</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">            ++*p;</span><br><span class="line">            p[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            p[<span class="number">2</span>] = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);   </span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/test/day13/homework$ make</span><br><span class="line">gcc  dekker.c -o dekker -g -O0</span><br><span class="line">scallacs@scallacs:~/test$ ./dekker  </span><br><span class="line">*p = <span class="number">20000000</span>  单核</span><br><span class="line">[ubuntu@VM<span class="number">-16</span><span class="number">-8</span>-ubuntu ~/linux/\ []$ ./dekker </span><br><span class="line">*p = <span class="number">19899008</span>  双核 会受到核心数影响，单核时表现完美</span><br></pre></td></tr></table></figure><p><code>计数信号量 + 生产者消费者问题</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1002</span>, <span class="number">2</span>,IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="comment">// unsigned short  *array;  /* Array for GETALL, SETALL */ 要使用SETALL初始化</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> arr[] = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;; <span class="comment">//arr[0]&lt;-&gt;商品  arr[1]&lt;-&gt;货仓 初始货仓摆满商品</span></span><br><span class="line">    <span class="keyword">int</span> ret = semctl(semid, <span class="number">0</span>, SETALL, arr);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;semctl setall&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出看看是否初始化成功，增量编程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sem[0] = %d, sem[1] = %d\n&quot;</span>, semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">    <span class="comment">// 设置信号量做PV操作, 先设定操作的行为,针对两种资源使用信号量集合</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">produce</span>[2];</span><span class="comment">//produce[0]:商品 produce[1]:货仓?</span></span><br><span class="line">    produce[<span class="number">0</span>].sem_num = <span class="number">0</span>;</span><br><span class="line">    produce[<span class="number">0</span>].sem_op = <span class="number">1</span>; <span class="comment">//商品+1</span></span><br><span class="line">    produce[<span class="number">0</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    produce[<span class="number">1</span>].sem_num = <span class="number">1</span>;</span><br><span class="line">    produce[<span class="number">1</span>].sem_op = <span class="number">-1</span>;</span><br><span class="line">    produce[<span class="number">1</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">consume</span>[2];</span><span class="comment">//consume[0]:商品 consume[1]:货仓</span></span><br><span class="line">    consume[<span class="number">0</span>].sem_num = <span class="number">0</span>;</span><br><span class="line">    consume[<span class="number">0</span>].sem_op = <span class="number">-1</span>; <span class="comment">//商品-1</span></span><br><span class="line">    consume[<span class="number">0</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    consume[<span class="number">1</span>].sem_num = <span class="number">1</span>;</span><br><span class="line">    consume[<span class="number">1</span>].sem_op = <span class="number">1</span>;</span><br><span class="line">    consume[<span class="number">1</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="comment">// 启动父子进程分别作为生产者和消费者</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// sleep(1);//如果交换睡眠时间会一直显示&#123;5, 0&#125;消费太慢</span></span><br><span class="line">            usleep(<span class="number">500000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am consumer, before consume, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">            <span class="comment">// semop(semid,consume,2);//这个操作会影响到2个资源 </span></span><br><span class="line">            semop(semid, &amp;consume[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consumer buy a product\n&quot;</span>);</span><br><span class="line">            semop(semid, &amp;consume[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am consumer, after consume, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// usleep(500000);</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am producer, before produce, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">            <span class="comment">// semop(semid,produce,2);//这个操作会影响到2个资源 </span></span><br><span class="line">            semop(semid, &amp;produce[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;produce a product\n&quot;</span>);</span><br><span class="line">            semop(semid, &amp;produce[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am producer, after produce, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./produceAndConsume </span><br><span class="line">sem[<span class="number">0</span>] = <span class="number">5</span>, sem[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am producer, before produce, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">produce a product</span><br><span class="line">i am producer, after produce, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">i am producer, before produce, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">produce a product</span><br><span class="line">i am producer, after produce, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">2</span>, space = <span class="number">3</span></span><br><span class="line">i am producer, before produce, product = <span class="number">2</span>, space = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4.消息队列"></a>4.消息队列</h3><blockquote><p>这里使用的是狭义的消息队列(广义的消息队列:网络消息中间件)， 这里的是面向消息的进程间通信机制</p><p>使用流程与前二者类似</p><p>——&gt; <code>MSGGET(2)</code>获取消息队列</p><p>——&gt; <code>MSGSND(2)</code> 发</p><p>——&gt; <code>MSGRCV(2)</code> 收</p><p>后面综合使用时演示</p></blockquote><p><code>MSGGET(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>MSGSND(2)</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><p> <code>MSGRCV(2)</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="5-信号"><a href="#5-信号" class="headerlink" title="5. 信号"></a>5. 信号</h3><blockquote><p>进程间异步通信机制(软件层面的，异步:不知道什么时候有信号来;管道是同步的:先写再读)</p><p>信号分为产生 递送(对某个进程施加影响(处理信号))两个阶段</p><p><code>kill -l </code>列出所有信号 共有64个 每种信号对应一个整数</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">递送信号发生了什么(递送信号的默认行为)(收到信号的默认行为:是可以通过注册信号改变这些行为的)</span><br><span class="line">Each signal has a current disposition, <span class="built_in">which</span> determines how the process behaves when it is delivered the signal.</span><br><span class="line"></span><br><span class="line">The entries <span class="keyword">in</span> the <span class="string">&quot;Action&quot;</span> column of the table below specify the default disposition <span class="keyword">for</span> each signal, as follows:</span><br><span class="line">      Term   Default action is to terminate the process.  终止进程 Ctrl C</span><br><span class="line">      Ign    Default action is to ignore the signal. 忽略信号<span class="built_in">wait</span>()的实现原理 SIGCHILD 告知父进程可以回收</span><br><span class="line">      Core   Default action is to terminate the process and dump core (see core(5)). 终止生成并core文件 Ctrl \ </span><br><span class="line">      Stop   Default action is to stop the process. 暂停 Ctrl Z</span><br><span class="line">      Cont   Default action is to <span class="built_in">continue</span> the process <span class="keyword">if</span> it is currently stopped. 恢复<span class="built_in">bg</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>将递送信号时的默认行为改变为自己定义的行为<code>SIGNAL(2)</code>(更改递送信号时的默认行为:可以实现进程的有序退出)</p><p>递送信号的本质 是 修改被递送信号的进程的task_struct （[注]9号信号的默认行为不能改）</p></blockquote><blockquote><p>执行流程如下图所示，在进程执行过程中受到信号，CPU的使用权移交给信号产生者，它会要求进程调用预定义的回调函数handler()，将这个信号的默认行为使用handler()定义的行为取代，函数接口如下</p></blockquote><p><code>SIGNAL(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line">                                              |-&gt;注册一个handler</span><br><span class="line">把系统信号的递送行为改为自己注册的行为</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.png" alt="回调函数的执行"></p><blockquote><p>如果有多个信号同时递送，会发现这么一种现象，有的递送行为没有执行，分析会发现，相同信号的递送会有如下现象</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BF%A1%E5%8F%B7%E9%80%92%E9%80%81.png" alt="信号递送"></p><blockquote><p>Q:那么为什么 多余的信号会被丢弃</p><p>A:这涉及两个结构体 <code>mask </code> <code>掩码，表示是否阻塞 pending   </code>未决信号集，表示是否有未决信号 它们都是位图实现的</p><p>所以在递送X信号时，会将mask的X置为1(递送结束恢复为0)(信号递送过程中把自己阻塞:把自己加入mask)—-&gt;当新信号产生，若这个信号也是X，查询mask发现其中有自己，那就把自己加入pending(对应位置1)—–&gt;再有一个X产生，同样的流程，但因为底层实现是位图pending只能保存一个，所以它被丢弃。</p><p>类似的，如果第三个信号是个新的，且mask中没它，就会转而执行新信号的递送…….</p></blockquote><blockquote><p>signal系统调用也存在一些缺陷，它的很多特性是写死的，比如递送X信号时会将X加入mask因此还有更好用的系统调用</p></blockquote><p><code>SIGACTION(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure><p><code>用法示例</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;<span class="comment">//指定不把自己加入mask,可反复切换，没使用SIGINFO指定为单参数版本的handler</span></span><br><span class="line">    act.sa_handler = handler; <span class="comment">//指定回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用sigaction注册信号 注册2号3号信号执行handler以来回打断</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGQUIT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./sigaction </span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">Killed</span><br></pre></td></tr></table></figure><blockquote><p>后续，这些进程间通信机制都用的比较少，有更好的实现方案</p><p>用网络取代管道，用线程取代共享内存，用互斥锁取代信号量(当然，信号是比较独特的进程间通信机制，用到时再复盘)</p></blockquote><h3 id="6-综合应用：实现一个四窗口聊天"><a href="#6-综合应用：实现一个四窗口聊天" class="headerlink" title="6. 综合应用：实现一个四窗口聊天"></a>6. 综合应用：实现一个四窗口聊天</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通信方式：</span><br><span class="line">- 4个进程，A进程和B进程负责通信，从标准输入读到的字符串通过管道发给对方，A1和B1进程负责显示。</span><br><span class="line">- A进程从标准输入读到的字符串发给B进程后，放到共享内存里，从管道中读到的字符串也放到共享内存里，A1进程到共享内存中拿到字符串，打印到屏幕上。</span><br><span class="line">- B进程从标准输入读到的字符串发给B进程，同时通过消息队列发给B1进程，B1进程从消息队列中读出消息，打印到屏幕上。</span><br><span class="line">退出方式：</span><br><span class="line">- 第一种：可以通过ctrl+C退出，任意一个进程收到CTRL+C时，给所有进程（包括自己）发送10号信号，每个进程收到10号信号后，开始执行有序退出。</span><br><span class="line">- 第二种：通过kill命令给4个进程中的任何一个进程发送10号信号，收到信号的进程再给其他3个进程发送10号信号。每个进程在自己的信号处理函数中执行有序退出。</span><br><span class="line">有序退出的工作内容：</span><br><span class="line">- 有序退出要做的主要有：关闭管道，解除对共享内存的映射，删除共享内存，删除信号量，删除消息队列。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  注意：A和A1进程都要访问共享内存，需要同信号量完成同步，所以退出时要也删除信号量。</span><br><span class="line">  提示：A1进程和B1进程需要知道每条消息是对方发来的消息还是发给对方的消息，用消息队列的一方可以通过mtype的值来标识，</span><br><span class="line">       用共享内存的进程可以自己定义一个类似 msgbuf的结构体，然后结构体中也用一个类似mtype的成员来标记。</span><br></pre></td></tr></table></figure><p><code>a.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">2048</span>];</span><br><span class="line">&#125;<span class="keyword">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pa, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid 输出看看是否正常收到</span></span><br><span class="line">    <span class="comment">// 程序启动，先获取四个进程的PID存入全局变量输出一下(通信时用不到，但退出时有用)</span></span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">0</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ******************************************************</span></span><br><span class="line">    <span class="comment">// 通信，a2b管道通信</span></span><br><span class="line">    <span class="comment">// int ret_ab = mkfifo(&quot;a2b&quot;, 0666);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_ab, -1, &quot;mkfifo&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信 a2a1 by 共享内存+信号量 ?共享内存中怎么设置msgbuf结构体? 类似malloc</span></span><br><span class="line">    <span class="comment">// 为什么要用信号量：写的时候不允许读 先做共享内存读写再做信号量</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">msg_t</span> *p = (<span class="keyword">msg_t</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信号量完成同步(不用的话a1显示时有时候会阻塞住?)</span></span><br><span class="line">    <span class="comment">//(Q:stdin的消息较少阻塞，pipe的消息很容易?)确实是同步问题，加锁解决</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret_sem = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem, <span class="number">-1</span>, <span class="string">&quot;semctl setval&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>;<span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开a2b的写端，b2a的读端 完成后输出</span></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;a2b&quot;</span>, O_WRONLY);</span><br><span class="line">    ERROR_CHECK(fdw, <span class="number">-1</span>, <span class="string">&quot;open pipe a2b\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;b2a&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fdr, <span class="number">-1</span>, <span class="string">&quot;open pipe b2a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;chat established!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//IO多路复用</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);<span class="comment">//设置监听集合</span></span><br><span class="line">        <span class="keyword">int</span> ret_slt = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from process b\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdb = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdb == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// puts(buf);//后面改成在进程a1上显示</span></span><br><span class="line">            <span class="comment">// 从管道读来自b的消息 重定向到a1进程去显示 来自管道的消息定为2</span></span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            p-&gt;mtype = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;mtext, buf);</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from stdin.\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdin = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdin == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fdw, buf, ret_rdin);<span class="comment">//除开给管道发送一份之外还要写给a1显示进程一份</span></span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            p-&gt;mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;mtext, buf);</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    shmdt(p);</span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>a1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">2048</span>];</span><br><span class="line">&#125;<span class="keyword">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">1</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *************************************************</span></span><br><span class="line">    <span class="comment">// 读取共享内存中的消息</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">msg_t</span> *p = (<span class="keyword">msg_t</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信号量完成同步</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret_sem = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem, <span class="number">-1</span>, <span class="string">&quot;semctl setval&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>;<span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mtype == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg from process b:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg type = %d, msg = %s\n&quot;</span>, p-&gt;mtype, p-&gt;mtext);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mtype == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg from stdin:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg type = %d, msg = %s\n&quot;</span>, p-&gt;mtype, p-&gt;mtext);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Q : 怎么做到读出一条消息后阻塞? 清空一下阻塞住了但是 有时候接不到下条消息?等会加锁试试</span></span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line">        semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int ret_shmdt = shmdt(p);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_shmdt, -1, &quot;shmdt&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> ret_sem_rm = semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem_rm, <span class="number">-1</span>, <span class="string">&quot;semctl IPC_RMID&quot;</span>);</span><br><span class="line">    shmdt(p);   <span class="comment">//有一片共享内存(a2a1通信用的那片)和信号量没有正确退出，其他的正常</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>b.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">2</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *********************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信，b2b1(b1为显示端) 使用消息队列，要做的事情:b把从管道读端,键盘输入读到的数据重定向到b1,区分消息类型 by 消息队列</span></span><br><span class="line">    <span class="comment">// 消息对列发端</span></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">bufin</span>, <span class="title">bufpipe</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信，a2b管道通信</span></span><br><span class="line">    <span class="comment">// int ret_ba = mkfifo(&quot;b2a&quot;, 0666);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_ba, -1, &quot;mkfifo&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开b2a的写端，a2b的读端 完成后输出</span></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;a2b&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fdr, <span class="number">-1</span>, <span class="string">&quot;open pipe b2a\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;b2a&quot;</span>, O_WRONLY);</span><br><span class="line">    ERROR_CHECK(fdw, <span class="number">-1</span>, <span class="string">&quot;open pipe a2b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;chat established!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        <span class="keyword">int</span> ret_slt = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from process a\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rda = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rda == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// puts(buf);//管道读端读到的原本直接输出，现在重定向到b1进程 by message queue;</span></span><br><span class="line">            </span><br><span class="line">            bufpipe.mtype = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(bufpipe.mtext, buf);</span><br><span class="line">            <span class="keyword">int</span> ret_msgque_pipe = msgsnd(msgid, &amp;bufpipe, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret_msgque_pipe, <span class="number">-1</span>, <span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from stdin.\n&quot;);//隐藏掉这些信息进程b就只管输入了,显示全在b1</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdin = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdin == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fdw, buf, ret_rdin);<span class="comment">//后面改成在进程a1上显示</span></span><br><span class="line">            <span class="comment">// 键盘输入还要再在b1上显示一次</span></span><br><span class="line">            bufin.mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(bufin.mtext, buf);</span><br><span class="line">            <span class="keyword">int</span> ret_msgque_in = msgsnd(msgid, &amp;bufin, <span class="keyword">sizeof</span>(bufin), <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret_msgque_in, <span class="number">-1</span>, <span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>b1.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">3</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *********************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// msgrcv</span></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">bufin</span>, <span class="title">bufpipe</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin)); <span class="comment">//两种消息有时候会阻塞?</span></span><br><span class="line">        <span class="keyword">int</span> ret_msgrcv_in = msgrcv(msgid, &amp;bufin, <span class="keyword">sizeof</span>(bufin), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//1, IPC_NOWAIT  改填0不限制消息类型直接取出</span></span><br><span class="line">        ERROR_CHECK(ret_msgrcv_in, <span class="number">-1</span>, <span class="string">&quot;msgrcv_in&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgrcv form stdin:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type = %ld, msg = %s\n&quot;</span>, bufin.mtype, bufin.mtext);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));       <span class="comment">//注意这个限制消息队列长度的参数：msgrcv: Argument list too long</span></span><br><span class="line">        <span class="keyword">int</span> ret_msgrcv_pipe = msgrcv(msgid, &amp;bufpipe, <span class="keyword">sizeof</span>(bufpipe), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//2, IPC_NOWAIT</span></span><br><span class="line">        ERROR_CHECK(ret_msgrcv_pipe, <span class="number">-1</span>, <span class="string">&quot;msgrcv_pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgrcv from pipe:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type = %ld, msg = %s\n&quot;</span>, bufpipe.mtype, bufpipe.mtext);</span><br><span class="line">        <span class="comment">//这样会循环取出，几乎一瞬间取完然后进程终止(怎么阻塞它)？不加IPC_NOWAIT 即可</span></span><br><span class="line">        <span class="comment">//目前对b1用Ctrl+C 不会影响a, b进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Unix/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix/Linux-file-management</title>
      <link href="/2022/02/26/6.Unix-Linux-file-management/"/>
      <url>/2022/02/26/6.Unix-Linux-file-management/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-一点历史"><a href="#0-一点历史" class="headerlink" title="0 .一点历史"></a>0 .一点历史</h3><blockquote><p>还是从一点历史引入，感觉了解一些历史缘由，会更好地理解采用某种特定实现技术的原因</p><p>看了一点《The art of Unix Programming》 序中有一句话挺吸引我</p><p><em>Unix is not so much an operating system as an oral history.  —-Neal Stephenson</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-&gt;(早期)批处理OS</span><br><span class="line">-&gt;(1960)MIT分时OS:多终端+大型机</span><br><span class="line">-&gt;(1965)AT&amp;T:Bell+MIT+GE(通用电气):Multics计划(全面通用分时OS:bye)</span><br><span class="line">-&gt;(1969)Bell认为该计划GG,退出 (不算失败，有些成果) ：Ken Thompson 写了 Space Travle, PDP-7小型机移植，对它重写OS内核并移植 称Unics</span><br><span class="line">-&gt;Unics(核心哲学:一切皆文件, 程序的目的只有一个-有效的完成目标 : 与Multics理念不同《The Art of Unix Programming》)</span><br><span class="line">-&gt;(1969)Linus Torvalds 在芬兰诞生</span><br><span class="line">-&gt;尝试用高级语言解决移植问题BCPL, PASCAL-&gt;编译出的内核性能不够好-&gt;根据BCPL发明C</span><br><span class="line">-&gt;(1973)Deneish Richie(C的主要发明者)用C重写了Unics系统(提供了管道等重要功能),更名为Unix</span><br><span class="line">-&gt;(1977)AT&amp;T将Unix源代码(用C写的,高可移植性)发给学术界-&gt;UC Berkeley-&gt;Bill Joy professor 编译成适合自己机器的系统，增减一些功能:命名为BSD(Berkeley Software Distribution)</span><br><span class="line">-&gt;(1979)AT&amp;T:推出System V(five(Sun - Solaris)):第七版(不再开源:商业纠纷开始):特性:可以支持x86架构的个人计算机</span><br><span class="line">-&gt;(1984)不再开源对教授OS的professor产生了影响:Andrew TannenBaum-&gt;自己写个Mini Unix -&gt; Minix</span><br><span class="line">-&gt;(1986)完成Minix, 并出版《Operating System : Design and Implementation》附带Minix的源代码</span><br><span class="line">        《Modern Operating System》也是他写的</span><br><span class="line">-&gt;同期 Richard Stallman 发起了GNU计划:GNU:Gnu is not Unix!(GCC, Emacs, Bash Shell, GDB...)目标创建一套完全自由的Unix OS(当时的Unix与硬件捆绑销售)但是缺少Unix内核</span><br><span class="line">-&gt;草拟 GPL协议(General Publilc License | 🙂 copyleft &lt;!-&gt; copyright:著作权) 开源 != 免费(维护可以收费)</span><br><span class="line">-&gt;(1988)IEEE:POSIX标准(旨在:保证各个OS间的兼容性) (IEEE-IX-&gt;POSIX:Portable Operating System Interface X:(Unix))可移植...</span><br><span class="line">-&gt;(1993)Linus:宏内核构造的Linux内核面世</span><br></pre></td></tr></table></figure><h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><blockquote><p>感觉之前学过很多次，并且每次学习也有用纸质或者文档记录，博客记录学到，使用过的命令，但大多情况学过不用就忘了，不是长久之计，这次就不记录这些。尽量多用以熟练。同时，本文的侧重点不在使用这方面，想要更深入的学习一些东西。</p></blockquote><blockquote><p>如果有不会的熟练使用 <code>$man</code></p><p>一点准备工作，环境使用的Ubuntu18.04 帮助手册不全<code>sudo apt install manpages-posix-dev</code></p></blockquote><h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3><blockquote><p>这是一张来自《Advanced Programing in the UNIX Environment》的图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/imgUnix%E6%9E%B6%E6%9E%84.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Kernel：OS内核：管理硬件资源，给上层程序提供运行环境(所以有很多驱动，提供很多接口，服务)</span><br><span class="line">System calls：系统调用：内核给上层程序提供的接口(有些繁琐复杂，做些封装-&gt;系统库)程序由系统调用使用内核提供的功能</span><br><span class="line">Library routines:库函数 (printf, scanf:对系统调用做一次封装)上层程序不能直接与硬件交互，需调用底层接口(对System calls封装)</span><br><span class="line">Shell：命令行解释器(bash:Bourne-again shell:/bin/bash):命令，脚本(命令的集合)， 访问内核资源</span><br><span class="line">Applications:应用程序:可以直接使用系统调用调用内核功能，也能使用系统库提供内核功能</span><br></pre></td></tr></table></figure><blockquote><p>在学习C的过程中，用到过不少库函数，按照这幅图从 库函数-&gt;System call-&gt;Kernel 由外层到里层深入的学习确实是此前没有接触过的全新思路，当然，任务也很艰巨《APUE》《内核源码》都是大部头，希望后面有毅力能啃完吧 : )</p></blockquote><blockquote><p>接下来按照OS的功能划分，以文件管理,进程管理,内存管理,IO管理 来分块学习。</p></blockquote><h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><blockquote><p>关于一切皆文件这个理念</p><p>对于这个Unix设计哲学，之前是知道这个名词，但是要具体来说可能说不出什么，结合一些文件操作来理解可能更为清晰。(图画的丑: ))在程序的运行过程中，计算机是怎样去操作磁盘上的文件的? 在一个程序运行时，由CPU去代码段取一条条指令，并将指令执行生成的数据放入堆栈等数据区。那么指令的操作数在哪？在内存上，内存的数据是从磁盘上取出的，最终也会持久化的存储在磁盘上。从中取，往回存这两个操作是怎么做到的，把磁盘看做程序运行时的外部设备，它在内存上建立了映射区—称作文件缓冲区。文件缓冲区在内存上，但是影响外部设备。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/img%E6%96%87%E4%BB%B6_%E6%93%8D%E4%BD%9C.jpg"></p><blockquote><p>以此类推，目录文件，设备文件，管道文件等等，理念是一致的，对于众多的文件类型使用通用的方式去操作它们。文件操作操作的是内存上的数据，影响的是外部设备。对于Linux而言存在内核态与用户态，当文件操作涉及外部硬件时，用户态将这些操作委托给内核态去完成，这就离不开系统调用。</p><p>理解了这一点，就可以通过学习文件操作更深入的理解(操作文件会影响外部硬件，这个函数就不是普通的函数而是系统调用)。使用库函数和系统调用来操作文件，从库函数–&gt;系统调用。</p><p>基于文件指针的文件操作函数(ANSI 标准库函数) –&gt; 基于系统调用的文件操作</p></blockquote><h4 id="3-1-文件操作-基于-库函数-文件指针FILE"><a href="#3-1-文件操作-基于-库函数-文件指针FILE" class="headerlink" title="3.1 文件操作 - 基于(库函数)文件指针FILE*"></a>3.1 文件操作 - 基于(库函数)文件指针FILE*</h4><blockquote><p>从普通文件的打开与操作开始</p></blockquote><p><code>流</code>：表示任意输入<code>src</code>, 任意输出<code>dst</code> ，屏蔽硬件设备之间的差异，使得C像读写文件一样读写任意设备。</p><blockquote><p>内存与硬件设备存在读写性能上的鸿沟，OS在内存上为<code>流</code>设置缓冲区，C通过文件指针<code>FILE*</code>实现对流的访问, 启动任意进程OS将打开三个标准流<code>stdin</code> , <code>stdout</code>,  <code>stderr</code>.它们都默认与硬件关联。</p></blockquote><p>从普通文件操作开始, 读写之前先打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">返回值是指针:暗含的意思-&gt;返回值指针指向必定不在被调函数栈帧(而在用户态某个空间，需用户自行释放)</span><br><span class="line">返回文件指针访问流</span><br><span class="line">|</span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* mode)</span></span>;</span><br><span class="line">                                                |</span><br><span class="line">                                            打开模式(考虑后续操作)</span><br><span class="line">                                            <span class="string">&quot;r&quot;</span> :只读打开</span><br><span class="line">                                            <span class="string">&quot;r+&quot;</span>:读写打开 文件必须存在</span><br><span class="line">                                            <span class="string">&quot;w&quot;</span> :只写创建 文件不需要存在</span><br><span class="line">                                            <span class="string">&quot;w+&quot;</span>:读写创建 文件存在就清空</span><br><span class="line">                                            <span class="string">&quot;a+&quot;</span>:读写追加 在原有数据后写入新值</span><br><span class="line">                                                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* stream)</span></span>;                                                    </span><br></pre></td></tr></table></figure><blockquote><p>文件不再使用要关闭，这涉及一点更底层的系统调用<code>open</code>相关，之后会谈到<code>fopen</code>与<code>open</code>的联系。<br>简单来讲OS使用文件描述符来打开文件资源，<code>fopen</code>返回的文件指针FILE*实际指向的即是这些文件描述符。<br>不使用<code>fclose</code>释放这些文件描述符的话，需要进程结束时由OS去回收它们。<br>如果在一个程序中持续打开文件又不关闭，文件描述符是可能被用完的。再涉及一点后面的知识，使<code>fopen</code>时一般与库函数<code>fwrite</code>等搭配使用而<strong>库函数</strong>与后面的<code>write</code>这样的<strong>系统调用</strong>是不一样的，它不会直接将数据写入磁盘，而是有缓冲区的，当达到一定条件(比如缓冲区满)才会将数据写入磁盘。所以如果程序正常退出，缓冲中的数据会安全写入磁盘，但如果异常退出缓冲中的数据可能丢失。所以使用<code>fclose</code>能确保数据安全。</p></blockquote><p>文件读写操作 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">处理字符串</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">                                        |</span><br><span class="line">           (序列化|反序列化)做格式化输入输出到目标文件，有时候用fwrite二进制处理更方便</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br><span class="line">                                   |</span><br><span class="line">                               把这些流参数写成<span class="built_in">stdin</span>,<span class="built_in">stdout</span> 就是<span class="built_in">puts</span>,gets等库函数</span><br><span class="line">                                        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line">    </span><br><span class="line">处理二进制</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>处理文件的函数的基本读写操作 - 基于文件指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">&#125;<span class="keyword">student_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./fopen file file2</span></span><br><span class="line">    <span class="comment">//注意这几段测试代码不能混用，让文件流指针走到文件末尾了?</span></span><br><span class="line">    <span class="comment">/*******************fgetc fputc************************/</span></span><br><span class="line">    <span class="keyword">int</span> retc = fgetc(fp);<span class="comment">//读一个字符成功返回字符，失败返回EOF(-1)</span></span><br><span class="line">    ERROR_CHECK(retc, <span class="number">-1</span>, <span class="string">&quot;fgetc read EOF&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,retc);</span><br><span class="line">    <span class="keyword">int</span> retpc = fputc(<span class="string">&#x27;p&#x27;</span>,fp);</span><br><span class="line">    ERROR_CHECK(retpc, <span class="number">-1</span>, <span class="string">&quot;fputc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************fgets fputs************************/</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">1024</span>, fp) != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        <span class="built_in">fputs</span>(buf, dst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******************fscanf fprintf************************/</span></span><br><span class="line">    <span class="keyword">student_t</span> stu[<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="number">60.1</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>, <span class="number">88.88</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">3</span>, <span class="string">&quot;laowang&quot;</span>, <span class="number">99.87</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;\n%d-%s-%.2lf&quot;</span>, stu[i].id, stu[i].name, stu[i].score);</span><br><span class="line">        <span class="comment">//格式化输入到文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******************fread fwrite************************/</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2048</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(n = fread(buf, <span class="number">1</span>, <span class="keyword">sizeof</span>(buf), fp) != <span class="number">0</span>)&#123;</span><br><span class="line">        fwrite(buf, <span class="number">1</span>, <span class="built_in">strlen</span>(buf), dst);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(dst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件定位操作</p><blockquote><p>对于流这个概念有个很重要的性质—流有它关联的位置指针，在进行读写操作时，文件位置指针会自动推进，以顺序访问文件。</p><p>但是也有手段去改变这个文件位置指针的指向，如以下几个库函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                              SEEK_SET, SEEK_CUR, SEEK_END</span><br><span class="line">                                         参照点</span><br><span class="line">                                           |</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;  &lt;=&gt; fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br></pre></td></tr></table></figure><p>关于<code>fopen</code>与<code>open</code>的底层联系,见3.3</p><blockquote><p> [补充]：</p><p> 对于之前程序中经常会用到的两种操作，抽取成两个带参宏：</p><ul><li>1.参数个数检查：</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARGS_CHECK(argc, num) </span></span><br><span class="line">&#123;<span class="keyword">if</span>(argc != num)&#123;<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;args error!\n&quot;</span>);<span class="keyword">return</span> <span class="number">-1</span>;&#125;&#125; </span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>2.函数运行错误检查</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_CHECK(ret, num, msg) &#123;<span class="meta-keyword">if</span>(ret == num) &#123;perror(msg);return -1;&#125;&#125;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p> 关于文本格式文件与二进制格式文件的使用，熟悉使用二进制格式文件，节省空间，转换效率高，怎么写就怎么读</p></blockquote><blockquote><p>关于参考手册的查询 <code>&gt;$ man xxx</code>重点关注函数原型，返回值</p></blockquote><blockquote><p>创建文件由于掩码<code>umask : 0002</code>的影响 取反按位与 其它用户没有写权限 </p></blockquote><blockquote><p><code>puts(str); == printf(&quot;%s\n&quot;,str);</code>   <code>scanf</code> 从非空白读到空白  <code>gets</code> 从开始读到换行</p></blockquote><h4 id="3-2-目录操作"><a href="#3-2-目录操作" class="headerlink" title="3.2 目录操作"></a>3.2 目录操作</h4><blockquote><p>先学习一些库函数和系统调用，然后组合使用他们实现一些系统命令。</p></blockquote><p>CHMOD(2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>GETCWD(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">                    |</span><br><span class="line">                  将当前工作目录的绝对路径复制到buf所指空间，buf不够大可能报错,在栈上</span><br><span class="line">                                               </span><br><span class="line">getcwd(<span class="literal">NULL</span>, <span class="number">0</span>); 另一种用法，返回当前工作目录</span><br><span class="line">buf为<span class="literal">NULL</span>，依照size大小自动分配，而size也为<span class="number">0</span>，则根据绝对路径字符串长在**堆**上分配，需自行<span class="built_in">free</span>     </span><br></pre></td></tr></table></figure><p>CHDIR(2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure><p>MKDIR(2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>RMDIR(2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><em>关于文件系统(OS中负责管理持久数据的子系统)，基本单位是文件，对文件的组织方式不同就会生成不同的文件系统，对于任意文件，快速定位到它的位置是首要的需求。所以在文件系统的设计之初就需要利用专门的索引结构来管理所有文件。索引结构的基本单位是*<em>索引节点</em></em>(具有固定大小，其中存放单个文件的位置，文件类型，权限，修改时间等信息。是文件的唯一标识，会占据磁盘空间)文件系统利用数组组织这些索引节点并用一个辅助的位图实现高效的管理文件信息。*</p></blockquote><blockquote><p>按照一切皆文件的设计理念，目录也是文件。类比文件操作的文件指针与文件流，目录也有对应的目录流结构以及相应的位置指针</p><p>目录的存储原理</p><p>Linux 会为每个文件分配两个数据结构 索引节点(index node)目录项(directory entry) 分别记录文件的元信息和目录层次结构。<strong>目录项</strong>会记录文件名，索引节点指针，与其他节点的层级关联关系等。多个目录项关联起来形成目录结构。目录项由内核维护，不存放在磁盘，缓存在内存。注意<strong>索引节点</strong>才是唯一标识。扯远了，这一块其实理的不是很清楚，后面再看看。</p></blockquote><blockquote><p>总之，目录作为特殊的文件，简单来讲会把其下的所有目录项(孩子)组织成链表结构，当需要访问这个目录时，需要将其映射到内存中，这就变成了目录流结构如下图所示。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/目录结构.jpg" alt="目录流" style="zoom: 80%;" /><blockquote><p>链表节点为dirent(directory entry)定义如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ man <span class="number">3</span> readdir</span><br><span class="line">In the glibc implementation, the dirent structure is defined as follows:</span><br><span class="line">&lt;dirent.h&gt;</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">               <span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">               <span class="keyword">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span>  </span><br><span class="line">                                              访问下个dirent结点，实际是依赖于本结点中d_off属性</span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">               <span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* Type of file; not supported</span></span><br><span class="line"><span class="comment">                                              by all filesystem types */</span></span><br><span class="line">               <span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>对于的目录文件，提供了对应的库函数操作它们 从映射到内存(打开目录流)-&gt;提取目录项信息-&gt;-&gt;-&gt;</p></blockquote><p>OPENDIR(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>CLOSEDIR(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure><p>READDIR(3)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"> On success, readdir() returns a pointer  to  a  dirent  structure.   </span><br><span class="line">(This structure may be statically allocated; <span class="keyword">do</span> <span class="keyword">not</span> attempt to <span class="built_in">free</span>(<span class="number">3</span>) it.)</span><br><span class="line"> 这个函数返回以结构体类型为基类型的指针，但不需要主调申请内存(如此前在堆上<span class="built_in">malloc</span>的)特别的，此函数在数据段上申请内存。</span><br><span class="line">(与全局变量申请在一起)</span><br><span class="line">主调调用此函数，此函数readdir申请内存。主调创建一个指针即可。(不同库函数作者的口味不同)</span><br><span class="line">     </span><br><span class="line">用法：</span><br><span class="line">    truct dirent *pdirent;</span><br><span class="line">    <span class="keyword">while</span> ((pdirent = readdir(pdir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        do_something;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>几个定位，不太常用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dir)</span></span>;            <span class="comment">//重新定位到目录文件的头部 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dir,<span class="keyword">off_t</span> offset)</span></span>; <span class="comment">//用来设置目录流目前的读取位置 </span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">telldir</span><span class="params">(DIR *dir)</span></span>;             <span class="comment">//返回目录流当前的读取位置</span></span><br></pre></td></tr></table></figure><p>STAT(2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>有了以上的库函数与系统调用，可以做点有意思的事情，实现几个UNIX命令看看</p></blockquote><p><code>ls -l</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递任意一个目录路径，能够显示该目录的ls -l的效果。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">switch_mon</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="string">&quot;Mon&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="string">&quot;Feb&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="string">&quot;Mar&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="string">&quot;Apr&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="string">&quot;May&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">return</span> <span class="string">&quot;Jun&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">return</span> <span class="string">&quot;Jul&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">return</span> <span class="string">&quot;Aug&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: <span class="keyword">return</span> <span class="string">&quot;Sep&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>: <span class="keyword">return</span> <span class="string">&quot;Oct&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">return</span> <span class="string">&quot;Nov&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>: <span class="keyword">return</span> <span class="string">&quot;Dec&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//OJ做法，不用switch-case 直接定义一个数组即可</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * month[<span class="number">12</span>] = &#123;<span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span>, <span class="string">&quot;Apr&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;Jun&quot;</span>, </span><br><span class="line">                            <span class="string">&quot;Jul&quot;</span>,<span class="string">&quot;Aug&quot;</span>, <span class="string">&quot;Sep&quot;</span>, <span class="string">&quot;Oct&quot;</span>, <span class="string">&quot;Nov&quot;</span>, <span class="string">&quot;Dec&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">switch_mode</span><span class="params">(<span class="keyword">mode_t</span> mode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">11</span>];<span class="comment">//字符串给点余量，其实申请大一点空间也可以</span></span><br><span class="line">    <span class="keyword">switch</span>(mode &amp; S_IFMT)&#123;<span class="comment">//取出高四位表示文件类型</span></span><br><span class="line">        <span class="keyword">case</span> S_IFBLK : str[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR : str[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR : str[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO : str[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK : str[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG : str[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK : str[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt; <span class="number">10</span> ; ++i, ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mode &amp; mask)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(i % <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: str[i] = <span class="string">&#x27;x&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: str[i] = <span class="string">&#x27;r&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: str[i] = <span class="string">&#x27;w&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str[i] = <span class="string">&#x27;-&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        mask /= <span class="number">2</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./ls_l path</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    DIR* pdir = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    ERROR_CHECK(pdir, <span class="literal">NULL</span>, <span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">    <span class="comment">//列出目标目录下的详细信息 先进到这个目录</span></span><br><span class="line">    <span class="keyword">int</span> ret = chdir(argv[<span class="number">1</span>]);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">    <span class="comment">//进到目标目录读, dirent的结构体信息不够丰富，使用stat函数,它有一个struct stat *statbuf的传入传出参数</span></span><br><span class="line">    <span class="comment">// 由主调准备它</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">pdirent</span>;</span></span><br><span class="line">    <span class="keyword">while</span>((pdirent = readdir(pdir)) != <span class="literal">NULL</span>)&#123;<span class="comment">//注意readdir的用法</span></span><br><span class="line">        <span class="keyword">int</span> ret = stat(pdirent-&gt;d_name, &amp;statbuf);<span class="comment">//只读dirent信息不够丰富，使用stat</span></span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="comment">// 按照ls -l命令的需求使用stat结构体的字段</span></span><br><span class="line">        switch_mode(statbuf.st_mode);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %ld %s %s %6ld %s %d %d:%d %s\n&quot;</span>,</span><br><span class="line">            <span class="comment">// statbuf.st_mode,</span></span><br><span class="line">            statbuf.st_nlink,</span><br><span class="line">            getpwuid(statbuf.st_uid)-&gt;pw_name,<span class="comment">//stat结构体中是id转换成字符串</span></span><br><span class="line">            getgrgid(statbuf.st_gid)-&gt;gr_name,</span><br><span class="line">            statbuf.st_size,</span><br><span class="line">            <span class="comment">// ctime(&amp;statbuf.st_mtime),</span></span><br><span class="line">            switch_mon(localtime(&amp;statbuf.st_mtime)-&gt;tm_mon), <span class="comment">//对获取的时间信息做点修改</span></span><br><span class="line">            localtime(&amp;statbuf.st_mtime)-&gt;tm_mday,</span><br><span class="line">            localtime(&amp;statbuf.st_mtime)-&gt;tm_hour,</span><br><span class="line">            localtime(&amp;statbuf.st_mtime)-&gt;tm_sec,</span><br><span class="line">            pdirent-&gt;d_name</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(pdir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tree</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现tree命令的效果。使用深度优先遍历递归实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给出路径与画结构的间隔宽度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFSerch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line">    DIR* pdir = opendir(path);</span><br><span class="line">    ERROR_CHECK(pdir, <span class="literal">NULL</span>, <span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">pdirent</span>;</span></span><br><span class="line">    <span class="keyword">char</span> newpath[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>((pdirent = readdir(pdir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//不必显示 . .. 注意字符串比较 其他的项先打印空格再打印名字</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pdirent-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(pdirent-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pdirent-&gt;d_name);</span><br><span class="line">        <span class="comment">//key 遇见子目录的情况，生成新路径递归</span></span><br><span class="line">        <span class="keyword">if</span>(pdirent-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(newpath, <span class="string">&quot;%s%s%s&quot;</span>, path, <span class="string">&quot;/&quot;</span>, pdirent-&gt;d_name);</span><br><span class="line">            DFSerch(newpath, width+<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./myTree .</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    DFSerch(argv[<span class="number">1</span>], <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-基于文件描述符操作文件-文件操作-基于系统调用-不带缓冲的文件IO"><a href="#3-3-基于文件描述符操作文件-文件操作-基于系统调用-不带缓冲的文件IO" class="headerlink" title="3.3 基于文件描述符操作文件 || 文件操作-基于系统调用(不带缓冲的文件IO)"></a>3.3 基于文件描述符操作文件 || 文件操作-基于系统调用(不带缓冲的文件IO)</h4><blockquote><p>所谓的不带缓冲，不带的是用户态文件缓冲区。如下图所示 注意也是内存中，只是相对在内核部分</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E4%B8%8D%E5%B8%A6%E7%BC%93%E5%86%B2IO.png" alt="不带缓冲的文件IO"></p><blockquote><p>使用文件本质是把磁盘与用户建立连接，但这件事情是OS做的，OS在内核态建立了文件对象，直接与硬件对应，如果要让用户直接通过指针去操作这些文件对象，显然是不合适的。这就引入了新的结构—索引数组，用户可以通过索引数组的下标:文件描述符去间接的找到真正的文件</p><p>即：进程空间的内核部分维护一个已打开文件的数组，管理所有已打开的文件，文件描述符是这个数组的索引(文件描述符：非负整数，是指针数组的下标，用于找到文件对象)。</p><p>其实日常所用的<code>stdin, stdout, stderr</code>就是最常见的文件对象 任意一个进程都默认打开这三个文件对象，他们的文件描述符即<code>0,1,2</code></p></blockquote><p><code>OPEN(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">//有两个版本，是用宏实现的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> the <span class="keyword">new</span> file descriptor, <span class="keyword">or</span> <span class="number">-1</span> <span class="keyword">if</span> an error occurred .</span><br><span class="line">从这里就能隐约看出一点不同，fopen执行成功返回的是一个文件指针，会在用户态有一块内存空间，先把数据拷贝去FILE结构体。FILE结构的本质是一块缓冲区。</span><br><span class="line">而open则不同，返回的是一个整数值——文件描述符，会通过它实现进程与打开文件间的交互。</span><br><span class="line">&gt;$ man open 可以看到一段open 与fopen对应关系的描述</span><br><span class="line">    </span><br><span class="line">The file descriptor associated with the stream is opened as <span class="keyword">if</span> by  a  call</span><br><span class="line">to open(<span class="number">2</span>) with the following flags:</span><br><span class="line"></span><br><span class="line">              ┌─────────────┬───────────────────────────────┐</span><br><span class="line">              │fopen() mode │ open() flags                  │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     r       │ O_RDONLY                      │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     w       │ O_WRONLY | O_CREAT | O_TRUNC  │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     a       │ O_WRONLY | O_CREAT | O_APPEND │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     r+      │ O_RDWR                        │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     w+      │ O_RDWR | O_CREAT | O_TRUNC    │</span><br><span class="line">              ├─────────────┼───────────────────────────────┤</span><br><span class="line">              │     a+      │ O_RDWR | O_CREAT | O_APPEND   │</span><br><span class="line">              └─────────────┴───────────────────────────────┘</span><br><span class="line">    </span><br><span class="line">[补]</span><br><span class="line"><span class="keyword">int</span> creat(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode); <span class="comment">//文件名 权限 </span></span><br><span class="line"><span class="comment">//creat现在已经不常用了，它等价于</span></span><br><span class="line">open(pathname,O_CREAT|O_TRUNC|O_WRONLY,mode);</span><br></pre></td></tr></table></figure><p><code>CLOSE(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">调用close，则该进程对文件所加的锁全都被释放，并且使文件的打开引用计数减<span class="number">1</span>，</span><br><span class="line">只有文件的打开引用计数变为<span class="number">0</span>以后，文件才会被真正的关闭。</span><br></pre></td></tr></table></figure><blockquote><p>使用read和write来读写文件，它们统称为不带缓冲的IO</p></blockquote><p><code>READ(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; <span class="comment">//出错返回-1， 读完返回0， 其他返回读写个数</span></span><br></pre></td></tr></table></figure><p><code>WRITE(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>只是这么看的话,对于不带缓冲IO的感觉挺迷的，想一想<code>read</code>和<code>fread</code>的区别, 使用<code>read</code>读CPU陷入内核态处理文件读取，频繁使用<code>read</code>读取少量数据则数据读取效率较低。而<code>fread</code>是有缓冲的,它在用户态有文件缓冲区，达到一定条件时才向文件对象中写。这个条件可能是缓冲区满了，也可能是读取结束。这就减少了系统调用的次数，可能缓冲满才进行一次状态切换。当然，代价是多进行了一次拷贝。如下方示意图；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2.png" alt="状态切换"></p><blockquote><p>接下来使用前面的知识实现一下<code>cp -r</code></p></blockquote><p><code>cp -r</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpdir</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *src, <span class="keyword">char</span> <span class="keyword">const</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpfile</span><span class="params">(<span class="keyword">char</span> *src, <span class="keyword">char</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./cp_r src dst</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    cpdir(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpdir</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *src, <span class="keyword">char</span> <span class="keyword">const</span> *dst)</span></span>&#123;</span><br><span class="line">    mkdir(dst, <span class="number">0755</span>);</span><br><span class="line">    <span class="comment">//创建目标目录，定义一个基类型为目录项结构体的指针用于遍历(流式结构指针自动后移)源目录,打开源目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">pdirent</span>;</span></span><br><span class="line">    DIR* pdir = opendir(src);</span><br><span class="line">    <span class="keyword">char</span> newsrc[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> newdst[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ERROR_CHECK(pdir, <span class="literal">NULL</span>, <span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历源目录，跳过目录项 . 和 .. 目录项类型为DT_DIR先配置好新地址然后递归，目录项类型为其他文件copy</span></span><br><span class="line">    <span class="keyword">while</span>((pdirent = readdir(pdir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pdirent-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(pdirent-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)&#123;<span class="comment">//注意C的字符串比较</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//和tree稍有不同tree是遍历到直接打印，遇到子目录才递归进去，cp -r不管是不是子目录都需准备新目标地址，因为只给了目录</span></span><br><span class="line">        <span class="built_in">sprintf</span>(newsrc, <span class="string">&quot;%s%s%s&quot;</span>, src, <span class="string">&quot;/&quot;</span>, pdirent-&gt;d_name);</span><br><span class="line">        <span class="built_in">sprintf</span>(newdst, <span class="string">&quot;%s%s%s&quot;</span>, dst, <span class="string">&quot;/&quot;</span>, pdirent-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span>(pdirent-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">            cpdir(newsrc, newdst);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cpfile(newsrc, newdst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpfile</span><span class="params">(<span class="keyword">char</span> *src, <span class="keyword">char</span> *dst)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fdr = open(src, O_RDONLY);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(dst, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = read(fdr, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">//注意read与write的常用法</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(fdw, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他的文件操作 ：改变文件大小<code>ftruncate</code>，文件映射机制<code>mmap</code>配合<code>ftruncate</code>使用</p></blockquote><p><code>TRUNCATE(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>mmap</code>可以将一个磁盘文件映射到存储空间的一个缓冲区上，无需使用<code>read</code>和<code>write</code>进行IO</p></blockquote><p><code>MMAP(2)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个文件，里边内容为hello，通过mmap映射该文件后，修改hello为world，然后解除映射。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./mmap file</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> cut = ftruncate(fd, <span class="number">5</span>);</span><br><span class="line">    ERROR_CHECK(cut, <span class="number">-1</span>, <span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line">    <span class="comment">//建立映射关系</span></span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">5</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>); </span><br><span class="line">    ERROR_CHECK(p, MAP_FAILED, <span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    munmap(p,<span class="number">5</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-4-IO多路转接模型"><a href="#3-4-IO多路转接模型" class="headerlink" title="3.4 IO多路转接模型"></a>3.4 IO多路转接模型</h4><h2 id="写在后面-结"><a href="#写在后面-结" class="headerlink" title="写在后面(结)"></a>写在后面(结)</h2><blockquote><p>还是太菜，任重而道远</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Unix/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_Summarize_with_code</title>
      <link href="/2022/02/17/5.C-Summarize-with-code/"/>
      <url>/2022/02/17/5.C-Summarize-with-code/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1.基本数据结构"></a>1.基本数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="2-常见排序算法"><a href="#2-常见排序算法" class="headerlink" title="2. 常见排序算法"></a>2. 常见排序算法</h3><blockquote><p>关于排序算法分析</p><p>1.时间复杂度</p><p>冒泡排序，插入排序，简单选择排序无法突破<code>O(n2)</code>时间复杂度，因为其有序化过程中都是一个一个来减少逆序度的，当逆序度为0时整个序列有序，相对的希尔，并归，快排，堆排能突破是因为其不依赖相邻元素逐个排序。</p><ul><li><p>最好，最坏，平均   </p><p>分析时间复杂度，要给出 最好，最坏，平均情况下的时间复杂度(给出最好，最坏情况下对应要排序的原始数据情况)</p><ul><li><p>平均时间复杂度分析</p><p>n个元素有n!种排序，然后统计比较和交换的次数，再计算平均值。想想就十分复杂。</p><p>这里我们采用逆序对的方式来分析。</p><p>有序元素对：<code>arr[i] &lt;= arr[j], i &lt; j  </code></p><p>逆序元素对：<code>arr[i] &gt; arr[j], i &lt; j</code></p><p>有序度：数组中有序元素对的个数</p><p>逆序度：数组中逆序元素对的个数</p><p>满有序度：数组排好序后的有序度。</p><p>假设数组有n个元素，满有序度 =  <code>n(n-1)/2</code></p><p>公式： 满有序度 = 有序度 + 逆序度排序过程就是增加有序度，减少逆序度，最终达到满有序度的过程。</p></li></ul></li><li><p>常数，系数，低阶  </p><p>时间复杂度反应规模n很大时的增长趋势，忽略常数，系数，低阶(考虑规模小的数据时考虑这些因素)</p></li><li><p>比较， 交换  </p><p>基于比较的排序算法涉及元素的比较，交换，分析效率要考虑这些</p></li></ul><p>2.空间复杂度  </p><p>是否是原地算法</p><p>3.稳定性  </p><p>待排序列中存在值相等的元素，排序后这些元素间的前后关系是否不变</p></blockquote><p><code>bubble</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// i 表示冒泡的次数，也就是比较的趟数</span></span><br><span class="line">        <span class="keyword">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//每趟比较中，j从0开始取相邻两个元素比较(交换),每趟一定有一个元素有序排好，可以利用i</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;<span class="comment">//做点优化，使得有序(这趟没执行交换)之后结束排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有序度是数组中具有有序关系的元素对的个数。如果一个数组完全有序，有序度就是<code>Cn2 = n(n-1)/2</code>，这种叫做满有序度。</p><p>对于冒泡排序来说，交换会导致：有序度+1， 逆序度-1.</p><p>所以 交换的次数 = 逆序度。可以简单的认为平均情况下，逆序度 = <code> n(n-1)/4</code> 比较的次数肯定比交换的次数多，但少于 <code>n(n-1)/2</code>所以平均情况下，时间复杂度为<code>O(n2)</code></p></blockquote><p><code>selection</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// i表示选择元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = i;<span class="comment">//先预设当前索引所指数为最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//j从后一个元素开始向后找有无更小的</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每趟先假定本趟开头为最小元素，记录其索引，从其后一个元素开始向后遍历，找到更小的，更新最小元索引记录一趟走完交换本趟开头与最小<br>发生长距离的交换 所以不稳定</p><p>[5, 5, 1, 2, 3, 0, ]第一个5换到第二个5后面</p><p><code>O(n2) </code>不存在最好最坏，都是<code>O(n2)</code></p></blockquote><p><code>insertion</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">// i代表待插入元素的索引，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">int</span> val = arr[i];<span class="comment">//先记录，如果要插到前面的话需要前方元素后移，可能会覆盖它</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">//找到待插元素的前一个元素</span></span><br><span class="line">        <span class="comment">// 元素(比记录的待插元素大)往后移(凡比ta大的都后移，留出ta的位置)</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从第二个元素开始，每趟排序使当前遍历元素变得有序，取出元素值后先记录，往前找，凡前前面的元素(认为是有序序列)比ta大的，都后移，留出ta的位置，把它插入</p><p>最好<code>O(n) </code>比较n-1此，序列有序，不做交换</p><p>最坏O(n2)</p><p>逆序度分析平均时间复杂度 </p><p>稳定</p></blockquote><blockquote><p>选择排序一般不使用，冒泡排序一般也不用，</p><p>可能会用到的是插入排序为什么选择插入而不选择冒泡选择O()表示法省略了系数项和低阶项</p></blockquote><p><code>shell</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 组间插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123; <span class="comment">//还是插入排序的特性，先取后面的元素，只是这里用增量序列分组</span></span><br><span class="line">                                        <span class="comment">//i = gap 以 n = 10 个数为例 每轮 gap /= 2;  </span></span><br><span class="line">                                        <span class="comment">// 8 9 1 7 2 3 5 4 6 0  gap = 5</span></span><br><span class="line">                                        <span class="comment">// |         |</span></span><br><span class="line">                                                     i</span><br><span class="line">            <span class="keyword">int</span> val = arr[i];    <span class="comment">//组内比大小交换</span></span><br><span class="line">            <span class="keyword">int</span> j = i - gap;    </span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];<span class="comment">//每组前面的值先赋值给后面的值</span></span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = val; <span class="comment">//先减掉后加上用于交换赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缩小gap</span></span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>(缩小增量排序)插入排序的优化版本 (第一批突破<code>O(n^2))</code>基于插入排序的性质提出改进方法  </p><ul><li><p>插入排序对基本有序的数据操作时，效率高。  </p></li><li><p>插入排序的缺点:每次比较相邻两个元素:对于基本有序的数组，一直比较相邻元素若有插入距离远的将比较多次，不适合</p></li></ul><p>希尔有先比较 距离远的(使得数据基本有序)基本有序的元素交换距离短</p><p>选择一个增量序列gap:(希尔推荐:n/2, n/4, …, 1)，分组，然后组间插入排序缩小增量 再分组 组间插入排序</p><p>插入排序:当数组基本有序，性能好(利用这一点)的有限，并解决不能长距离交换元素的缺点</p><p>长距离交换元素 不稳定</p><p>时间复杂度小于<code>O(n^2),</code>与增量序列有关</p></blockquote><p><code>merge</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//所给的接口感觉不好实现，在函数内部做一层封装委托出去</span></span><br><span class="line">    merge_sort1(arr, <span class="number">0</span>, n - <span class="number">1</span>);       <span class="comment">//知道数组的长度，把头当左界，尾当右界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;<span class="comment">//采用分治的思想，假定已有部分子序列有序，把他们合并</span></span><br><span class="line">                                                  <span class="comment">//至于怎么得到有序的子序列anyway，先不管，交个计算机，我只考虑这一层</span></span><br><span class="line">    <span class="comment">// 边界条件                                      //使用递归来做</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 递归公式</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);       <span class="comment">//使用已知的左右界求得中间节点，作为下层的右界，左界</span></span><br><span class="line">    merge_sort1(arr, left, mid);                  <span class="comment">//下层将要给我的是有序的左半边子序列 右半边子序列，实现合并即可</span></span><br><span class="line">    merge_sort1(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(arr, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;<span class="comment">//关键 实现归并操作</span></span><br><span class="line">    <span class="keyword">int</span>* temp = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>((right - left + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//先分配长度为n的辅助数组，排序过程中先将数据存入辅助序列</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;  <span class="comment">//两半有序子序列合并成整个有序序列</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;       <span class="comment">//Caution: 不能是 arr[i] &lt; arr[j] 相等的左边仍在前面 保证稳定性</span></span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;                  <span class="comment">//如果有一边的数据未取完，剩余的全复制过去</span></span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[left + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(nlog n)</code>的时间复杂度。代价是需要额外的内存空间<code>O(n) </code> tmp数组辅助。</p><p>稳定</p><p>建立在归并操作上的一种有效的排序算法是采用分治法（Divide and Conquer）(一种算法设计思想，策略)的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；</p><p>即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p></blockquote><p><code>Quick</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//同样，给定的接口不太好实现，可以利用已有的信息构建自己的内部接口委托实现</span></span><br><span class="line">    quick_sort1(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; <span class="comment">// pivot 枢 基准 定标点， 从数列中挑出元素做基准定标点</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)                               </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = partition(arr, left, right);         <span class="comment">// 这个pivot的选取由分区函数实现，可以认为它有序了</span></span><br><span class="line">                                                   <span class="comment">// 接下来下层函数实现 pivot左边和右边的排序</span></span><br><span class="line">    quick_sort1(arr, left, idx - <span class="number">1</span>);</span><br><span class="line">    quick_sort1(arr, idx + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;    <span class="comment">//那么怎么找到这个定标点，使得比它小的在它左边，大的在它右边</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];                         <span class="comment">//定标的过程中也完成了局部的排序， 先选定pivot在最左侧(有不同选法)</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123;           <span class="comment">//本例做法:标定在左边，先判右边，在右边找到比pivot小的，</span></span><br><span class="line">            j--;        </span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[j];                           <span class="comment">//填入pivot的位置，而这个位置的值暂存在pivot中也不会丢失</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123;           <span class="comment">//再判断左边，此时arr[i]为新填入，一定会向右走，当遇到比pivot大的</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = arr[i];                           <span class="comment">//填到刚才换走数据的位置中</span></span><br><span class="line">    &#125;<span class="comment">//当i, j 相遇，此时比pivot小的已经全部换去左边，比pivot大的已经全部换去右边，这里是pivot的正确位置，填入并返回</span></span><br><span class="line"></span><br><span class="line">    arr[i] = pivot;    <span class="comment">//来回交换，但一次始终只交换一个，由pivot暂存有一个值，所以不会有数据丢失</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>实现简答，变种多，性能好(桶排序和计数排序不基于比较 所以能突破<code>O(nlog(n))</code>)</p><p>算法思路：</p><ol><li>从数列中挑出一个元素，称为 “基准”<code>（pivot）</code>；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置(也是它最终的位置)。这个操作我们称之为分区<code>(partition)</code>；</li><li>递归地<code>(recursive)</code>把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>最坏情况：<code>O(n^2) </code>每次分区，基准都位于最右边或者最左边<code> T(n) = T(n-1) + O(n) = T(n-2) + O(n-1) + O(n) =.....</code>.;  <code>partition</code> 为<code>O(n)</code> 两个指针 i, j 分别遍历<br>最好情况：<code>O(nlogn)</code>每次分区，基准值都位于中间， <code>T(n) = 2T(n/2) + n; </code>每次问题规模折半</p></blockquote><p><code>heap</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;     <span class="comment">//先构建大顶堆，使堆顶最大，左右子树也是大顶堆</span></span><br><span class="line">    build_heap(arr, n);             <span class="comment">//传入序列与长度完成构建,取最大值做顶</span></span><br><span class="line">    <span class="keyword">int</span> length = n;                 <span class="comment">//此时还没进行排序，认为 无序区的长度为 n</span></span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">1</span>) &#123;            <span class="comment">//单个节点为最小大顶堆</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, length - <span class="number">1</span>);   <span class="comment">//将此时的顶换至末尾，减少序列长度-&gt;认为最大(顶)排序完成</span></span><br><span class="line">        length--;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, length);    <span class="comment">//将长度减少的序列重新调整成大顶堆，实际最大数据已经填在数组正确位置不再对它操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到最后一个有孩子的结点         //分析数组，先把无序的数组认为是一个完全二叉树，要让这个数组满足大顶堆的性质</span></span><br><span class="line">                                    <span class="comment">//无序的完全二叉树不是堆，需要调整</span></span><br><span class="line">                                    <span class="comment">//调整从数组的末尾开始做起，找到最后一个有孩子的节点，认为它的孩子是大顶堆</span></span><br><span class="line">                                    <span class="comment">//把这个节点和它的孩子们这棵子树调整成大顶堆</span></span><br><span class="line">                                    <span class="comment">//往数组的前面继续...</span></span><br><span class="line">    <span class="comment">// 数组从0 开始编号 左孩子为2i+1 右孩子为 2i+2</span></span><br><span class="line">    <span class="comment">// i:  leftChild=2i + 1, rightChild = 2i + 2;</span></span><br><span class="line">    <span class="comment">// 找最后一个有孩子的节点序号i 判断有孩子，只要有左孩子就行</span></span><br><span class="line">    <span class="comment">// 2i + 1 &lt;= n - 1 --&gt; i &lt;= (n - 2) / 2;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//从最后一个有孩子的节点开始调整，调整完后下一个调整的是数组中排在它前面的</span></span><br><span class="line">        heapify(arr, i, n);                     <span class="comment">//依次完成调整，构建大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//从上往下调整为大顶堆</span></span><br><span class="line">                                         <span class="comment">//记录并与左右孩子比较</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = i;</span><br><span class="line">        <span class="keyword">int</span> leftChild = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightChild = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftChild &lt; n &amp;&amp; arr[leftChild] &gt; arr[maxIdx]) <span class="comment">//限制避免数组越界再比较</span></span><br><span class="line">            maxIdx = leftChild;</span><br><span class="line">        <span class="keyword">if</span> (rightChild &lt; n &amp;&amp; arr[rightChild] &gt; arr[maxIdx])</span><br><span class="line">            maxIdx = rightChild;</span><br><span class="line">        <span class="keyword">if</span> (maxIdx == i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i, maxIdx);</span><br><span class="line">        i = maxIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>二叉堆 完全二叉树</p><p>大顶堆：堆顶元素最大，左右子树也是大顶堆</p><p>小顶堆：堆顶元素最小，左右子树也是小顶堆</p><p>堆:近似完全二叉树:性质:子节点的键值或索引总是小于（或者大于）它的父节点 </p><p><em>Wikipedia</em></p><p>以升序排序说明，把数组转换成最大堆(Max-Heap Heap)，这是一种满足最大堆性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。</p><p>思路：</p><ol><li>构建大顶堆</li><li>交换堆顶和无序区最后一个元素 此后 无序区元素个数-1，有序区元素个数+1</li><li>把无序区重新调整成大顶堆O(log(n))重复步骤2</li></ol><p>完全二叉树可以用数组去做-&gt;把待排序数组看成堆</p><p>先把待排序数组看做无序的完全二叉树 数组从前到后对应树的层序 ： 这个无序的完全二叉树不是堆，需要调整</p><p><strong>定义：单个节点的树是大顶堆</strong>找到第一个有孩子的节点 它的左右孩子一定是大顶堆然后把第一个有孩子的这棵树构建成大顶堆(做法:这个有孩子的节点与其左右孩子比较，大的改为父亲节点) –&gt;获得了第一个是大顶堆的子树以此类推-&gt;从后往前找，判，变      </p><p>大顶堆构建完成<br>由构建的过程知，堆顶元素为数组中最大元素，堆顶元素位于数组中索引为0的位置，交换它与数组的末尾</p></blockquote><p><code>二叉搜索与其变种</code></p><p><code>递归实现</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 递归公式</span></span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line"><span class="keyword">return</span> binary_search1(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)</span><br><span class="line"><span class="keyword">return</span> binary_search1(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">return</span> binary_search1(arr, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>循环实现</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>变种 </code>查找第一个与target相等的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid == left || arr[mid - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找最后一个小于等于target值的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt;= target) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == right || arr[mid + <span class="number">1</span>] &gt; target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找最后一个与key相等的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找3</span></span><br><span class="line"><span class="comment">//&#123; 0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 4, 5, 6, 7, 8, 9 &#125;;</span></span><br><span class="line"><span class="comment">//                             |</span></span><br><span class="line"><span class="comment">//     返回9</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; target) &#123;<span class="comment">//向右缩小范围</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;<span class="comment">//向左缩小范围</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (mid == right || arr[mid+<span class="number">1</span>] &gt; target) &#123;<span class="comment">//处理相等，走到末尾(此时右边界)或者下个大于target可返回</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找第一个大于等于key值的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; target) &#123;<span class="comment">//向右缩小范围</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid == left || arr[mid<span class="number">-1</span>] &lt; target) &#123;<span class="comment">//当前arr[mid]&gt;= target 向左走到边界 或者遇见小的</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="写在后面-结"><a href="#写在后面-结" class="headerlink" title="写在后面(结)"></a>写在后面(结)</h2><blockquote><p>本次关于C的整理梳理工作暂时告一段落，总的来说，起初的基础知识方面的整理有些浮躁，不耐烦，但是在重看过程中发现了不少之前未注意到的点，多对自己提问，试图站在作者的角度思考这个问题的产生与解决，分析需求并给出解决办法是有好处的，新的视角会带来一些未曾有过的思考。</p><p>同时也发现学过或者说学过不止一遍不代表就是懂得，就是精通。越发感觉此前的学习方式存在不少问题。<strong>Talk is cheap. Show me the code.</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C Summarize</title>
      <link href="/2022/02/10/4.C-Summarize/"/>
      <url>/2022/02/10/4.C-Summarize/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote><p>  对于C的学习，已经反复好多次了，前面一直想要做个系统的梳理，但总是会出各种状况。之前有过跟着视频学习，自己对着书看写例程写课后题等等，最完整的一次梳理是在2020年的寒假，那次花了比较多的时间，从重看翁恺老师的视频开始，后续继续看了《K&amp;R》《C陷阱与缺陷》《C和指针》《C专家编程》等书。前期跟视频以及看《K&amp;R》可能算是做到了专注，精读，但后面有完成任务式的阅读，最终感觉效果不佳。当然，那段时间确实感觉有较大的提升，可后面因为一些事情耽误，很长一段时间没有再碰过。</p><p>最近打算重新系统梳理相关知识。这次打算配合最近捡起的知识点及写的程序，对C做大致的总结梳理。(总结自用，可能不甚严谨)</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-历史"><a href="#0-历史" class="headerlink" title="0.历史"></a>0.历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ken Thompson为了游戏(Space Travel)</span><br><span class="line">Multics -&gt; Unics(最初汇编PDP-7,移植性问题-&gt;发明BCPL:B语言)-&gt;</span><br><span class="line">Dennis Ritchie加入</span><br><span class="line">Dennis Ritchie-&gt;B不适合Unics(内核)开发:发明C -&gt; 用C重写Unics更名为Unix</span><br></pre></td></tr></table></figure><blockquote><p>结论： C用来<strong>开发系统软件</strong> (重写Unics系统,而此系统是K为了发挥PDP-7的全部性能以玩游戏而产生的)：       </p><p>所以C没有try-catch机制(耗费性能)       C与汇编有强对应关系</p></blockquote><h3 id="1-虚拟内存空间"><a href="#1-虚拟内存空间" class="headerlink" title="1.虚拟内存空间"></a>1.虚拟内存空间</h3><blockquote><p>源码经-&gt;预处理-&gt;编译-&gt;汇编-&gt;链接  程序-静态</p></blockquote><blockquote><p>变成了可执行文件，而可执行文件加载进内存变为进程，用于独立的虚拟内存空间 进程-动态</p></blockquote><p><img src="https://s2.loli.net/2022/02/15/fDxObctmSZCYWNM.png" alt="虚拟内存空间.png"></p><p>每个进程有自己的虚拟内存空间，而这个图可以辅助理解一些语言以及程序的相关特性。</p><blockquote><p>如：</p><ol><li>0x00000000 NULL 预留出不能访问 再将其定义为宏 #define 0x00000000 NULL (减少magic number)</li><li>HEAP 向上增长，结构体之类，程序员自行管理(如何申请，如何释放)</li><li>STACK 向下增长 存栈帧(活动记录：编译器实现过程调用的数据结构),存局部变量，运行函数</li><li>虚拟地址空间分区:高地址-&gt;低地址：OS区, 栈, 堆, 代码段数据段, NULL;</li><li>大端小端: 多字节数据布局问题<br>little-endian: 低地址存低位:小端: 0a 00 00 00(存10(0a)， 低–&gt;高)<br>big-endian   : 低地址存高位:大端: 00 00 00 0a<br>多字节间(00 00 00 0a)数据顺序相反，字节内(0a)不变</li><li>为什么OS存放在高地址:几乎所有OS都这么设计，编程要计算内存资源做地址分配，从低地址开始比较合理<br>OS为用户程序服务，映射到高地址<br>放在高地址用户程序很难碰到，在实模式时期也能最大程度兼容用户程序(使之保有原地址而不是后移)</li></ol></blockquote><h3 id="2-未曾想过并认为理所当然的问题"><a href="#2-未曾想过并认为理所当然的问题" class="headerlink" title="2. 未曾想过并认为理所当然的问题"></a>2. 未曾想过并认为理所当然的问题</h3><blockquote><p>关于之前没有关注过的认为理所当然的问题 辅助理解编译器给出的一些信息<br>1.<br>什么是表达式，语句，表达式语句<br>表达式(计算某值的公式)有值 按C的语言规定，很多地方需要给一个表达式 比如 while(…){}括号中需要一个表达式<br>所以<code>while(int i)&#123;&#125;</code>报错 <code>int i</code>不是一个表达式(是初始化语句?)<br>表达式以;结尾变成表达式语句<br>为什么编译器有时提示xxx不做 左值(一片存储空间)<br>表达式就不能做左值(它是计算某个值的公式)这个值应该是固定的不能让它改变也就不能做左值<br><code>&#123;...&#125;</code>是复合语句，让编译器将{}内的语句理解为一条语句</p><p>2.<br>为什么宏定义不用分号做结尾 <code>#define N 10</code><br>ta是预处理指令，是指令而不是语句，因此不用;结尾<br>预处理时是直接把它复制做文本替换的</p><p>3.<br>为什么<code>scanf()</code>, <code>printf()</code>函数能处理不定参数，这是怎么做到的?<br>可以输出输入多个参数的值，但又不知道多个几个</p><p>4.<br>知道优先级这个概念与内容<br>但是编译器是怎么理解并解析优先级的?</p><p>5.<br>为什么 <code>switch-case</code> 中 <code>case:</code> 后不需要加花括号{}<br>case是标签</p><p>6.<br><code>while do-while for</code> 之间的替换问题<br>由于<code>for(int i = 0; i &lt; n; ++i)</code>//将循环条件的改变放在语句中 所以在使用continue;时不要用它做替换</p><p>7.<br>为什么数组元素需要类型相同(一片连续内存，并且它被划分为大小相等的小空间)<br>为了随机访问-&gt;寻址公式:<code> address_i = base_address + i * sizeof(type);</code><br>为什么数组下标从0开始？<br>也是为了实现寻址公式。从1开始寻址会变为<code>address_i = base_address + (i-1) * sizeof(type); </code><br>或者不用第一个空间(浪费)则公式不变<code>address_i = base_address + i * sizeof(type);</code></p><ol start="8"><li>为什么函数不返回数组(做参数带出是可以的)<br> 要让它做返回值，说明是在这个函数周期内声明的?函数返回时，本地变量生存期结束，回收返回野指针?</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findMinMax</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="comment">/*** WRONG ***/</span></span><br><span class="line"> <span class="keyword">int</span> result[<span class="number">2</span>];</span><br><span class="line"> result[<span class="number">0</span>] = result[<span class="number">1</span>] = arr[<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (arr[i] &lt; result[<span class="number">0</span>])</span><br><span class="line">         result[<span class="number">0</span>] = arr[i];</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; result[<span class="number">1</span>])</span><br><span class="line">         result[<span class="number">1</span>] = arr[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样返回的指针也是指向当前函数的栈帧区域的，函数返回，这片区域不可控，变为野指针</p><p>9.<br>带参宏 <code>#define SIZE(a) (sizeof(a) / sizeof(a[0]))</code>挺好用的 </p><p>10.<br>为什么数组名在传递给函数时被视为指针？<br>C只有值传递，早期考虑传递数组整个copy耗时耗内存<br>所以使传递数组为参数时退化为指针(为什么会用“退化”–&gt;与隐式类型转化相似)<br><code>int find_largest(int a[], int n)&#123;&#125;</code><br><code>int find_largest(int *a, int n)&#123;&#125;</code>这样写可读性差，但更接近本质</p><p>11.<br>编译器帮忙补全的main()的参数<code>int main(int argc, char const *argv[])</code><br>命令行参数<br>OS调用<code>main(int argc, char const *argv[]) </code>并传参给它<br><code>argc   </code> : 参数计数<br><code>*argv[] </code>: 参数组，第一条参数为 函数名<br>有了这个特性<br>传递给<code>main()</code>不同的参数，可以产生不同的行为(.e.g:文件操作不再需要写死文件地址)“由命令行参数改变函数行为”</p><p>12.<br>使用free()函数时，参数只是给了一个 指针(指向某片内存的首地址)，free怎么知道要释放多少内存?<br>在之前分配内存时就给出了此块内存占多少字节 (关于这点可以看《CS:APP》free_list空闲链表)(free为程序员减负)?</p></blockquote><p><img src="https://s2.loli.net/2022/02/15/7G4lhe9OjHZXMig.png" alt="优先级表.png"></p><p><img src="https://s2.loli.net/2022/02/15/One4RJdaDyXchmp.png" alt="ASCII表.png"></p><h3 id="3-递归-recursion"><a href="#3-递归-recursion" class="headerlink" title="3. 递归 recursion"></a>3. <strong>递归 recursion</strong></h3><p>定义时调用本身 (传统引例为:斐波那契数列求和，其实这并不是一个很好的例子(画出递归树可知有<strong>太多重复计算</strong>性能差))</p><p><strong>但作为分析案例是合适的</strong></p><p>它满足以下条件：</p><ul><li>大问题分解为小问题</li><li>大小问题求解方式一致，只是规模不同</li><li>小问题的解可合成大问题的解</li></ul><p>可是使用递归，但注意在递归代码书写时，一定要有:</p><ul><li><p>边界条件(没有的话会调用下去直到Stack Overflow)</p></li><li><p>递归公式要考虑重复计算问题:</p></li></ul><p>以斐波那契为例，由于存在重复计算问题，其实效率不高</p><p>总结：<strong>得出递归公式，知道边界条件且解决重复计算问题可用递归</strong></p><p>更经典的例子:</p><p><strong>汉诺塔问题 Hanoi</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> start, <span class="keyword">char</span> middle, <span class="keyword">char</span> end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hanoi(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> start, <span class="keyword">char</span> middle, <span class="keyword">char</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, start, end); <span class="comment">//记得设置边界条件，不然会一直递归下去</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        hanoi(n<span class="number">-1</span>, start, end, middle);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c\n&quot;</span>, start, end);</span><br><span class="line">        hanoi(n<span class="number">-1</span>, middle, start, end);</span><br><span class="line">    &#125;<span class="comment">//抽象的思考问题，不要考虑具体实现细节，交个计算机来做，只想这一步该完成什么(这里即:将前n-1个经end移至middle)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>约瑟夫问题 Joseph (只是其中一种，隔一个杀一个的情况)</strong></p><p><img src="https://s2.loli.net/2022/02/15/nX2uet4WBZEpqib.png" alt="约瑟夫环.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jos</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,  jos(<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jos</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//边界条件</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * jos(n / <span class="number">2</span>) - <span class="number">1</span>; <span class="comment">//输入偶数的规模与编号关系</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * jos((n - <span class="number">1</span>) / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//隔一个杀一个的Joseph环，推导一定次数之后  得出规律</span></span><br></pre></td></tr></table></figure><p><strong>结论：递归是一种考虑问题的思想，可以降低问题的复杂度</strong></p><p><strong>使用递归时，不要用脑向下展开模拟，站在较高的角度，抽象的考虑当前这步：</strong></p><p><strong><code>hanoi</code>比较典型</strong></p><p><strong>当前这步将最大的圆盘n从 start –&gt; end而为了实现这步，需要将其上的n-1个盘从start –&gt; end –&gt; middle</strong></p><p><strong>当最大盘到end之后，将此时在middle上的n-1个盘 middle –&gt; start –&gt; end</strong></p><p><strong>anyway：中间的具体实现不去管它，交给计算机去一层层分解。</strong></p><h3 id="4-指针"><a href="#4-指针" class="headerlink" title="4.指针"></a>4.指针</h3><blockquote><p>在本次回顾与重学的过程中，改用了<code>Visual Studio</code>，相比于之前使用的<code>VsCode+MinGW</code>的方案，它的各种检查更加严格，使用起来没有之前那么间接方便，但是也帮助发现了不少之前没注意的细节问题。</p></blockquote><blockquote><p>1<br>野指针问题(没有初始化)但是对它解引用赋值了(属于未定义的行为)<br>注意 <code>int *p = 0x100;</code> 也是野指针，虽然初始化了，但是指向的区域不可控。<br>野指针指向未知(不可控)产生未定义的行为<br>空指针(“不指向任何地方的指针”)实现为指向<code>NULL(0x00000000)</code>但对其指向访问也是未定义的行为,可看做野指针的一种</p><p>2<br>由指针的算数运算特性，可以使用指针控制访问数组<br><code>char str[N] = &#123;0&#125;</code><br><code>for(char *p = str + N; p &gt; str; --p)&#123;&#125;</code> //使用指针而不是整数控制访问数组</p><p>3<br>数组名作为指向数组第一个元素的指针(数组名是个常量指针不能改其值)<br>反过来也能把指针当数组名用 <code>char *p = str; p[i] </code>编译器解释为<code>*(p + i)</code></p><p>4<br>字符串字面值是一个常量，使用指针指向它是不能用指针修改它的<br><code>*p = &quot;a string&quot;;</code> 使<code>p</code>指向字符串第一个字符<br><code>*p = &quot;b&quot; /*** WRONG ***/</code> 指向的字符串字面值是常量，不能修改</p><p>而<br><code>char data[9] = &quot;a string&quot;</code> 不是将字符串字面值给字符数组<br>其实是编译器帮我们做了一些工作，其本质为<br><code>char data[9] = &#123;&#39;a&#39;, &#39; &#39;, &#39;s&#39;, &#39;t&#39;, &#39;r&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;, &#39;\0&#39;&#125;   </code><br>所以其后<code>data[]</code>数组中的值是可以改变的</p><p>对比<br><code>char data[] = &quot;a string&quot;;</code>  字符数组 – 可修改data中字符           – data为数组名,不能改变指向<br><code>char *data  = &quot;a string&quot;;  </code>字符指针 – data指向字符串字面值,不可改  – data为指针变量,可改变指向<br>所以对要修改字符串的场景，使用字符数组存储。要使用指针的话，这个指针必须指向实际存在的字符数组。</p><p>5.<br>结构成员运算符 <code>“.”</code><br>结构指针运算符 <code>“-&gt;”</code><br><code>(*p).val = xx; &lt;=&gt; p-&gt;val = xx;</code></p><p>6.<br><code>free()</code>释放了分配的内存块但也引入了新的问题–悬空指针<br>显然<code>free(p)</code>释放内存后 p指向的空间被回收<br>这时试图由指针p访问或修改这片内存(野指针了属于是)也会导致未定义的行为。<br>同时，如果有多个指针指向同片内存空间，释放指针可能会导致这些指针都悬空</p></blockquote><h2 id="写在后面-想法"><a href="#写在后面-想法" class="headerlink" title="写在后面(想法)"></a>写在后面(想法)</h2><blockquote><p> 关于思考，学会思考是很重要的事情，之前总有这样的感觉:老师说什么就是什么，同时老师说到哪里就截止到哪里。感觉自己并没有向下深思，探究底层逻辑的想法。诚然，在这些年的学习过程中，我是体会到过 懂得底层逻辑，并在有较完善知识体系结构的基础上学习新知识的好处的。</p><p>但经常陷入两个误区：</p><p>一是抓住细枝末节后往其它细枝末节深究(感觉这样也不能说没用处，但是可能在没有足够好的基础的情况下深究这些效果不佳，同时对于此前的学习场景(在有限的时间内尽可能掌握固定范围的知识)这种学习思路对打好基础没有太多的益处，同时也耗费了相当多的时间，转移了有限的注意力。)</p><p>二是喜欢囤积知识，为了搭建好的知识体系，回去参考其他人分享的经验(书单，课程，视频…)但是收集到了这些信息不代表就是懂得了这些知识。</p></blockquote><blockquote><p>学习时不要用后续的”高深”知识点逆推基础，反而要思考作者的思路从基础推出高深(成体系)。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello New Worldhistory</title>
      <link href="/2022/01/22/3.Hello-New-World-history/"/>
      <url>/2022/01/22/3.Hello-New-World-history/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/60578464">参考</a><br><a href="https://ares-x.com/2019/12/29/freemind-bithack-readme-zh/">主题参考</a><br><a href="https://lacsscal.github.io/">实现效果</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>原理：本地撰写MarkDown文档，Hexo解析渲染成具有主题样式的HTML静态网页，推送至GitHub完成发布。</p></blockquote><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li> 环境 nodejs, git</li><li> 连接GitHub</li><li> 添加Github SSH秘钥 并验证连接</li><li> 创建GitHub仓库</li><li> 本地安装Hexo博客并测试</li><li> <strong>部署</strong>注意分支名(main/master）到github上</li><li> 验证</li></ol><h2 id="本地Hexo"><a href="#本地Hexo" class="headerlink" title="本地Hexo"></a>本地Hexo</h2><blockquote><p>前面的准备过程跳过，以前搭过，环境还在，环境配置也不难<br>下面从Hexo本地安装开始<br>因为Hexo是基于Node.js的静态博客框架，可以经由npm一键安装</p></blockquote><pre><code>npm install -g hexo-cli #安装命令</code></pre><p>安装好后初始化即可，选一个空文件夹初始化并安装所需组件</p><pre><code>hexo init      # 初始化npm install    # 安装组件</code></pre><p>生成页面并启动，本地安装完成 可访问 <a href="http://localhost:4000/%E9%AA%8C%E8%AF%81">http://localhost:4000/验证</a></p><pre><code>hexo g   # 生成页面hexo s   # 启动预览(本地，Ctrl+C结束)</code></pre><p>​<br>后面要更新，删除博客方案类似</p><pre><code>hexo g   # 生成页面(增删都是)先渲染？大概hexo d   # 发布[注]自行添加一段名字与时间戳方便归档，或者使用命令生成自行添加：---title: 给个名字date: 2022-01-22 14:16:19tags:---命令生成：hexo new &quot;给个名字&quot;</code></pre><p>​    </p><h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><p>一般来说<a href="http://localhost:4000能访问成功说明本地安装完成，之后部署到Github上即可，此前已经建好仓库并且配置好SSH秘钥">http://localhost:4000能访问成功说明本地安装完成，之后部署到Github上即可，此前已经建好仓库并且配置好SSH秘钥</a><br>再安装组件</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>​<br>并修改  _config.yml 配置文件末尾的 Deployment 部分，<br>修改成如下：</p><pre><code>deploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: master/main</code></pre><p>完成后执行</p><pre><code>hexo d</code></pre><p>访问https://用户名.github.io 验证，一般要等待几分钟到十几分钟不等<em>我在搭建时先在本地置换了主题并验证成功后部署，但是在经过15以上页面才渲染成功</em></p><h3 id="关于主题更换"><a href="#关于主题更换" class="headerlink" title="关于主题更换"></a>关于主题更换</h3><blockquote><p>可以放在部署之前进行，也能在部署之后进行<br>我找了个FREEMIND-BITHACK主题，参考<a href="https://ares-x.com/2019/12/29/freemind-bithack-readme-zh/">主题参考</a>，<br>下载好的主题放在X:\blog\themes文件夹下并修改配置主题文件夹名与配置文件_config.yml中主题名一致。</p></blockquote><h1 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h1><p>后续还有一些细节，暂时不想折腾了，后续完善再说吧<br>目前简单使用可行</p><p>1.post文件夹下新增 .md文件<br>2.git bash here<br>3.hexo g 生成页面<br>4.hexo d 同步发布</p>]]></content>
      
      
      
        <tags>
            
            <tag> xxxx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test2</title>
      <link href="/2022/01/22/2.test2/"/>
      <url>/2022/01/22/2.test2/</url>
      
        <content type="html"><![CDATA[<p>test 2 <em>version2.0</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> xxxx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/21/1.hello-world/"/>
      <url>/2022/01/21/1.hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> xxxx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
