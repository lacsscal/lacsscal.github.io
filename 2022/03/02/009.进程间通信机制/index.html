<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Unix-Linux-Process-进程间通信 | lacsscal&#39;s blog</title>
  <meta name="author" content="chen">
  
  <meta name="description" content="进程间通信 IPC:Inter Process Communication
分别从几种进程间通信机制总结，每个机制可能搭配几个相关函数或系统调用的手册信息和一个或几个小例程，分析一下各种机制的特点。

1.管道
之前用过命令创建的有名管道, 也能在程序中创建管道。在fork()的基础上还能使用匿名管道。

POPEN(3) PCLOSE(3)  
12345FILE *popen(const char *command, const char *type);                         |                     底层实现是fork()+exec()int pclose(FILE *stream);用的不多，意义不大, fork+匿名管道pipe可能更常用一点

PIPE(2)
123456int pipe(int pipefd[2]);                 |               传参时退化为指针，主要是提示去传入长度为2的数组，这个数组会保存文件描述符返回，由此可操纵匿名管道The array pipefd is used to return two file descriptors referring to the ends of the pipe.pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the  write  end  of  the  pipe.Data  written  to  the  write  end of the pipe is buffered by the kernel until it is read from the read end of the pipe.     


配合fork()一起使用，fork()出的两个进程是共享文件对象的，而用户态资源又是全部拷贝的
这样父子进程分别拥有用于描述匿名管道读端，写端文件对象的文件描述符，各自关闭一端就能实现半双工通信，两根管道各自关闭一端就能实现全双工通信。(显然，这样的特性是依赖与fork()实现的)

示例"> 
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Unix-Linux-Process-进程间通信"/>
  <meta property="og:site_name" content="lacsscal&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="lacsscal&#39;s blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.0.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">lacsscal&#39;s blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Unix-Linux-Process-进程间通信</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h2 id="进程间通信-IPC-Inter-Process-Communication"><a href="#进程间通信-IPC-Inter-Process-Communication" class="headerlink" title="进程间通信 IPC:Inter Process Communication"></a>进程间通信 IPC:Inter Process Communication</h2><blockquote>
<p>分别从几种进程间通信机制总结，每个机制可能搭配几个相关函数或系统调用的手册信息和一个或几个小例程，分析一下各种机制的特点。</p>
</blockquote>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><blockquote>
<p>之前用过命令创建的有名管道, 也能在程序中创建管道。在<code>fork()</code>的基础上还能使用匿名管道。</p>
</blockquote>
<p><code>POPEN(3) PCLOSE(3)</code>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line">                         |</span><br><span class="line">                     底层实现是fork()+exec()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">用的不多，意义不大, fork+匿名管道pipe可能更常用一点</span><br></pre></td></tr></table></figure>

<p><code>PIPE(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line">                 |</span><br><span class="line">               传参时退化为指针，主要是提示去传入长度为<span class="number">2</span>的数组，这个数组会保存文件描述符返回，由此可操纵匿名管道</span><br><span class="line">The <span class="built_in">array</span> pipefd is used to <span class="keyword">return</span> two file descriptors referring to the ends of the pipe.</span><br><span class="line">pipefd[<span class="number">0</span>] refers to the read end of the pipe.  pipefd[<span class="number">1</span>] refers to the  write  end  of  the  pipe.</span><br><span class="line">Data  written  to  the  write  end of the pipe is buffered by the kernel until it is read from the read end of the pipe.     </span><br></pre></td></tr></table></figure>

<blockquote>
<p>配合<code>fork()</code>一起使用，<code>fork()</code>出的两个进程是共享文件对象的，而用户态资源又是全部拷贝的</p>
<p>这样父子进程分别拥有用于描述匿名管道读端，写端文件对象的文件描述符，各自关闭一端就能实现半双工通信，两根管道各自关闭一端就能实现全双工通信。(显然，这样的特性是依赖与fork()实现的)</p>
</blockquote>
<p><code>示例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让父进程打开文件file1，读取其内容，通过管道发送给子进程，而子进程将内容写入到文件file2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./pipe2 file1 file2</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> fds1[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> fds2[<span class="number">2</span>];</span><br><span class="line">    pipe(fds1);</span><br><span class="line">    pipe(fds2);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程 父读子写 关闭父的写子的读</span></span><br><span class="line">        close(fds1[<span class="number">1</span>]);</span><br><span class="line">        close(fds2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> fd2 = open(argv[<span class="number">2</span>], O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(read(fds1[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// puts(buf);</span></span><br><span class="line">            write(fd2, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// read(fds1[0], buf, sizeof(buf));</span></span><br><span class="line">        <span class="comment">// puts(buf);</span></span><br><span class="line">        <span class="comment">// write(fds2[1], &quot;hello i am child&quot;, 17);</span></span><br><span class="line">        close(fd2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程 父写子读 关闭父的读 子的写</span></span><br><span class="line">        close(fds1[<span class="number">0</span>]);</span><br><span class="line">        close(fds2[<span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">int</span> fd1 = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(read(fd1, buf, <span class="keyword">sizeof</span>(buf)) != <span class="number">0</span>)&#123;</span><br><span class="line">            write(fds1[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write(fds1[1], &quot;i am parent\n&quot;, 13);   </span></span><br><span class="line">        <span class="comment">// char buf[1024];</span></span><br><span class="line">        <span class="comment">// read(fds2[0], buf, sizeof(buf));</span></span><br><span class="line">        <span class="comment">// puts(buf);</span></span><br><span class="line">        close(fds1[<span class="number">1</span>]);</span><br><span class="line">        close(fd1);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MIFIFO(3)   创建有名管道</p>
<p>UNLINK(2)  删除文件(删除的本质是:接触数据与文件系统的连接—数据不一定被销毁)</p>
<p>RENAME(2)  移动文件</p>
<p>LINK(2) 创建硬链接</p>
</blockquote>
<h3 id="2-共享内存"><a href="#2-共享内存" class="headerlink" title="2. 共享内存"></a>2. 共享内存</h3><blockquote>
<p>基于system V 版本的系统调用  $ipcs </p>
</blockquote>
<blockquote>
<p>使用步骤 </p>
<p>——&gt;通过文件使用<code>FTOK(3)</code>得到一个shmid（是个数字）或者自定义一个数字也可(此数字识别不同的IPC机制?同一个数字可能串号冲突?)</p>
<p>——&gt; <code>SHMGET(2)</code>生成共享内存</p>
<p>——&gt; <code>SHMAT(2)</code>将共享内存映射到虚拟地址空间(申请到的共享内存是物理内存，但想要使用它必须先映射) </p>
<p>——&gt; 之后类似malloc申请到的空间一样操作它即可  </p>
<p>——&gt; 分配在堆区 用<code>SHMDT(2)</code>释放 并用·<code>shmctl(shmid,IPC_RMID,NULL);</code>删除</p>
</blockquote>
<p><code>FTOK(3)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SHMGET(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SHMOP(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SHMOP(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SHMCTL(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>示例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./fhm file</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(argv[<span class="number">1</span>], <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;Hou are you&quot;</span>);</span><br><span class="line">    <span class="comment">// puts(p);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//创建并写入</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./shm_r file1 用同一个文件创建的key相同</span></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(argv[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>); </span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">int</span> ret = shmdt(p);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;shmadt&quot;</span>);</span><br><span class="line">    <span class="comment">// while(1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个独立进程同时对一个共享内存去访问修改，可能造成竞争条件的出现race condition 由此可以引出信号量作为互斥机制</p>
</blockquote>
<blockquote>
<p>竞争条件:并发的执行流对共享资源的访问会导致竞争条件(进程是默认隔离的，所以出现概率比较低)</p>
</blockquote>
<p><code>竞争条件举例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">父子进程各自对共享内存变量加一千万，结果不是两千万</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(IPC_PRIVATE, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmid&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//取4字节存整数</span></span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span> *)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            ++*p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            ++*p;</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./shm_fork </span><br><span class="line">*p = <span class="number">18630024</span></span><br></pre></td></tr></table></figure>



<h3 id="3-信号量-以二元信号量为主"><a href="#3-信号量-以二元信号量为主" class="headerlink" title="3. 信号量(以二元信号量为主)"></a>3. 信号量(以二元信号量为主)</h3><blockquote>
<p>由上例中引出的竞争条件，分析其原因，<code>++*p;</code>这条指令在汇编层与机器层是更细化的 大概能分作三步(读取值，计算值，写回值)，如果中途被打断，可能会使得计算(访存)时所用的(得到的)并非最新值</p>
<p>想要解决这种情况需要有一种机制使的这三步要么不做，要么一次做完。比如原子操作，比如信号量。</p>
</blockquote>
<blockquote>
<p>信号量是描述资源数量的整数 &lt;= 0 : 资源不可用   &gt; 0 : 资源可用</p>
<p>PV操作 P:测试并加锁，V:释放并解锁 PV之间访问临界资源(这部分代码叫”临界区”)</p>
</blockquote>
<blockquote>
<p>使用步骤 </p>
<p>——&gt; <code>SEMGET(2)</code>获取信号量</p>
<p>——&gt;用·<code>semctl(semid, 数组下标, 行为, ....);</code>操作信号， 一般先设初值<code>semctl(semid, 0, SETVAL, 1);</code></p>
<p>——&gt;定义PV操作</p>
<p>——&gt;在需要加锁的地方调用<code>SEMOP(2)</code></p>
</blockquote>
<p><code>SEMGET(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SEMCTL(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SEMOP(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nsops)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>使用示例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用二元信号量，让两个进程对同一个数各加1千万次之后，最终每次执行结果都是2千万，看一下需要耗时多长时间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//准备共享内存,四个字节存加的数</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="comment">//准备二元信号量</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;semctl&quot;</span>);</span><br><span class="line">    <span class="comment">//设置PV操作 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>; <span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="comment">//计算耗时，使用gettimeofday</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">begTime</span>, <span class="title">endTime</span>;</span></span><br><span class="line">    gettimeofday(&amp;begTime, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//完成准备工作，生成两个进程</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            ++*p;</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            ++*p;</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        gettimeofday(&amp;endTime, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total microseconds = %ld\n&quot;</span>, (endTime.tv_sec - begTime.tv_sec)*<span class="number">1000000</span> + endTime.tv_usec - begTime.tv_usec);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/test$ ./pv</span><br><span class="line">*p = <span class="number">20000000</span></span><br><span class="line">Total microseconds = <span class="number">32416265</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>题外话 : dekker算法 伪代码与实现; 计数信号量; ......</code></p>
<p><code>伪代码</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># dekker算法的基本思路</span><br><span class="line">    variables</span><br><span class="line">        wants_to_enter : array of 2 booleans</span><br><span class="line">        turn : integer</span><br><span class="line"></span><br><span class="line">    wants_to_enter[0] ← false</span><br><span class="line">    wants_to_enter[1] ← false</span><br><span class="line">    turn ← 0   // or 1</span><br><span class="line"># p0</span><br><span class="line">p0:</span><br><span class="line">   wants_to_enter[0] ← true</span><br><span class="line">   while wants_to_enter[1] &#123;</span><br><span class="line">      if turn ≠ 0 &#123;</span><br><span class="line">         wants_to_enter[0] ← false</span><br><span class="line">         while turn ≠ 0 &#123;</span><br><span class="line">           // busy wait</span><br><span class="line">         &#125;</span><br><span class="line">         wants_to_enter[0] ← true</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // critical section</span><br><span class="line">   ...</span><br><span class="line">   turn ← 1</span><br><span class="line">   wants_to_enter[0] ← false</span><br><span class="line">   // remainder section</span><br><span class="line"># p1</span><br><span class="line">p1:</span><br><span class="line">   wants_to_enter[1] ← true</span><br><span class="line">   while wants_to_enter[0] &#123;</span><br><span class="line">      if turn ≠ 1 &#123;</span><br><span class="line">         wants_to_enter[1] ← false</span><br><span class="line">         while turn ≠ 1 &#123;</span><br><span class="line">           // busy wait</span><br><span class="line">         &#125;</span><br><span class="line">         wants_to_enter[1] ← true</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // critical section</span><br><span class="line">   ...</span><br><span class="line">   turn ← 0</span><br><span class="line">   wants_to_enter[1] ← false</span><br><span class="line">   // remainder section</span><br></pre></td></tr></table></figure>

<p><code>dekker 实现+20000000</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(IPC_PRIVATE, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmid&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//算值</span></span><br><span class="line">    p[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">//wants_to_enter[0] false 两个标志</span></span><br><span class="line">    p[<span class="number">2</span>] = <span class="literal">false</span>; <span class="comment">//wants_to_enter[1]</span></span><br><span class="line">    p[<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">//turn轮转</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            <span class="comment">//p0</span></span><br><span class="line">            p[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//子进程的flag</span></span><br><span class="line">            <span class="keyword">while</span>(p[<span class="number">2</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">3</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">                    p[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">//1号标志false</span></span><br><span class="line">                    <span class="keyword">while</span>(p[<span class="number">3</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//busy wait</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    p[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++*p;</span><br><span class="line">            p[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">            p[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//p1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            p[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(p[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">3</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                    p[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">while</span>(p[<span class="number">3</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">            ++*p;</span><br><span class="line">            p[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            p[<span class="number">2</span>] = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);   </span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/test/$ make</span><br><span class="line">gcc  dekker.c -o dekker -g -O0</span><br><span class="line">scallacs@scallacs:~/test$ ./dekker  </span><br><span class="line">*p = <span class="number">20000000</span>  单核</span><br><span class="line">[ubuntu@VM<span class="number">-16</span><span class="number">-8</span>-ubuntu ~/linux/\ []$ ./dekker </span><br><span class="line">*p = <span class="number">19899008</span>  双核 会受到核心数影响，单核时表现完美</span><br></pre></td></tr></table></figure>

<p><code>计数信号量 + 生产者消费者问题</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1002</span>, <span class="number">2</span>,IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="comment">// unsigned short  *array;  /* Array for GETALL, SETALL */ 要使用SETALL初始化</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> arr[] = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;; <span class="comment">//arr[0]&lt;-&gt;商品  arr[1]&lt;-&gt;货仓 初始货仓摆满商品</span></span><br><span class="line">    <span class="keyword">int</span> ret = semctl(semid, <span class="number">0</span>, SETALL, arr);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;semctl setall&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出看看是否初始化成功，增量编程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sem[0] = %d, sem[1] = %d\n&quot;</span>, semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">    <span class="comment">// 设置信号量做PV操作, 先设定操作的行为,针对两种资源使用信号量集合</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">produce</span>[2];</span><span class="comment">//produce[0]:商品 produce[1]:货仓?</span></span><br><span class="line">    produce[<span class="number">0</span>].sem_num = <span class="number">0</span>;</span><br><span class="line">    produce[<span class="number">0</span>].sem_op = <span class="number">1</span>; <span class="comment">//商品+1</span></span><br><span class="line">    produce[<span class="number">0</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    produce[<span class="number">1</span>].sem_num = <span class="number">1</span>;</span><br><span class="line">    produce[<span class="number">1</span>].sem_op = <span class="number">-1</span>;</span><br><span class="line">    produce[<span class="number">1</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">consume</span>[2];</span><span class="comment">//consume[0]:商品 consume[1]:货仓</span></span><br><span class="line">    consume[<span class="number">0</span>].sem_num = <span class="number">0</span>;</span><br><span class="line">    consume[<span class="number">0</span>].sem_op = <span class="number">-1</span>; <span class="comment">//商品-1</span></span><br><span class="line">    consume[<span class="number">0</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    consume[<span class="number">1</span>].sem_num = <span class="number">1</span>;</span><br><span class="line">    consume[<span class="number">1</span>].sem_op = <span class="number">1</span>;</span><br><span class="line">    consume[<span class="number">1</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="comment">// 启动父子进程分别作为生产者和消费者</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// sleep(1);//如果交换睡眠时间会一直显示&#123;5, 0&#125;消费太慢</span></span><br><span class="line">            usleep(<span class="number">500000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am consumer, before consume, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">            <span class="comment">// semop(semid,consume,2);//这个操作会影响到2个资源 </span></span><br><span class="line">            semop(semid, &amp;consume[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consumer buy a product\n&quot;</span>);</span><br><span class="line">            semop(semid, &amp;consume[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am consumer, after consume, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// usleep(500000);</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am producer, before produce, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">            <span class="comment">// semop(semid,produce,2);//这个操作会影响到2个资源 </span></span><br><span class="line">            semop(semid, &amp;produce[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;produce a product\n&quot;</span>);</span><br><span class="line">            semop(semid, &amp;produce[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am producer, after produce, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./produceAndConsume </span><br><span class="line">sem[<span class="number">0</span>] = <span class="number">5</span>, sem[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am producer, before produce, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">produce a product</span><br><span class="line">i am producer, after produce, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">i am producer, before produce, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">produce a product</span><br><span class="line">i am producer, after produce, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">2</span>, space = <span class="number">3</span></span><br><span class="line">i am producer, before produce, product = <span class="number">2</span>, space = <span class="number">3</span></span><br></pre></td></tr></table></figure>



<h3 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4.消息队列"></a>4.消息队列</h3><blockquote>
<p>这里使用的是狭义的消息队列(广义的消息队列:网络消息中间件)， 这里的是面向消息的进程间通信机制</p>
<p>使用流程与前二者类似</p>
<p>——&gt; <code>MSGGET(2)</code>获取消息队列</p>
<p>——&gt; <code>MSGSND(2)</code> 发</p>
<p>——&gt; <code>MSGRCV(2)</code> 收</p>
<p>后面综合使用时演示</p>
</blockquote>
<p><code>MSGGET(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>MSGSND(2)</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p> <code>MSGRCV(2)</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="5-信号"><a href="#5-信号" class="headerlink" title="5. 信号"></a>5. 信号</h3><blockquote>
<p>进程间异步通信机制(软件层面的，异步:不知道什么时候有信号来;管道是同步的:先写再读)</p>
<p>信号分为产生 递送(对某个进程施加影响(处理信号))两个阶段</p>
<p><code>kill -l </code>列出所有信号 共有64个 每种信号对应一个整数</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">递送信号发生了什么(递送信号的默认行为)(收到信号的默认行为:是可以通过注册信号改变这些行为的)</span><br><span class="line">Each signal has a current disposition, <span class="built_in">which</span> determines how the process behaves when it is delivered the signal.</span><br><span class="line"></span><br><span class="line">The entries <span class="keyword">in</span> the <span class="string">&quot;Action&quot;</span> column of the table below specify the default disposition <span class="keyword">for</span> each signal, as follows:</span><br><span class="line">      Term   Default action is to terminate the process.  终止进程 Ctrl C</span><br><span class="line">      Ign    Default action is to ignore the signal. 忽略信号<span class="built_in">wait</span>()的实现原理 SIGCHILD 告知父进程可以回收</span><br><span class="line">      Core   Default action is to terminate the process and dump core (see core(5)). 终止生成并core文件 Ctrl \ </span><br><span class="line">      Stop   Default action is to stop the process. 暂停 Ctrl Z</span><br><span class="line">      Cont   Default action is to <span class="built_in">continue</span> the process <span class="keyword">if</span> it is currently stopped. 恢复<span class="built_in">bg</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>将递送信号时的默认行为改变为自己定义的行为<code>SIGNAL(2)</code>(更改递送信号时的默认行为:可以实现进程的有序退出)</p>
<p>递送信号的本质 是 修改被递送信号的进程的task_struct （[注]9号信号的默认行为不能改）</p>
</blockquote>
<blockquote>
<p>执行流程如下图所示，在进程执行过程中受到信号，CPU的使用权移交给信号产生者，它会要求进程调用预定义的回调函数handler()，将这个信号的默认行为使用handler()定义的行为取代，函数接口如下</p>
</blockquote>
<p><code>SIGNAL(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line">                                              |-&gt;注册一个handler</span><br><span class="line">把系统信号的递送行为改为自己注册的行为</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.png" alt="回调函数的执行"></p>
<blockquote>
<p>如果有多个信号同时递送，会发现这么一种现象，有的递送行为没有执行，分析会发现，相同信号的递送会有如下现象</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BF%A1%E5%8F%B7%E9%80%92%E9%80%81.png" alt="信号递送"></p>
<blockquote>
<p>Q:那么为什么 多余的信号会被丢弃</p>
<p>A:这涉及两个结构体 <code>mask </code> <code>掩码，表示是否阻塞 pending   </code>未决信号集，表示是否有未决信号 它们都是位图实现的</p>
<p>所以在递送X信号时，会将mask的X置为1(递送结束恢复为0)(信号递送过程中把自己阻塞:把自己加入mask)—-&gt;当新信号产生，若这个信号也是X，查询mask发现其中有自己，那就把自己加入pending(对应位置1)—–&gt;再有一个X产生，同样的流程，但因为底层实现是位图pending只能保存一个，所以它被丢弃。</p>
<p>类似的，如果第三个信号是个新的，且mask中没它，就会转而执行新信号的递送…….</p>
</blockquote>
<blockquote>
<p>signal系统调用也存在一些缺陷，它的很多特性是写死的，比如递送X信号时会将X加入mask因此还有更好用的系统调用</p>
</blockquote>
<p><code>SIGACTION(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>用法示例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;<span class="comment">//指定不把自己加入mask,可反复切换，没使用SIGINFO指定为单参数版本的handler</span></span><br><span class="line">    act.sa_handler = handler; <span class="comment">//指定回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用sigaction注册信号 注册2号3号信号执行handler以来回打断</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGQUIT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./sigaction </span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">Killed</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后续，这些进程间通信机制都用的比较少，有更好的实现方案</p>
<p>用网络取代管道，用线程取代共享内存，用互斥锁取代信号量(当然，信号是比较独特的进程间通信机制，用到时再复盘)</p>
</blockquote>
<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1>
	  <div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>

	</div>

	
	<span id="/2022/03/02/009.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/" class="leancloud-visitors view" data-flag-title="Unix-Linux-Process-进程间通信">
		<em class="post-meta-item-text"> Page View </em> <i class="leancloud-visitors-count"></i>
	</span>
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a href="/2022/03/02/009.应用-聊天程序/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2022/02/26/008.Unix-Linux.FileManagement/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>

-->
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2022-03-02 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/Unix-Linux/">Unix/Linux<span>7</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2022 chen's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
