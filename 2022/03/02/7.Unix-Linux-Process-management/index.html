<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Unix-Linux-Process-management | lacsscal&#39;s blog</title>
  <meta name="author" content="chen">
  
  <meta name="description" content="序go on
正文一、进程基础0.概念
程序：静态文件，二进制指令和数据的集合，存储在磁盘中
进程：程序的动态执行过程，资源分配的基本单位(占CPU资源以执行程序指令，占存储资源以保存状态(数据段，代码段，堆…))，进程是处于执行器的程序和相关资源的总称。(同一份静态程序，可以启动多个不同进程).以进程的视角来看，它是独占CPU的，同时它也是独占内存空间的。以进程视角看到的内存空间称为虚拟内存空间。如下图所示。
[注]在内核态空间里面，与进程相关的数据结构是每个进程都不同的，物理存储器和内核代码数据是所有进程共享的。内核进程通常被成为内核线程，因为它们没有自己的独立地址空间，它们永远运行在内核态空间或者说它们本身就是内核的一部分。



Linux开机:(ROM中存有自举程序，计算机加电，CPU的PC置为自举程序的第一条指令，这个程序的唯一职责是把OS本身(至少是启动计算机的那部分)装入内存)主要关注进程的话，略过这些细节，在所有硬件配置好的情况下，这时bootloader程序会启动0号进程。0号进程会配置实时时钟，它的主要工作是启动1号进程(init,新版中被systemd取代)和2号进程(页面守护进程),0号进程在启动完1号2号进程后终止(后面OS会再重启一个0号进程，但功能完全不同，它是idel空闲进程PID:0, 因为CPU总要选择一个进程运行，所以没活干的时候让CPU运行idel进程以省电。1号进程是其他所有用户进程的祖先, 2号进程是其他内核线程的祖先内核进程不占用户虚拟地址，也称做用户线程

1.一些库函数和系统调用GETPID(2)"> 
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Unix-Linux-Process-management"/>
  <meta property="og:site_name" content="lacsscal&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="lacsscal&#39;s blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.0.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">lacsscal&#39;s blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Unix-Linux-Process-management</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、进程基础"><a href="#一、进程基础" class="headerlink" title="一、进程基础"></a>一、进程基础</h2><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0.概念"></a>0.概念</h3><blockquote>
<p>程序：静态文件，二进制指令和数据的集合，存储在磁盘中</p>
<p>进程：程序的动态执行过程，资源分配的基本单位(占CPU资源以执行程序指令，占存储资源以保存状态(数据段，代码段，堆…))，进程是处于执行器的程序和相关资源的总称。(同一份静态程序，可以启动多个不同进程).以进程的视角来看，它是独占CPU的，同时它也是独占内存空间的。以进程视角看到的内存空间称为虚拟内存空间。如下图所示。</p>
<p>[注]在内核态空间里面，与进程相关的数据结构是每个进程都不同的，物理存储器和内核代码数据是所有进程共享的。内核进程通常被成为内核线程，因为它们没有自己的独立地址空间，它们永远运行在内核态空间或者说它们本身就是内核的一部分。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%9B%B4%E7%BB%86%E5%8C%96%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.jpg" alt="更细化恶虚拟内存空间"></p>
<blockquote>
<p>Linux开机:(ROM中存有自举程序，计算机加电，CPU的PC置为自举程序的第一条指令，这个程序的唯一职责是把OS本身(至少是启动计算机的那部分)装入内存)主要关注进程的话，略过这些细节，在所有硬件配置好的情况下，<strong>这时bootloader程序会启动0号进程。0号进程会配置实时时钟，它的主要工作是启动1号进程(init,新版中被systemd取代)和2号进程(页面守护进程)</strong>,0号进程在启动完1号2号进程后终止(后面OS会再重启一个0号进程，但功能完全不同，它是idel空闲进程PID:0, 因为CPU总要选择一个进程运行，所以没活干的时候让CPU运行idel进程以省电。<strong>1号进程是其他所有用户进程的祖先, 2号进程是其他内核线程的祖先</strong>内核进程不占用户虚拟地址，也称做用户线程</p>
</blockquote>
<h3 id="1-一些库函数和系统调用"><a href="#1-一些库函数和系统调用" class="headerlink" title="1.一些库函数和系统调用"></a>1.一些库函数和系统调用</h3><p><code>GETPID(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>GETPPID(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>GETUID(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>GETEUID(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>GETGID(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>GETEGID(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这些信息的基础上，要清晰一些概念，进程是动态的，当进程启动后，<strong>启动者的权限和属性</strong>以及程序的指令和数据会加载到内存中，为了方便普通用户定位进程，操作系统会为进程分配唯一正整数标识符PID，进程之间存在亲缘关系(pid, ppid)。为了方便内核进行进程的权限管理，默认进程拥有启动用户的身份(uid, gid)。<strong>内核对进程进行访问权限检查是，检查的是euid, egid</strong>默认与uid,gid相同。</p>
<p>下面用这些基础概念和系统调用探究一下<code>$passwd</code>的实现原理</p>
</blockquote>
<h3 id="2-passwd的实现原理与特殊权限管理"><a href="#2-passwd的实现原理与特殊权限管理" class="headerlink" title="2. $passwd的实现原理与特殊权限管理"></a>2. <code>$passwd</code>的实现原理与特殊权限管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scallacs@scallacs$ ll /etc/shadow </span><br><span class="line">-rw-r----- 1 root shadow 1.5K Feb 28 19:51 /etc/shadow</span><br></pre></td></tr></table></figure>

<blockquote>
<p>密码存在/etc/shadow 中，该文件的所有者为root,所属组为shadow，照这样用常规思路来想，用户在不是root或b不在shadow组的情况下是不能修改shadow的，甚至在shadow组中也只有读权限。</p>
<p>Q：那么：为什么普通用户使用passwd命令能成功修改密码?</p>
<p>A：显然普通用户在执行passwd时，获取了/etc/shadow的写权限，也就是说此时普通用户的euid是root。（前文讲到:内核对进程进行访问权限检查是，检查的是euid)。也就是说，存在这样一种机制，使得用户在运行某进程时修改自己的euid或egid.</p>
<p>Q：想一想还有没有类似的命令，运行时可以做到本身权限不能做到的事情</p>
<p>A：sudo</p>
<p>那么，获取一下这两个命令可执行文件的信息，看看有无什么特殊之处</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scallacs@scallacs$ <span class="built_in">which</span> sudo</span><br><span class="line">/usr/bin/sudo</span><br><span class="line">scallacs@scallacs$ ll /usr/bin/sudo</span><br><span class="line">-rwsr-xr-x 1 root root 146K Jan 19  2021 /usr/bin/sudo</span><br><span class="line">scallacs@scallacs$ ll /usr/bin/passwd  </span><br><span class="line">-rwsr-xr-x 1 root root 59K Jan 26 00:26 /usr/bin/passwd</span><br><span class="line">   |</span><br><span class="line">  s权限</span><br></pre></td></tr></table></figure>

<blockquote>
<p>它们都有s权限</p>
</blockquote>
<blockquote>
<p>文件的特殊权限：</p>
<p>在此前的9位普通权限的基础上，还有三位特殊权限，</p>
<p>针对所有者权限有SUID，用于在程序运行中修改自己的euid为文件所有者。</p>
<p>类似的针对所属组有SGID，用于修改自己的egid为文件所属组。</p>
<p>对于目录文件，可以使用sticky bit(SBIT)权限限制用户协同工作时的一些操作。比如/tmp</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxrwt  18 root root  12K Mar  2 20:28 tmp </span><br><span class="line">         |</span><br><span class="line">       sticky bit 对目录有写权限，但不能删除其他用户的文件</span><br></pre></td></tr></table></figure>

<p><code>应用举例：SUID SGID</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">A用户编写一个程序，用来往file文件中写入内容hello，然后编译后，增加s权限，这时B用户执行该程序，能够往file文件中写入hello。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./write file</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用户A执行</span><br><span class="line">scallacs@scallacs:~/test/$ ./write file</span><br><span class="line">scallacs@scallacs:~/test/$ cat file </span><br><span class="line">hello</span><br><span class="line">用户A为程序增加suid权限</span><br><span class="line">scallacs@scallacs:~/test/$ chmod u+s write</span><br><span class="line">scallacs@scallacs:~/test/$ ls -l write</span><br><span class="line">-rwsrwxr-x <span class="number">1</span> scallacs scallacs <span class="number">8496</span> Feb <span class="number">28</span> <span class="number">20</span>:<span class="number">23</span> write</span><br><span class="line">   |</span><br><span class="line">  所有者有s权限</span><br><span class="line">先把文件清空</span><br><span class="line">scallacs@scallacs:~/test/$ echo -n &gt; file </span><br><span class="line">    </span><br><span class="line">切到用户B 执行</span><br><span class="line">scallacs@scallacs:~/test/$ su test</span><br><span class="line">Password: </span><br><span class="line">[test@scallacs /home/scallacs/test/\[]$ ./write file</span><br></pre></td></tr></table></figure>

<h3 id="3-使用系统调用创建进程-由可执行程序启动多个进程"><a href="#3-使用系统调用创建进程-由可执行程序启动多个进程" class="headerlink" title="3.使用系统调用创建进程(由可执行程序启动多个进程)"></a>3.使用系统调用创建进程(由可执行程序启动多个进程)</h3><p><code>system(3)</code></p>
<blockquote>
<p>之前使用过这个库函数，它是可以执行系统命令的比如<code>system(&quot;cls&quot;);</code>，也就是说它启动了另外的进程，可以使用<code>ps</code>命令看一下。会发现它创建了3个进程，并且3个进程之间存在父子亲缘关系。那么它的原理是什么，man一下它的手册</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The  <span class="title">system</span><span class="params">()</span>  library  function  uses <span class="title">fork</span><span class="params">(<span class="number">2</span>)</span> to create a child process</span></span><br><span class="line"><span class="function">that executes the shell command specified in command <span class="keyword">using</span>  <span class="title">execl</span><span class="params">(<span class="number">3</span>)</span>  as follows:</span></span><br><span class="line"><span class="function">	   <span class="title">execl</span><span class="params">(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, (<span class="keyword">char</span> *) <span class="number">0</span>)</span></span>;</span><br><span class="line">system() returns after the command has been completed.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>system()</code> 使用 <code>fork()</code>和<code>execl()</code>实现</p>
</blockquote>
<p><code>fork(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>fork的原理(先引入几个概念)</p>
<p>中断：硬件发送信息给CPU，CPU通知OS处理中断事宜.</p>
<p>异常：类似中断的概念，进程主动给CPU发消息(软件中断)，在x86体系,系统调用利用软中断实现(这个软中断叫<strong>陷入</strong>)</p>
<p>[注]OS对中断和异常的处理流程是一致的，除了信息的来源不同。</p>
<p>中断的上半部 下半部….</p>
</blockquote>
<blockquote>
<p>通过 fork 创建的子进程，它从父进程继承了进程的地址空间，包括进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设定、进程优先级、进程组ID、当前工作目录、根目录、资源限制、控制终端，而子进程所独有的只有它的进程ID、资源使用和计时器等。</p>
<p>子进程与父进程是clone与被clone的关系，在这种情况下，子进程可能会<em>认为自己</em>是**调用fork()**的那个人，因此以返回值区分子进程与父进程，子进程返回0，父进程返回子进程的PID。这样，用一个选择结构就可以让父子进程执行不同的操作。</p>
</blockquote>
<p><code>fork的基本用法</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child, pid = %d, ppid = %d\n&quot;</span>,</span><br><span class="line">            getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent, pid = %d, ppid = %d\n&quot;</span>,</span><br><span class="line">            getpid(),getppid());</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>fork()的写时复制</p>
<p>当执行了 fork 了以后，父子进程地址空间的内容是完全一致，所以完全可以共享同一片物理内存，也就是父子进程的同一个虚拟地址会对应同一个物理内存字节。通常来说，内存的分配单位是页，我们可以为每一个内存页维持一个引用计数。代码段的部分因为只读，所以完全可以多个进程同时共享。而对于地址空间的其他部分，当进程对某个内存页进行写入操作的时候，我们再真正执行被修改的虚拟内存页分配物理内存并拷贝数据，这就是所谓的<strong>写时复制</strong>。在执行拷贝以后，同样的虚拟地址就无法对应同样物理内存字节了。如下图所示</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/fork%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png"></p>
<blockquote>
<p>fork()刚创建出子进程以及父子进程只进行读操作都不会影响物理内存，二者共享同一片物理内存即可，但一旦有写操作发生，未改变的进程就需要拷贝原物理页，并分配新的物理页。* Copy On Write.*</p>
<p>[注]内核态地址空间拷贝和用户态会有所区别。 fork 产生的子进程会拷贝一份文件描述符数组，但是通过文件描述符所指向的文件对象是共享的。这种拷贝方式类似于 dup 系统调用，所以父子进程对同一个文件对象会共享读写位置</p>
<p>共享文件对象&lt;=&gt;共享内核文件缓冲区的偏移</p>
</blockquote>
<p><code>关于共享文件对象的思考</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">程序一共输出多少个“-”</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			fork();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">共打印<span class="number">8</span>个，<span class="built_in">printf</span>()格式串中没有\n 输出放到<span class="built_in">stdout</span>:行缓冲</span><br><span class="line">第一次循环fork创建一个子进程 父子进程<span class="built_in">stdout</span>中各有一个 <span class="string">&#x27;-&#x27;</span></span><br><span class="line">第二次循环各自创建一个子进程 一个四个进程用户空间信息一致，再执行<span class="built_in">printf</span>各自放入一个<span class="string">&#x27;-&#x27;</span></span><br><span class="line">程序结束 全部打印 一共<span class="number">8</span>个</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">把<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>)换成<span class="built_in">printf</span>(<span class="string">&quot;-\n&quot;</span>)；程序会输出多少个“-”?思考一下为什么？</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-\n&quot;</span>);<span class="comment">//共打印6个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">共打印<span class="number">6</span>个</span><br><span class="line">第一次循环fork创建一个子进程 父子进程各向<span class="built_in">stdout</span>输出一个 <span class="string">&#x27;-&#x27;</span>，然后<span class="built_in">stdout</span>空了</span><br><span class="line">第二次循环各自创建一个子进程 一个四个进程用户空间信息一致都是空的，再执行<span class="built_in">printf</span>各自输出一个<span class="string">&#x27;-&#x27;</span></span><br><span class="line">程序结束 全部打印 一共<span class="number">6</span>个</span><br></pre></td></tr></table></figure>



<p><code>execl(3)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>exec(execute)用在 fork 之后，将子进程的指令部分进行替换修改。当进程执行到 exec* 系统调用的时候，它会将传入的指令来取代进程本身的代码段、数据段、栈和堆，然后将PC指针重置为新的代码段的入口。</p>
</blockquote>
<p><code>示例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过execl拉起来一个进程，传递两个数字，比如15和65。被拉起的进程创建一个随机数，该随机数的范围在15-65之间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    execl(<span class="string">&quot;random&quot;</span>, <span class="string">&quot;./random&quot;</span>, <span class="string">&quot;15&quot;</span>, <span class="string">&quot;56&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个随机数，该随机数的范围在15-65之间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./add 15 56</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> lhs = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> rhs = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> rand = random()%(rhs - lhs + <span class="number">1</span>);</span><br><span class="line">    rand += lhs;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the random num = %d\n&quot;</span>, rand);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>使用fork 与execl实现system</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个mysystem程序，实现跟system函数类似的功能（只需要创建一个子进程）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySystem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//解析command 以space分割</span></span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> *args[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, command); </span><br><span class="line">        <span class="comment">// puts(str);</span></span><br><span class="line">        <span class="keyword">char</span> *word = strtok(str, <span class="string">&quot; &quot;</span>); </span><br><span class="line">        <span class="comment">// puts(word); </span></span><br><span class="line">        args[<span class="number">0</span>] = word;<span class="comment">//之前试图用strcpy函数写，写不进去? 遇到没显示的地方可能是访问空指针导致段错误了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((word = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// puts(word);</span></span><br><span class="line">            args[i] = word;<span class="comment">//操作数组小心越界问题 对于子进程的gdb调试方法 set follow-fork-mode child</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// execl(&quot;random&quot;, &quot;./random&quot;, &quot;15&quot;, &quot;56&quot;, NULL);</span></span><br><span class="line">        execv(<span class="string">&quot;random&quot;</span>, args);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system(&quot;./random 15 56&quot;); //传进一个命令，起一个shell，执行它</span></span><br><span class="line">    mySystem(<span class="string">&quot;./random 15 56&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>WAIT(2)</code></p>
<blockquote>
<p>进程结束后的资源回收问题 : 真正回收资源的系统调用</p>
<p>而由资源回收问题会引出–孤儿进程， 僵尸进程等概念</p>
<p>子进程资源一定由父进程回收，若是父进程在子进程终止前终止，此时的子进程是孤儿进程 <code>orphan</code>， 当子进程终止，父进程正忙，无法帮助子进程回收资源，或父进程一直没执行<code>wait</code>，此时子进程是僵尸进程</p>
<p>…….</p>
</blockquote>
<p><code>一堆多进程管理的概念........</code></p>
<h2 id="二、进程间通信-IPC-Inter-Process-Communication"><a href="#二、进程间通信-IPC-Inter-Process-Communication" class="headerlink" title="二、进程间通信 IPC:Inter Process Communication"></a>二、进程间通信 IPC:Inter Process Communication</h2><blockquote>
<p>分别从几种进程间通信机制总结，每个机制可能搭配几个相关函数或系统调用的手册信息和一个或几个小例程，分析一下各种机制的特点。</p>
</blockquote>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><blockquote>
<p>之前用过命令创建的有名管道, 也能在程序中创建管道。在<code>fork()</code>的基础上还能使用匿名管道。</p>
</blockquote>
<p><code>POPEN(3) PCLOSE(3)</code>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line">                         |</span><br><span class="line">                     底层实现是fork()+exec()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">用的不多，意义不大, fork+匿名管道pipe可能更常用一点</span><br></pre></td></tr></table></figure>

<p><code>PIPE(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line">                 |</span><br><span class="line">               传参时退化为指针，主要是提示去传入长度为<span class="number">2</span>的数组，这个数组会保存文件描述符返回，由此可操纵匿名管道</span><br><span class="line">The <span class="built_in">array</span> pipefd is used to <span class="keyword">return</span> two file descriptors referring to the ends of the pipe.</span><br><span class="line">pipefd[<span class="number">0</span>] refers to the read end of the pipe.  pipefd[<span class="number">1</span>] refers to the  write  end  of  the  pipe.</span><br><span class="line">Data  written  to  the  write  end of the pipe is buffered by the kernel until it is read from the read end of the pipe.     </span><br></pre></td></tr></table></figure>

<blockquote>
<p>配合<code>fork()</code>一起使用，<code>fork()</code>出的两个进程是共享文件对象的，而用户态资源又是全部拷贝的</p>
<p>这样父子进程分别拥有用于描述匿名管道读端，写端文件对象的文件描述符，各自关闭一端就能实现半双工通信，两根管道各自关闭一端就能实现全双工通信。(显然，这样的特性是依赖与fork()实现的)</p>
</blockquote>
<p><code>示例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让父进程打开文件file1，读取其内容，通过管道发送给子进程，而子进程将内容写入到文件file2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./pipe2 file1 file2</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> fds1[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> fds2[<span class="number">2</span>];</span><br><span class="line">    pipe(fds1);</span><br><span class="line">    pipe(fds2);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程 父读子写 关闭父的写子的读</span></span><br><span class="line">        close(fds1[<span class="number">1</span>]);</span><br><span class="line">        close(fds2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> fd2 = open(argv[<span class="number">2</span>], O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(read(fds1[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// puts(buf);</span></span><br><span class="line">            write(fd2, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// read(fds1[0], buf, sizeof(buf));</span></span><br><span class="line">        <span class="comment">// puts(buf);</span></span><br><span class="line">        <span class="comment">// write(fds2[1], &quot;hello i am child&quot;, 17);</span></span><br><span class="line">        close(fd2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程 父写子读 关闭父的读 子的写</span></span><br><span class="line">        close(fds1[<span class="number">0</span>]);</span><br><span class="line">        close(fds2[<span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">int</span> fd1 = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(read(fd1, buf, <span class="keyword">sizeof</span>(buf)) != <span class="number">0</span>)&#123;</span><br><span class="line">            write(fds1[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write(fds1[1], &quot;i am parent\n&quot;, 13);   </span></span><br><span class="line">        <span class="comment">// char buf[1024];</span></span><br><span class="line">        <span class="comment">// read(fds2[0], buf, sizeof(buf));</span></span><br><span class="line">        <span class="comment">// puts(buf);</span></span><br><span class="line">        close(fds1[<span class="number">1</span>]);</span><br><span class="line">        close(fd1);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MIFIFO(3)   创建有名管道</p>
<p>UNLINK(2)  删除文件(删除的本质是:接触数据与文件系统的连接—数据不一定被销毁)</p>
<p>RENAME(2)  移动文件</p>
<p>LINK(2) 创建硬链接</p>
</blockquote>
<h3 id="2-共享内存"><a href="#2-共享内存" class="headerlink" title="2. 共享内存"></a>2. 共享内存</h3><blockquote>
<p>基于system V 版本的系统调用  $ipcs </p>
</blockquote>
<blockquote>
<p>使用步骤 </p>
<p>——&gt;通过文件使用<code>FTOK(3)</code>得到一个shmid（是个数字）或者自定义一个数字也可(此数字识别不同的IPC机制?同一个数字可能串号冲突?)</p>
<p>——&gt; <code>SHMGET(2)</code>生成共享内存</p>
<p>——&gt; <code>SHMAT(2)</code>将共享内存映射到虚拟地址空间(申请到的共享内存是物理内存，但想要使用它必须先映射) </p>
<p>——&gt; 之后类似malloc申请到的空间一样操作它即可  </p>
<p>——&gt; 分配在堆区 用<code>SHMDT(2)</code>释放 并用·<code>shmctl(shmid,IPC_RMID,NULL);</code>删除</p>
</blockquote>
<p><code>FTOK(3)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SHMGET(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SHMOP(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SHMOP(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SHMCTL(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>示例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ./fhm file</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(argv[<span class="number">1</span>], <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;Hou are you&quot;</span>);</span><br><span class="line">    <span class="comment">// puts(p);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//创建并写入</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./shm_r file1 用同一个文件创建的key相同</span></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(argv[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>); </span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">int</span> ret = shmdt(p);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;shmadt&quot;</span>);</span><br><span class="line">    <span class="comment">// while(1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个独立进程同时对一个共享内存去访问修改，可能造成竞争条件的出现race condition 由此可以引出信号量作为互斥机制</p>
</blockquote>
<blockquote>
<p>竞争条件:并发的执行流对共享资源的访问会导致竞争条件(进程是默认隔离的，所以出现概率比较低)</p>
</blockquote>
<p><code>竞争条件举例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">父子进程各自对共享内存变量加一千万，结果不是两千万</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(IPC_PRIVATE, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmid&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//取4字节存整数</span></span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span> *)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            ++*p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            ++*p;</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./shm_fork </span><br><span class="line">*p = <span class="number">18630024</span></span><br></pre></td></tr></table></figure>



<h3 id="3-信号量-以二元信号量为主"><a href="#3-信号量-以二元信号量为主" class="headerlink" title="3. 信号量(以二元信号量为主)"></a>3. 信号量(以二元信号量为主)</h3><blockquote>
<p>由上例中引出的竞争条件，分析其原因，<code>++*p;</code>这条指令在汇编层与机器层是更细化的 大概能分作三步(读取值，计算值，写回值)，如果中途被打断，可能会使得计算(访存)时所用的(得到的)并非最新值</p>
<p>想要解决这种情况需要有一种机制使的这三步要么不做，要么一次做完。比如原子操作，比如信号量。</p>
</blockquote>
<blockquote>
<p>信号量是描述资源数量的整数 &lt;= 0 : 资源不可用   &gt; 0 : 资源可用</p>
<p>PV操作 P:测试并加锁，V:释放并解锁 PV之间访问临界资源(这部分代码叫”临界区”)</p>
</blockquote>
<blockquote>
<p>使用步骤 </p>
<p>——&gt; <code>SEMGET(2)</code>获取信号量</p>
<p>——&gt;用·<code>semctl(semid, 数组下标, 行为, ....);</code>操作信号， 一般先设初值<code>semctl(semid, 0, SETVAL, 1);</code></p>
<p>——&gt;定义PV操作</p>
<p>——&gt;在需要加锁的地方调用<code>SEMOP(2)</code></p>
</blockquote>
<p><code>SEMGET(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SEMCTL(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SEMOP(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nsops)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>使用示例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用二元信号量，让两个进程对同一个数各加1千万次之后，最终每次执行结果都是2千万，看一下需要耗时多长时间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//准备共享内存,四个字节存加的数</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="comment">//准备二元信号量</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;semctl&quot;</span>);</span><br><span class="line">    <span class="comment">//设置PV操作 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>; <span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="comment">//计算耗时，使用gettimeofday</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">begTime</span>, <span class="title">endTime</span>;</span></span><br><span class="line">    gettimeofday(&amp;begTime, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//完成准备工作，生成两个进程</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            ++*p;</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            ++*p;</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        gettimeofday(&amp;endTime, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total microseconds = %ld\n&quot;</span>, (endTime.tv_sec - begTime.tv_sec)*<span class="number">1000000</span> + endTime.tv_usec - begTime.tv_usec);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/test$ ./pv</span><br><span class="line">*p = <span class="number">20000000</span></span><br><span class="line">Total microseconds = <span class="number">32416265</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>题外话 : dekker算法 伪代码与实现; 计数信号量; ......</code></p>
<p><code>伪代码</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># dekker算法的基本思路</span><br><span class="line">    variables</span><br><span class="line">        wants_to_enter : array of 2 booleans</span><br><span class="line">        turn : integer</span><br><span class="line"></span><br><span class="line">    wants_to_enter[0] ← false</span><br><span class="line">    wants_to_enter[1] ← false</span><br><span class="line">    turn ← 0   // or 1</span><br><span class="line"># p0</span><br><span class="line">p0:</span><br><span class="line">   wants_to_enter[0] ← true</span><br><span class="line">   while wants_to_enter[1] &#123;</span><br><span class="line">      if turn ≠ 0 &#123;</span><br><span class="line">         wants_to_enter[0] ← false</span><br><span class="line">         while turn ≠ 0 &#123;</span><br><span class="line">           // busy wait</span><br><span class="line">         &#125;</span><br><span class="line">         wants_to_enter[0] ← true</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // critical section</span><br><span class="line">   ...</span><br><span class="line">   turn ← 1</span><br><span class="line">   wants_to_enter[0] ← false</span><br><span class="line">   // remainder section</span><br><span class="line"># p1</span><br><span class="line">p1:</span><br><span class="line">   wants_to_enter[1] ← true</span><br><span class="line">   while wants_to_enter[0] &#123;</span><br><span class="line">      if turn ≠ 1 &#123;</span><br><span class="line">         wants_to_enter[1] ← false</span><br><span class="line">         while turn ≠ 1 &#123;</span><br><span class="line">           // busy wait</span><br><span class="line">         &#125;</span><br><span class="line">         wants_to_enter[1] ← true</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // critical section</span><br><span class="line">   ...</span><br><span class="line">   turn ← 0</span><br><span class="line">   wants_to_enter[1] ← false</span><br><span class="line">   // remainder section</span><br></pre></td></tr></table></figure>

<p><code>dekker 实现+20000000</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 10000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(IPC_PRIVATE, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmid&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//算值</span></span><br><span class="line">    p[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">//wants_to_enter[0] false 两个标志</span></span><br><span class="line">    p[<span class="number">2</span>] = <span class="literal">false</span>; <span class="comment">//wants_to_enter[1]</span></span><br><span class="line">    p[<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">//turn轮转</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            <span class="comment">//p0</span></span><br><span class="line">            p[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//子进程的flag</span></span><br><span class="line">            <span class="keyword">while</span>(p[<span class="number">2</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">3</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">                    p[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">//1号标志false</span></span><br><span class="line">                    <span class="keyword">while</span>(p[<span class="number">3</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//busy wait</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    p[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++*p;</span><br><span class="line">            p[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">            p[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//p1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i)&#123;</span><br><span class="line">            p[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(p[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">3</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                    p[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">while</span>(p[<span class="number">3</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">            ++*p;</span><br><span class="line">            p[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            p[<span class="number">2</span>] = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(p);   </span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/test/day13/homework$ make</span><br><span class="line">gcc  dekker.c -o dekker -g -O0</span><br><span class="line">scallacs@scallacs:~/test$ ./dekker  </span><br><span class="line">*p = <span class="number">20000000</span>  单核</span><br><span class="line">[ubuntu@VM<span class="number">-16</span><span class="number">-8</span>-ubuntu ~/linux/\ []$ ./dekker </span><br><span class="line">*p = <span class="number">19899008</span>  双核 会受到核心数影响，单核时表现完美</span><br></pre></td></tr></table></figure>

<p><code>计数信号量 + 生产者消费者问题</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1002</span>, <span class="number">2</span>,IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="comment">// unsigned short  *array;  /* Array for GETALL, SETALL */ 要使用SETALL初始化</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> arr[] = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;; <span class="comment">//arr[0]&lt;-&gt;商品  arr[1]&lt;-&gt;货仓 初始货仓摆满商品</span></span><br><span class="line">    <span class="keyword">int</span> ret = semctl(semid, <span class="number">0</span>, SETALL, arr);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;semctl setall&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出看看是否初始化成功，增量编程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sem[0] = %d, sem[1] = %d\n&quot;</span>, semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">    <span class="comment">// 设置信号量做PV操作, 先设定操作的行为,针对两种资源使用信号量集合</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">produce</span>[2];</span><span class="comment">//produce[0]:商品 produce[1]:货仓?</span></span><br><span class="line">    produce[<span class="number">0</span>].sem_num = <span class="number">0</span>;</span><br><span class="line">    produce[<span class="number">0</span>].sem_op = <span class="number">1</span>; <span class="comment">//商品+1</span></span><br><span class="line">    produce[<span class="number">0</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    produce[<span class="number">1</span>].sem_num = <span class="number">1</span>;</span><br><span class="line">    produce[<span class="number">1</span>].sem_op = <span class="number">-1</span>;</span><br><span class="line">    produce[<span class="number">1</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">consume</span>[2];</span><span class="comment">//consume[0]:商品 consume[1]:货仓</span></span><br><span class="line">    consume[<span class="number">0</span>].sem_num = <span class="number">0</span>;</span><br><span class="line">    consume[<span class="number">0</span>].sem_op = <span class="number">-1</span>; <span class="comment">//商品-1</span></span><br><span class="line">    consume[<span class="number">0</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    consume[<span class="number">1</span>].sem_num = <span class="number">1</span>;</span><br><span class="line">    consume[<span class="number">1</span>].sem_op = <span class="number">1</span>;</span><br><span class="line">    consume[<span class="number">1</span>].sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="comment">// 启动父子进程分别作为生产者和消费者</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// sleep(1);//如果交换睡眠时间会一直显示&#123;5, 0&#125;消费太慢</span></span><br><span class="line">            usleep(<span class="number">500000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am consumer, before consume, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">            <span class="comment">// semop(semid,consume,2);//这个操作会影响到2个资源 </span></span><br><span class="line">            semop(semid, &amp;consume[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consumer buy a product\n&quot;</span>);</span><br><span class="line">            semop(semid, &amp;consume[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am consumer, after consume, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// usleep(500000);</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am producer, before produce, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">            <span class="comment">// semop(semid,produce,2);//这个操作会影响到2个资源 </span></span><br><span class="line">            semop(semid, &amp;produce[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;produce a product\n&quot;</span>);</span><br><span class="line">            semop(semid, &amp;produce[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am producer, after produce, product = %d, space = %d\n&quot;</span>,</span><br><span class="line">                    semctl(semid, <span class="number">0</span>, GETVAL), semctl(semid, <span class="number">1</span>, GETVAL));</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./produceAndConsume </span><br><span class="line">sem[<span class="number">0</span>] = <span class="number">5</span>, sem[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am producer, before produce, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">produce a product</span><br><span class="line">i am producer, after produce, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">5</span>, space = <span class="number">0</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">i am producer, before produce, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">produce a product</span><br><span class="line">i am producer, after produce, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">4</span>, space = <span class="number">1</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">i am consumer, before consume, product = <span class="number">3</span>, space = <span class="number">2</span></span><br><span class="line">consumer buy a product</span><br><span class="line">i am consumer, after consume, product = <span class="number">2</span>, space = <span class="number">3</span></span><br><span class="line">i am producer, before produce, product = <span class="number">2</span>, space = <span class="number">3</span></span><br></pre></td></tr></table></figure>



<h3 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4.消息队列"></a>4.消息队列</h3><blockquote>
<p>这里使用的是狭义的消息队列(广义的消息队列:网络消息中间件)， 这里的是面向消息的进程间通信机制</p>
<p>使用流程与前二者类似</p>
<p>——&gt; <code>MSGGET(2)</code>获取消息队列</p>
<p>——&gt; <code>MSGSND(2)</code> 发</p>
<p>——&gt; <code>MSGRCV(2)</code> 收</p>
<p>后面综合使用时演示</p>
</blockquote>
<p><code>MSGGET(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>MSGSND(2)</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p> <code>MSGRCV(2)</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="5-信号"><a href="#5-信号" class="headerlink" title="5. 信号"></a>5. 信号</h3><blockquote>
<p>进程间异步通信机制(软件层面的，异步:不知道什么时候有信号来;管道是同步的:先写再读)</p>
<p>信号分为产生 递送(对某个进程施加影响(处理信号))两个阶段</p>
<p><code>kill -l </code>列出所有信号 共有64个 每种信号对应一个整数</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">递送信号发生了什么(递送信号的默认行为)(收到信号的默认行为:是可以通过注册信号改变这些行为的)</span><br><span class="line">Each signal has a current disposition, <span class="built_in">which</span> determines how the process behaves when it is delivered the signal.</span><br><span class="line"></span><br><span class="line">The entries <span class="keyword">in</span> the <span class="string">&quot;Action&quot;</span> column of the table below specify the default disposition <span class="keyword">for</span> each signal, as follows:</span><br><span class="line">      Term   Default action is to terminate the process.  终止进程 Ctrl C</span><br><span class="line">      Ign    Default action is to ignore the signal. 忽略信号<span class="built_in">wait</span>()的实现原理 SIGCHILD 告知父进程可以回收</span><br><span class="line">      Core   Default action is to terminate the process and dump core (see core(5)). 终止生成并core文件 Ctrl \ </span><br><span class="line">      Stop   Default action is to stop the process. 暂停 Ctrl Z</span><br><span class="line">      Cont   Default action is to <span class="built_in">continue</span> the process <span class="keyword">if</span> it is currently stopped. 恢复<span class="built_in">bg</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>将递送信号时的默认行为改变为自己定义的行为<code>SIGNAL(2)</code>(更改递送信号时的默认行为:可以实现进程的有序退出)</p>
<p>递送信号的本质 是 修改被递送信号的进程的task_struct （[注]9号信号的默认行为不能改）</p>
</blockquote>
<blockquote>
<p>执行流程如下图所示，在进程执行过程中受到信号，CPU的使用权移交给信号产生者，它会要求进程调用预定义的回调函数handler()，将这个信号的默认行为使用handler()定义的行为取代，函数接口如下</p>
</blockquote>
<p><code>SIGNAL(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line">                                              |-&gt;注册一个handler</span><br><span class="line">把系统信号的递送行为改为自己注册的行为</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.png" alt="回调函数的执行"></p>
<blockquote>
<p>如果有多个信号同时递送，会发现这么一种现象，有的递送行为没有执行，分析会发现，相同信号的递送会有如下现象</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BF%A1%E5%8F%B7%E9%80%92%E9%80%81.png" alt="信号递送"></p>
<blockquote>
<p>Q:那么为什么 多余的信号会被丢弃</p>
<p>A:这涉及两个结构体 <code>mask </code> <code>掩码，表示是否阻塞 pending   </code>未决信号集，表示是否有未决信号 它们都是位图实现的</p>
<p>所以在递送X信号时，会将mask的X置为1(递送结束恢复为0)(信号递送过程中把自己阻塞:把自己加入mask)—-&gt;当新信号产生，若这个信号也是X，查询mask发现其中有自己，那就把自己加入pending(对应位置1)—–&gt;再有一个X产生，同样的流程，但因为底层实现是位图pending只能保存一个，所以它被丢弃。</p>
<p>类似的，如果第三个信号是个新的，且mask中没它，就会转而执行新信号的递送…….</p>
</blockquote>
<blockquote>
<p>signal系统调用也存在一些缺陷，它的很多特性是写死的，比如递送X信号时会将X加入mask因此还有更好用的系统调用</p>
</blockquote>
<p><code>SIGACTION(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>用法示例</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;<span class="comment">//指定不把自己加入mask,可反复切换，没使用SIGINFO指定为单参数版本的handler</span></span><br><span class="line">    act.sa_handler = handler; <span class="comment">//指定回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用sigaction注册信号 注册2号3号信号执行handler以来回打断</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGQUIT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scallacs@scallacs:~/test$ ./sigaction </span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^\handler got signal num = <span class="number">3</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">^Chandler got signal num = <span class="number">2</span></span><br><span class="line">Killed</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后续，这些进程间通信机制都用的比较少，有更好的实现方案</p>
<p>用网络取代管道，用线程取代共享内存，用互斥锁取代信号量(当然，信号是比较独特的进程间通信机制，用到时再复盘)</p>
</blockquote>
<h3 id="6-综合应用：实现一个四窗口聊天"><a href="#6-综合应用：实现一个四窗口聊天" class="headerlink" title="6. 综合应用：实现一个四窗口聊天"></a>6. 综合应用：实现一个四窗口聊天</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通信方式：</span><br><span class="line">- 4个进程，A进程和B进程负责通信，从标准输入读到的字符串通过管道发给对方，A1和B1进程负责显示。</span><br><span class="line">- A进程从标准输入读到的字符串发给B进程后，放到共享内存里，从管道中读到的字符串也放到共享内存里，A1进程到共享内存中拿到字符串，打印到屏幕上。</span><br><span class="line">- B进程从标准输入读到的字符串发给B进程，同时通过消息队列发给B1进程，B1进程从消息队列中读出消息，打印到屏幕上。</span><br><span class="line">退出方式：</span><br><span class="line">- 第一种：可以通过ctrl+C退出，任意一个进程收到CTRL+C时，给所有进程（包括自己）发送10号信号，每个进程收到10号信号后，开始执行有序退出。</span><br><span class="line">- 第二种：通过kill命令给4个进程中的任何一个进程发送10号信号，收到信号的进程再给其他3个进程发送10号信号。每个进程在自己的信号处理函数中执行有序退出。</span><br><span class="line">有序退出的工作内容：</span><br><span class="line">- 有序退出要做的主要有：关闭管道，解除对共享内存的映射，删除共享内存，删除信号量，删除消息队列。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  注意：A和A1进程都要访问共享内存，需要同信号量完成同步，所以退出时要也删除信号量。</span><br><span class="line">  提示：A1进程和B1进程需要知道每条消息是对方发来的消息还是发给对方的消息，用消息队列的一方可以通过mtype的值来标识，</span><br><span class="line">       用共享内存的进程可以自己定义一个类似 msgbuf的结构体，然后结构体中也用一个类似mtype的成员来标记。</span><br></pre></td></tr></table></figure>

<p><code>a.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">2048</span>];</span><br><span class="line">&#125;<span class="keyword">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid 输出看看是否正常收到</span></span><br><span class="line">    <span class="comment">// 程序启动，先获取四个进程的PID存入全局变量输出一下(通信时用不到，但退出时有用)</span></span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">0</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ******************************************************</span></span><br><span class="line">    <span class="comment">// 通信，a2b管道通信</span></span><br><span class="line">    <span class="comment">// int ret_ab = mkfifo(&quot;a2b&quot;, 0666);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_ab, -1, &quot;mkfifo&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信 a2a1 by 共享内存+信号量 ?共享内存中怎么设置msgbuf结构体? 类似malloc</span></span><br><span class="line">    <span class="comment">// 为什么要用信号量：写的时候不允许读 先做共享内存读写再做信号量</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">msg_t</span> *p = (<span class="keyword">msg_t</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信号量完成同步(不用的话a1显示时有时候会阻塞住?)(Q:stdin的消息较少阻塞，pipe的消息很容易?)确实是同步问题，加锁解决</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret_sem = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem, <span class="number">-1</span>, <span class="string">&quot;semctl setval&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>;<span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开a2b的写端，b2a的读端 完成后输出</span></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;a2b&quot;</span>, O_WRONLY);</span><br><span class="line">    ERROR_CHECK(fdw, <span class="number">-1</span>, <span class="string">&quot;open pipe a2b\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;b2a&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fdr, <span class="number">-1</span>, <span class="string">&quot;open pipe b2a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;chat established!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//IO多路复用</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);<span class="comment">//设置监听集合</span></span><br><span class="line">        <span class="keyword">int</span> ret_slt = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from process b\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdb = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdb == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// puts(buf);//后面改成在进程a1上显示</span></span><br><span class="line">            <span class="comment">// 从管道读来自b的消息 重定向到a1进程去显示 来自管道的消息定为2</span></span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            p-&gt;mtype = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;mtext, buf);</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from stdin.\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdin = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdin == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fdw, buf, ret_rdin);<span class="comment">//除开给管道发送一份之外还要写给a1显示进程一份</span></span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            p-&gt;mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;mtext, buf);</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    shmdt(p);</span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>a1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">2048</span>];</span><br><span class="line">&#125;<span class="keyword">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">1</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *************************************************</span></span><br><span class="line">    <span class="comment">// 读取共享内存中的消息</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">msg_t</span> *p = (<span class="keyword">msg_t</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信号量完成同步</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret_sem = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem, <span class="number">-1</span>, <span class="string">&quot;semctl setval&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>;<span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mtype == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg from process b:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg type = %d, msg = %s\n&quot;</span>, p-&gt;mtype, p-&gt;mtext);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mtype == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg from stdin:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg type = %d, msg = %s\n&quot;</span>, p-&gt;mtype, p-&gt;mtext);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Q : 怎么做到读出一条消息后阻塞? 清空一下阻塞住了但是 有时候接不到下条消息?等会加锁试试</span></span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line">        semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int ret_shmdt = shmdt(p);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_shmdt, -1, &quot;shmdt&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> ret_sem_rm = semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem_rm, <span class="number">-1</span>, <span class="string">&quot;semctl IPC_RMID&quot;</span>);</span><br><span class="line">    shmdt(p);   <span class="comment">//有一片共享内存(a2a1通信用的那片)和信号量没有正确退出，其他的正常</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>b.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">2</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *********************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信，b2b1(b1为显示端) 使用消息队列，要做的事情:b把从管道读端,键盘输入读到的数据重定向到b1,区分消息类型 by 消息队列</span></span><br><span class="line">    <span class="comment">// 消息对列发端</span></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">bufin</span>, <span class="title">bufpipe</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信，a2b管道通信</span></span><br><span class="line">    <span class="comment">// int ret_ba = mkfifo(&quot;b2a&quot;, 0666);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_ba, -1, &quot;mkfifo&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开b2a的写端，a2b的读端 完成后输出</span></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;a2b&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fdr, <span class="number">-1</span>, <span class="string">&quot;open pipe b2a\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;b2a&quot;</span>, O_WRONLY);</span><br><span class="line">    ERROR_CHECK(fdw, <span class="number">-1</span>, <span class="string">&quot;open pipe a2b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;chat established!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        <span class="keyword">int</span> ret_slt = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from process a\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rda = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rda == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// puts(buf);//管道读端读到的原本直接输出，现在重定向到b1进程 by message queue;</span></span><br><span class="line">            </span><br><span class="line">            bufpipe.mtype = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(bufpipe.mtext, buf);</span><br><span class="line">            <span class="keyword">int</span> ret_msgque_pipe = msgsnd(msgid, &amp;bufpipe, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret_msgque_pipe, <span class="number">-1</span>, <span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from stdin.\n&quot;);//隐藏掉这些信息进程b就只管输入了,显示全在b1</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdin = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdin == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fdw, buf, ret_rdin);<span class="comment">//后面改成在进程a1上显示</span></span><br><span class="line">            <span class="comment">// 键盘输入还要再在b1上显示一次</span></span><br><span class="line">            bufin.mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(bufin.mtext, buf);</span><br><span class="line">            <span class="keyword">int</span> ret_msgque_in = msgsnd(msgid, &amp;bufin, <span class="keyword">sizeof</span>(bufin), <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret_msgque_in, <span class="number">-1</span>, <span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>b1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">3</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *********************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// msgrcv</span></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">bufin</span>, <span class="title">bufpipe</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin)); <span class="comment">//两种消息有时候会阻塞?</span></span><br><span class="line">        <span class="keyword">int</span> ret_msgrcv_in = msgrcv(msgid, &amp;bufin, <span class="keyword">sizeof</span>(bufin), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//1, IPC_NOWAIT  改填0不限制消息类型直接取出</span></span><br><span class="line">        ERROR_CHECK(ret_msgrcv_in, <span class="number">-1</span>, <span class="string">&quot;msgrcv_in&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgrcv form stdin:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type = %ld, msg = %s\n&quot;</span>, bufin.mtype, bufin.mtext);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));       <span class="comment">//注意这个限制消息队列长度的参数：msgrcv: Argument list too long</span></span><br><span class="line">        <span class="keyword">int</span> ret_msgrcv_pipe = msgrcv(msgid, &amp;bufpipe, <span class="keyword">sizeof</span>(bufpipe), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//2, IPC_NOWAIT</span></span><br><span class="line">        ERROR_CHECK(ret_msgrcv_pipe, <span class="number">-1</span>, <span class="string">&quot;msgrcv_pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgrcv from pipe:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type = %ld, msg = %s\n&quot;</span>, bufpipe.mtype, bufpipe.mtext);</span><br><span class="line">        <span class="comment">//这样会循环取出，几乎一瞬间取完然后进程终止(怎么阻塞它)？不加IPC_NOWAIT 即可</span></span><br><span class="line">        <span class="comment">//目前对b1用Ctrl+C 不会影响a, b进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1>
	  <div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>

	</div>

	
	<span id="/2022/03/02/7.Unix-Linux-Process-management/" class="leancloud-visitors view" data-flag-title="Unix-Linux-Process-management">
		<em class="post-meta-item-text"> Page View </em> <i class="leancloud-visitors-count"></i>
	</span>
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2022/02/26/6.Unix-Linux-file-management/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>

-->
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2022-03-02 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/Unix-Linux/">Unix/Linux<span>2</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2022 chen's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
