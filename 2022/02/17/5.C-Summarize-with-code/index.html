<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>C_Summarize_with_code | lacsscal&#39;s blog</title>
  <meta name="author" content="chen">
  
  <meta name="description" content="写在前面(序)
接上篇总结1 上篇更多偏向文字叙述，以及一些概念方面的整理与思考，本篇结合一些常用的数据结构以及算法，换一个论述点再做一些整理

正文1.基本数据结构1....



2. 常见排序算法
关于排序算法分析
1.时间复杂度
冒泡排序，插入排序，简单选择排序无法突破O(n2)时间复杂度，因为其有序化过程中都是一个一个来减少逆序度的，当逆序度为0时整个序列有序，相对的希尔，并归，快排，堆排能突破是因为其不依赖相邻元素逐个排序。

最好，最坏，平均   
分析时间复杂度，要给出 最好，最坏，平均情况下的时间复杂度(给出最好，最坏情况下对应要排序的原始数据情况)

平均时间复杂度分析
n个元素有n!种排序，然后统计比较和交换的次数，再计算平均值。想想就十分复杂。
这里我们采用逆序对的方式来分析。
有序元素对：arr[i] &amp;lt;= arr[j], i &amp;lt; j  
逆序元素对：arr[i] &amp;gt; arr[j], i &amp;lt; j
有序度：数组中有序元素对的个数
逆序度：数组中逆序元素对的个数
满有序度：数组排好序后的有序度。
假设数组有n个元素，满有序度 =  n(n-1)/2
公式： 满有序度 = 有序度 + 逆序度排序过程就是增加有序度，减少逆序度，最终达到满有序度的过程。



常数，系数，低阶  
时间复杂度反应规模n很大时的增长趋势，忽略常数，系数，低阶(考虑规模小的数据时考虑这些因素)

比较， 交换  
基于比较的排序算法涉及元素的比较，交换，分析效率要考虑这些


2.空间复杂度  
是否是原地算法
3.稳定性  
待排序列中存在值相等的元素，排序后这些元素间的前后关系是否不变

bubble
123456789101112void bubble_sort(int arr[], int n) &amp;#123;    for (int i = 1; i &amp;lt; n; i++) &amp;#123; // i 表示冒泡的次数，也就是比较的趟数        bool sorted = true;        for (int j = 0; j &amp;lt; n - i; j++) &amp;#123;//每趟比较中，j从0开始取相邻两个元素比较(交换),每趟一定有一个元素有序排好，可以利用i            if (arr[j] &amp;gt; arr[j + 1]) &amp;#123;                swap(arr, j, j + 1);                sorted = false;            &amp;#125;        &amp;#125;        if (sorted) break;//做点优化，使得有序(这趟没执行交换)之后结束排序    &amp;#125;&amp;#125;


有序度是数组中具有有序关系的元素对的个数。如果一个数组完全有序，有序度就是Cn2 = n(n-1)/2，这种叫做满有序度。
对于冒泡排序来说，交换会导致：有序度+1， 逆序度-1.
所以 交换的次数 = 逆序度。可以简单的认为平均情况下，逆序度 =  n(n-1)/4 比较的次数肯定比交换的次数多，但少于 n(n-1)/2所以平均情况下，时间复杂度为O(n2)"> 
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="C_Summarize_with_code"/>
  <meta property="og:site_name" content="lacsscal&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="lacsscal&#39;s blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.0.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">lacsscal&#39;s blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> C_Summarize_with_code</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote>
<p>接上篇<a target="_blank" rel="noopener" href="https://lacsscal.github.io/2022/02/10/C-Summarize/">总结1</a> 上篇更多偏向文字叙述，以及一些概念方面的整理与思考，本篇结合一些常用的数据结构以及算法，换一个论述点再做一些整理</p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1.基本数据结构"></a>1.基本数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....</span><br></pre></td></tr></table></figure>



<h3 id="2-常见排序算法"><a href="#2-常见排序算法" class="headerlink" title="2. 常见排序算法"></a>2. 常见排序算法</h3><blockquote>
<p>关于排序算法分析</p>
<p>1.时间复杂度</p>
<p>冒泡排序，插入排序，简单选择排序无法突破<code>O(n2)</code>时间复杂度，因为其有序化过程中都是一个一个来减少逆序度的，当逆序度为0时整个序列有序，相对的希尔，并归，快排，堆排能突破是因为其不依赖相邻元素逐个排序。</p>
<ul>
<li><p>最好，最坏，平均   </p>
<p>分析时间复杂度，要给出 最好，最坏，平均情况下的时间复杂度(给出最好，最坏情况下对应要排序的原始数据情况)</p>
<ul>
<li><p>平均时间复杂度分析</p>
<p>n个元素有n!种排序，然后统计比较和交换的次数，再计算平均值。想想就十分复杂。</p>
<p>这里我们采用逆序对的方式来分析。</p>
<p>有序元素对：<code>arr[i] &lt;= arr[j], i &lt; j  </code></p>
<p>逆序元素对：<code>arr[i] &gt; arr[j], i &lt; j</code></p>
<p>有序度：数组中有序元素对的个数</p>
<p>逆序度：数组中逆序元素对的个数</p>
<p>满有序度：数组排好序后的有序度。</p>
<p>假设数组有n个元素，满有序度 =  <code>n(n-1)/2</code></p>
<p>公式： 满有序度 = 有序度 + 逆序度排序过程就是增加有序度，减少逆序度，最终达到满有序度的过程。</p>
</li>
</ul>
</li>
<li><p>常数，系数，低阶  </p>
<p>时间复杂度反应规模n很大时的增长趋势，忽略常数，系数，低阶(考虑规模小的数据时考虑这些因素)</p>
</li>
<li><p>比较， 交换  </p>
<p>基于比较的排序算法涉及元素的比较，交换，分析效率要考虑这些</p>
</li>
</ul>
<p>2.空间复杂度  </p>
<p>是否是原地算法</p>
<p>3.稳定性  </p>
<p>待排序列中存在值相等的元素，排序后这些元素间的前后关系是否不变</p>
</blockquote>
<p><code>bubble</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// i 表示冒泡的次数，也就是比较的趟数</span></span><br><span class="line">        <span class="keyword">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//每趟比较中，j从0开始取相邻两个元素比较(交换),每趟一定有一个元素有序排好，可以利用i</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;<span class="comment">//做点优化，使得有序(这趟没执行交换)之后结束排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有序度是数组中具有有序关系的元素对的个数。如果一个数组完全有序，有序度就是<code>Cn2 = n(n-1)/2</code>，这种叫做满有序度。</p>
<p>对于冒泡排序来说，交换会导致：有序度+1， 逆序度-1.</p>
<p>所以 交换的次数 = 逆序度。可以简单的认为平均情况下，逆序度 = <code> n(n-1)/4</code> 比较的次数肯定比交换的次数多，但少于 <code>n(n-1)/2</code>所以平均情况下，时间复杂度为<code>O(n2)</code></p>
</blockquote>
<p><code>selection</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// i表示选择元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = i;<span class="comment">//先预设当前索引所指数为最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//j从后一个元素开始向后找有无更小的</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每趟先假定本趟开头为最小元素，记录其索引，从其后一个元素开始向后遍历，找到更小的，更新最小元索引记录一趟走完交换本趟开头与最小<br>发生长距离的交换 所以不稳定</p>
<p>[5, 5, 1, 2, 3, 0, ]第一个5换到第二个5后面</p>
<p><code>O(n2) </code>不存在最好最坏，都是<code>O(n2)</code></p>
</blockquote>
<p><code>insertion</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">// i代表待插入元素的索引，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">int</span> val = arr[i];<span class="comment">//先记录，如果要插到前面的话需要前方元素后移，可能会覆盖它</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">//找到待插元素的前一个元素</span></span><br><span class="line">        <span class="comment">// 元素(比记录的待插元素大)往后移(凡比ta大的都后移，留出ta的位置)</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从第二个元素开始，每趟排序使当前遍历元素变得有序，取出元素值后先记录，往前找，凡前前面的元素(认为是有序序列)比ta大的，都后移，留出ta的位置，把它插入</p>
<p>最好<code>O(n) </code>比较n-1此，序列有序，不做交换</p>
<p>最坏O(n2)</p>
<p>逆序度分析平均时间复杂度 </p>
<p>稳定</p>
</blockquote>
<blockquote>
<p>选择排序一般不使用，冒泡排序一般也不用，</p>
<p>可能会用到的是插入排序为什么选择插入而不选择冒泡选择O()表示法省略了系数项和低阶项</p>
</blockquote>
<p><code>shell</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 组间插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123; <span class="comment">//还是插入排序的特性，先取后面的元素，只是这里用增量序列分组</span></span><br><span class="line">                                        <span class="comment">//i = gap 以 n = 10 个数为例 每轮 gap /= 2;  </span></span><br><span class="line">                                        <span class="comment">// 8 9 1 7 2 3 5 4 6 0  gap = 5</span></span><br><span class="line">                                        <span class="comment">// |         |</span></span><br><span class="line">                                                     i</span><br><span class="line">            <span class="keyword">int</span> val = arr[i];    <span class="comment">//组内比大小交换</span></span><br><span class="line">            <span class="keyword">int</span> j = i - gap;    </span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];<span class="comment">//每组前面的值先赋值给后面的值</span></span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = val; <span class="comment">//先减掉后加上用于交换赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缩小gap</span></span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>(缩小增量排序)插入排序的优化版本 (第一批突破<code>O(n^2))</code>基于插入排序的性质提出改进方法  </p>
<ul>
<li><p>插入排序对基本有序的数据操作时，效率高。  </p>
</li>
<li><p>插入排序的缺点:每次比较相邻两个元素:对于基本有序的数组，一直比较相邻元素若有插入距离远的将比较多次，不适合</p>
</li>
</ul>
<p>希尔有先比较 距离远的(使得数据基本有序)基本有序的元素交换距离短</p>
<p>选择一个增量序列gap:(希尔推荐:n/2, n/4, …, 1)，分组，然后组间插入排序缩小增量 再分组 组间插入排序</p>
<p>插入排序:当数组基本有序，性能好(利用这一点)的有限，并解决不能长距离交换元素的缺点</p>
<p>长距离交换元素 不稳定</p>
<p>时间复杂度小于<code>O(n^2),</code>与增量序列有关</p>
</blockquote>
<p><code>merge</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//所给的接口感觉不好实现，在函数内部做一层封装委托出去</span></span><br><span class="line">    merge_sort1(arr, <span class="number">0</span>, n - <span class="number">1</span>);       <span class="comment">//知道数组的长度，把头当左界，尾当右界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;<span class="comment">//采用分治的思想，假定已有部分子序列有序，把他们合并</span></span><br><span class="line">                                                  <span class="comment">//至于怎么得到有序的子序列anyway，先不管，交个计算机，我只考虑这一层</span></span><br><span class="line">    <span class="comment">// 边界条件                                      //使用递归来做</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 递归公式</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);       <span class="comment">//使用已知的左右界求得中间节点，作为下层的右界，左界</span></span><br><span class="line">    merge_sort1(arr, left, mid);                  <span class="comment">//下层将要给我的是有序的左半边子序列 右半边子序列，实现合并即可</span></span><br><span class="line">    merge_sort1(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(arr, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;<span class="comment">//关键 实现归并操作</span></span><br><span class="line">    <span class="keyword">int</span>* temp = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>((right - left + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//先分配长度为n的辅助数组，排序过程中先将数据存入辅助序列</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;  <span class="comment">//两半有序子序列合并成整个有序序列</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;       <span class="comment">//Caution: 不能是 arr[i] &lt; arr[j] 相等的左边仍在前面 保证稳定性</span></span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;                  <span class="comment">//如果有一边的数据未取完，剩余的全复制过去</span></span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[left + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(nlog n)</code>的时间复杂度。代价是需要额外的内存空间<code>O(n) </code> tmp数组辅助。</p>
<p>稳定</p>
<p>建立在归并操作上的一种有效的排序算法是采用分治法（Divide and Conquer）(一种算法设计思想，策略)的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；</p>
<p>即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<p><code>Quick</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//同样，给定的接口不太好实现，可以利用已有的信息构建自己的内部接口委托实现</span></span><br><span class="line">    quick_sort1(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; <span class="comment">// pivot 枢 基准 定标点， 从数列中挑出元素做基准定标点</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)                               </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = partition(arr, left, right);         <span class="comment">// 这个pivot的选取由分区函数实现，可以认为它有序了</span></span><br><span class="line">                                                   <span class="comment">// 接下来下层函数实现 pivot左边和右边的排序</span></span><br><span class="line">    quick_sort1(arr, left, idx - <span class="number">1</span>);</span><br><span class="line">    quick_sort1(arr, idx + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;    <span class="comment">//那么怎么找到这个定标点，使得比它小的在它左边，大的在它右边</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];                         <span class="comment">//定标的过程中也完成了局部的排序， 先选定pivot在最左侧(有不同选法)</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123;           <span class="comment">//本例做法:标定在左边，先判右边，在右边找到比pivot小的，</span></span><br><span class="line">            j--;        </span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[j];                           <span class="comment">//填入pivot的位置，而这个位置的值暂存在pivot中也不会丢失</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123;           <span class="comment">//再判断左边，此时arr[i]为新填入，一定会向右走，当遇到比pivot大的</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = arr[i];                           <span class="comment">//填到刚才换走数据的位置中</span></span><br><span class="line">    &#125;<span class="comment">//当i, j 相遇，此时比pivot小的已经全部换去左边，比pivot大的已经全部换去右边，这里是pivot的正确位置，填入并返回</span></span><br><span class="line"></span><br><span class="line">    arr[i] = pivot;    <span class="comment">//来回交换，但一次始终只交换一个，由pivot暂存有一个值，所以不会有数据丢失</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现简答，变种多，性能好(桶排序和计数排序不基于比较 所以能突破<code>O(nlog(n))</code>)</p>
<p>算法思路：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”<code>（pivot）</code>；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置(也是它最终的位置)。这个操作我们称之为分区<code>(partition)</code>；</li>
<li>递归地<code>(recursive)</code>把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p>最坏情况：<code>O(n^2) </code>每次分区，基准都位于最右边或者最左边<code> T(n) = T(n-1) + O(n) = T(n-2) + O(n-1) + O(n) =.....</code>.;  <code>partition</code> 为<code>O(n)</code> 两个指针 i, j 分别遍历<br>最好情况：<code>O(nlogn)</code>每次分区，基准值都位于中间， <code>T(n) = 2T(n/2) + n; </code>每次问题规模折半</p>
</blockquote>
<p><code>heap</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;     <span class="comment">//先构建大顶堆，使堆顶最大，左右子树也是大顶堆</span></span><br><span class="line">    build_heap(arr, n);             <span class="comment">//传入序列与长度完成构建,取最大值做顶</span></span><br><span class="line">    <span class="keyword">int</span> length = n;                 <span class="comment">//此时还没进行排序，认为 无序区的长度为 n</span></span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">1</span>) &#123;            <span class="comment">//单个节点为最小大顶堆</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, length - <span class="number">1</span>);   <span class="comment">//将此时的顶换至末尾，减少序列长度-&gt;认为最大(顶)排序完成</span></span><br><span class="line">        length--;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, length);    <span class="comment">//将长度减少的序列重新调整成大顶堆，实际最大数据已经填在数组正确位置不再对它操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到最后一个有孩子的结点         //分析数组，先把无序的数组认为是一个完全二叉树，要让这个数组满足大顶堆的性质</span></span><br><span class="line">                                    <span class="comment">//无序的完全二叉树不是堆，需要调整</span></span><br><span class="line">                                    <span class="comment">//调整从数组的末尾开始做起，找到最后一个有孩子的节点，认为它的孩子是大顶堆</span></span><br><span class="line">                                    <span class="comment">//把这个节点和它的孩子们这棵子树调整成大顶堆</span></span><br><span class="line">                                    <span class="comment">//往数组的前面继续...</span></span><br><span class="line">    <span class="comment">// 数组从0 开始编号 左孩子为2i+1 右孩子为 2i+2</span></span><br><span class="line">    <span class="comment">// i:  leftChild=2i + 1, rightChild = 2i + 2;</span></span><br><span class="line">    <span class="comment">// 找最后一个有孩子的节点序号i 判断有孩子，只要有左孩子就行</span></span><br><span class="line">    <span class="comment">// 2i + 1 &lt;= n - 1 --&gt; i &lt;= (n - 2) / 2;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//从最后一个有孩子的节点开始调整，调整完后下一个调整的是数组中排在它前面的</span></span><br><span class="line">        heapify(arr, i, n);                     <span class="comment">//依次完成调整，构建大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//从上往下调整为大顶堆</span></span><br><span class="line">                                         <span class="comment">//记录并与左右孩子比较</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = i;</span><br><span class="line">        <span class="keyword">int</span> leftChild = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightChild = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftChild &lt; n &amp;&amp; arr[leftChild] &gt; arr[maxIdx]) <span class="comment">//限制避免数组越界再比较</span></span><br><span class="line">            maxIdx = leftChild;</span><br><span class="line">        <span class="keyword">if</span> (rightChild &lt; n &amp;&amp; arr[rightChild] &gt; arr[maxIdx])</span><br><span class="line">            maxIdx = rightChild;</span><br><span class="line">        <span class="keyword">if</span> (maxIdx == i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i, maxIdx);</span><br><span class="line">        i = maxIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二叉堆 完全二叉树</p>
<p>大顶堆：堆顶元素最大，左右子树也是大顶堆</p>
<p>小顶堆：堆顶元素最小，左右子树也是小顶堆</p>
<p>堆:近似完全二叉树:性质:子节点的键值或索引总是小于（或者大于）它的父节点 </p>
<p><em>Wikipedia</em></p>
<p>以升序排序说明，把数组转换成最大堆(Max-Heap Heap)，这是一种满足最大堆性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。</p>
<p>思路：</p>
<ol>
<li>构建大顶堆</li>
<li>交换堆顶和无序区最后一个元素 此后 无序区元素个数-1，有序区元素个数+1</li>
<li>把无序区重新调整成大顶堆O(log(n))重复步骤2</li>
</ol>
<p>完全二叉树可以用数组去做-&gt;把待排序数组看成堆</p>
<p>先把待排序数组看做无序的完全二叉树 数组从前到后对应树的层序 ： 这个无序的完全二叉树不是堆，需要调整</p>
<p><strong>定义：单个节点的树是大顶堆</strong>找到第一个有孩子的节点 它的左右孩子一定是大顶堆然后把第一个有孩子的这棵树构建成大顶堆(做法:这个有孩子的节点与其左右孩子比较，大的改为父亲节点) –&gt;获得了第一个是大顶堆的子树以此类推-&gt;从后往前找，判，变      </p>
<p>大顶堆构建完成<br>由构建的过程知，堆顶元素为数组中最大元素，堆顶元素位于数组中索引为0的位置，交换它与数组的末尾</p>
</blockquote>
<p><code>二叉搜索与其变种</code></p>
<p><code>递归实现</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search1</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 边界条件</span></span><br><span class="line">	<span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">// 递归公式</span></span><br><span class="line">	<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line">		<span class="keyword">return</span> binary_search1(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)</span><br><span class="line">		<span class="keyword">return</span> binary_search1(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 边界条件</span></span><br><span class="line">	<span class="keyword">return</span> binary_search1(arr, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>循环实现</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>变种 </code>查找第一个与target相等的元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid == left || arr[mid - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找最后一个小于等于target值的元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt;= target) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mid == right || arr[mid + <span class="number">1</span>] &gt; target)</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找最后一个与key相等的元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找3</span></span><br><span class="line"><span class="comment">//&#123; 0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 4, 5, 6, 7, 8, 9 &#125;;</span></span><br><span class="line"><span class="comment">//                             |</span></span><br><span class="line"><span class="comment">//						     返回9</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (arr[mid] &lt; target) &#123;<span class="comment">//向右缩小范围</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;<span class="comment">//向左缩小范围</span></span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (mid == right || arr[mid+<span class="number">1</span>] &gt; target) &#123;<span class="comment">//处理相等，走到末尾(此时右边界)或者下个大于target可返回</span></span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找第一个大于等于key值的元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (arr[mid] &lt; target) &#123;<span class="comment">//向右缩小范围</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (mid == left || arr[mid<span class="number">-1</span>] &lt; target) &#123;<span class="comment">//当前arr[mid]&gt;= target 向左走到边界 或者遇见小的</span></span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......</span><br></pre></td></tr></table></figure>











<h2 id="写在后面-结"><a href="#写在后面-结" class="headerlink" title="写在后面(结)"></a>写在后面(结)</h2><blockquote>
<p>本次关于C的整理梳理工作暂时告一段落，总的来说，起初的基础知识方面的整理有些浮躁，不耐烦，但是在重看过程中发现了不少之前未注意到的点，多对自己提问，试图站在作者的角度思考这个问题的产生与解决，分析需求并给出解决办法是有好处的，新的视角会带来一些未曾有过的思考。</p>
<p>同时也发现学过或者说学过不止一遍不代表就是懂得，就是精通。越发感觉此前的学习方式存在不少问题。<strong>Talk is cheap. Show me the code.</strong></p>
</blockquote>

	  <div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>

	</div>

	
	<span id="/2022/02/17/5.C-Summarize-with-code/" class="leancloud-visitors view" data-flag-title="C_Summarize_with_code">
		<em class="post-meta-item-text"> Page View </em> <i class="leancloud-visitors-count"></i>
	</span>
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a href="/2022/02/26/6.Unix-Linux-file-management/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2022/02/10/4.C-Summarize/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>

-->
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2022-02-17 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2022 chen's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
