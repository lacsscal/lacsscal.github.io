<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Page 2 | lacsscal&#39;s blog</title>
  <meta name="author" content="chen">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="lacsscal&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="lacsscal&#39;s blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.0.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">lacsscal&#39;s blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>lacsscal&#39;s blog<span class="blink-fast">|</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/26/008.Unix-Linux.FileManagement/" >Unix/Linux-file-management</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-26  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><blockquote>
<p>关于一切皆文件这个理念</p>
<p>对于这个Unix设计哲学，之前是知道这个名词，但是要具体来说可能说不出什么，结合一些文件操作来理解可能更为清晰。(图画的丑: ))在程序的运行过程中，计算机是怎样去操作磁盘上的文件的? 在一个程序运行时，由CPU去代码段取一条条指令，并将指令执行生成的数据放入堆栈等数据区。那么指令的操作数在哪？在内存上，内存的数据是从磁盘上取出的，最终也会持久化的存储在磁盘上。从中取，往回存这两个操作是怎么做到的，把磁盘看做程序运行时的外部设备，它在内存上建立了映射区—称作文件缓冲区。文件缓冲区在内存上，但是影响外部设备。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/img%E6%96%87%E4%BB%B6_%E6%93%8D%E4%BD%9C.jpg"></p>
<blockquote>
<p>以此类推，目录文件，设备文件，管道文件等等，理念是一致的，对于众多的文件类型使用通用的方式去操作它们。文件操作操作的是内存上的数据，影响的是外部设备。对于Linux而言存在内核态与用户态，当文件操作涉及外部硬件时，用户态将这些操作委托给内核态去完成，这就离不开系统调用。</p>
<p>理解了这一点，就可以通过学习文件操作更深入的理解(操作文件会影响外部硬件，这个函数就不是普通的函数而是系统调用)。使用库函数和系统调用来操作文件，从库函数–&gt;系统调用。</p>
<p>基于文件指针的文件操作函数(ANSI 标准库函数) –&gt; 基于系统调用的文件操作</p>
</blockquote>
<h4 id="1-1-文件操作-基于-库函数-文件指针FILE"><a href="#1-1-文件操作-基于-库函数-文件指针FILE" class="headerlink" title="1.1 文件操作 - 基于(库函数)文件指针FILE*"></a>1.1 文件操作 - 基于(库函数)文件指针FILE*</h4><blockquote>
<p>从普通文件的打开与操作开始</p>
</blockquote>
<p><code>流</code>：表示任意输入<code>src</code>, 任意输出<code>dst</code> ，屏蔽硬件设备之间的差异，使得C像读写文件一样读写任意设备。</p>
<blockquote>
<p>内存与硬件设备存在读写性能上的鸿沟，OS在内存上为<code>流</code>设置缓冲区，C通过文件指针<code>FILE*</code>实现对流的访问, 启动任意进程OS将打开三个标准流<code>stdin</code> , <code>stdout</code>,  <code>stderr</code>.它们都默认与硬件关联。</p>
</blockquote>
<p>从普通文件操作开始, 读写之前先打开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">返回值是指针:暗含的意思-&gt;返回值指针指向必定不在被调函数栈帧(而在用户态某个空间，需用户自行释放)</span><br><span class="line">返回文件指针访问流</span><br><span class="line">|</span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* mode)</span></span>;</span><br><span class="line">                                                |</span><br><span class="line">                                            打开模式(考虑后续操作)</span><br><span class="line">                                            <span class="string">&quot;r&quot;</span> :只读打开</span><br><span class="line">                                            <span class="string">&quot;r+&quot;</span>:读写打开 文件必须存在</span><br><span class="line">                                            <span class="string">&quot;w&quot;</span> :只写创建 文件不需要存在</span><br><span class="line">                                            <span class="string">&quot;w+&quot;</span>:读写创建 文件存在就清空</span><br><span class="line">                                            <span class="string">&quot;a+&quot;</span>:读写追加 在原有数据后写入新值</span><br><span class="line">                                                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* stream)</span></span>;                                                    </span><br></pre></td></tr></table></figure>
	

	</div>
  <a type="button" href="/2022/02/26/008.Unix-Linux.FileManagement/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><blockquote>
<p>关于一切皆文件这个理念</p>
<p>对于这个Unix设计哲学，之前是知道这个名词，但是要具体来说可能说不出什么，结合一些文件操作来理解可能更为清晰。(图画的丑: ))在程序的运行过程中，计算机是怎样去操作磁盘上的文件的? 在一个程序运行时，由CPU去代码段取一条条指令，并将指令执行生成的数据放入堆栈等数据区。那么指令的操作数在哪？在内存上，内存的数据是从磁盘上取出的，最终也会持久化的存储在磁盘上。从中取，往回存这两个操作是怎么做到的，把磁盘看做程序运行时的外部设备，它在内存上建立了映射区—称作文件缓冲区。文件缓冲区在内存上，但是影响外部设备。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/img%E6%96%87%E4%BB%B6_%E6%93%8D%E4%BD%9C.jpg"></p>
<blockquote>
<p>以此类推，目录文件，设备文件，管道文件等等，理念是一致的，对于众多的文件类型使用通用的方式去操作它们。文件操作操作的是内存上的数据，影响的是外部设备。对于Linux而言存在内核态与用户态，当文件操作涉及外部硬件时，用户态将这些操作委托给内核态去完成，这就离不开系统调用。</p>
<p>理解了这一点，就可以通过学习文件操作更深入的理解(操作文件会影响外部硬件，这个函数就不是普通的函数而是系统调用)。使用库函数和系统调用来操作文件，从库函数–&gt;系统调用。</p>
<p>基于文件指针的文件操作函数(ANSI 标准库函数) –&gt; 基于系统调用的文件操作</p>
</blockquote>
<h4 id="1-1-文件操作-基于-库函数-文件指针FILE"><a href="#1-1-文件操作-基于-库函数-文件指针FILE" class="headerlink" title="1.1 文件操作 - 基于(库函数)文件指针FILE*"></a>1.1 文件操作 - 基于(库函数)文件指针FILE*</h4><blockquote>
<p>从普通文件的打开与操作开始</p>
</blockquote>
<p><code>流</code>：表示任意输入<code>src</code>, 任意输出<code>dst</code> ，屏蔽硬件设备之间的差异，使得C像读写文件一样读写任意设备。</p>
<blockquote>
<p>内存与硬件设备存在读写性能上的鸿沟，OS在内存上为<code>流</code>设置缓冲区，C通过文件指针<code>FILE*</code>实现对流的访问, 启动任意进程OS将打开三个标准流<code>stdin</code> , <code>stdout</code>,  <code>stderr</code>.它们都默认与硬件关联。</p>
</blockquote>
<p>从普通文件操作开始, 读写之前先打开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">返回值是指针:暗含的意思-&gt;返回值指针指向必定不在被调函数栈帧(而在用户态某个空间，需用户自行释放)</span><br><span class="line">返回文件指针访问流</span><br><span class="line">|</span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* mode)</span></span>;</span><br><span class="line">                                                |</span><br><span class="line">                                            打开模式(考虑后续操作)</span><br><span class="line">                                            <span class="string">&quot;r&quot;</span> :只读打开</span><br><span class="line">                                            <span class="string">&quot;r+&quot;</span>:读写打开 文件必须存在</span><br><span class="line">                                            <span class="string">&quot;w&quot;</span> :只写创建 文件不需要存在</span><br><span class="line">                                            <span class="string">&quot;w+&quot;</span>:读写创建 文件存在就清空</span><br><span class="line">                                            <span class="string">&quot;a+&quot;</span>:读写追加 在原有数据后写入新值</span><br><span class="line">                                                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* stream)</span></span>;                                                    </span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2022/02/26/008.Unix-Linux.FileManagement/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/26/007.Unix.Linux.start/" >Unix/Linux-file-management</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-26  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-一点历史"><a href="#0-一点历史" class="headerlink" title="0 .一点历史"></a>0 .一点历史</h3><blockquote>
<p>还是从一点历史引入，感觉了解一些历史缘由，会更好地理解采用某种特定实现技术的原因</p>
<p>看了一点《The art of Unix Programming》 序中有一句话挺吸引我</p>
<p><em>Unix is not so much an operating system as an oral history.  —-Neal Stephenson</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-&gt;(早期)批处理OS</span><br><span class="line">-&gt;(1960)MIT分时OS:多终端+大型机</span><br><span class="line">-&gt;(1965)AT&amp;T:Bell+MIT+GE(通用电气):Multics计划(全面通用分时OS:bye)</span><br><span class="line">-&gt;(1969)Bell认为该计划GG,退出 (不算失败，有些成果) ：Ken Thompson 写了 Space Travle, PDP-7小型机移植，对它重写OS内核并移植 称Unics</span><br><span class="line">-&gt;Unics(核心哲学:一切皆文件, 程序的目的只有一个-有效的完成目标 : 与Multics理念不同《The Art of Unix Programming》)</span><br><span class="line">-&gt;(1969)Linus Torvalds 在芬兰诞生</span><br><span class="line">-&gt;尝试用高级语言解决移植问题BCPL, PASCAL-&gt;编译出的内核性能不够好-&gt;根据BCPL发明C</span><br><span class="line">-&gt;(1973)Deneish Richie(C的主要发明者)用C重写了Unics系统(提供了管道等重要功能),更名为Unix</span><br><span class="line">-&gt;(1977)AT&amp;T将Unix源代码(用C写的,高可移植性)发给学术界-&gt;UC Berkeley-&gt;Bill Joy professor 编译成适合自己机器的系统，增减一些功能:命名为BSD(Berkeley Software Distribution)</span><br><span class="line">-&gt;(1979)AT&amp;T:推出System V(five(Sun - Solaris)):第七版(不再开源:商业纠纷开始):特性:可以支持x86架构的个人计算机</span><br><span class="line">-&gt;(1984)不再开源对教授OS的professor产生了影响:Andrew TannenBaum-&gt;自己写个Mini Unix -&gt; Minix</span><br><span class="line">-&gt;(1986)完成Minix, 并出版《Operating System : Design and Implementation》附带Minix的源代码</span><br><span class="line">        《Modern Operating System》也是他写的</span><br><span class="line">-&gt;同期 Richard Stallman 发起了GNU计划:GNU:Gnu is not Unix!(GCC, Emacs, Bash Shell, GDB...)目标创建一套完全自由的Unix OS(当时的Unix与硬件捆绑销售)但是缺少Unix内核</span><br><span class="line">-&gt;草拟 GPL协议(General Publilc License | 🙂 copyleft &lt;!-&gt; copyright:著作权) 开源 != 免费(维护可以收费)</span><br><span class="line">-&gt;(1988)IEEE:POSIX标准(旨在:保证各个OS间的兼容性) (IEEE-IX-&gt;POSIX:Portable Operating System Interface X:(Unix))可移植...</span><br><span class="line">-&gt;(1993)Linus:宏内核构造的Linux内核面世</span><br></pre></td></tr></table></figure>

<h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><blockquote>
<p>感觉之前学过很多次，并且每次学习也有用纸质或者文档记录，博客记录学到，使用过的命令，但大多情况学过不用就忘了，不是长久之计，这次就不记录这些。尽量多用以熟练。同时，本文的侧重点不在使用这方面，想要更深入的学习一些东西。</p>
</blockquote>
<blockquote>
<p>如果有不会的熟练使用 <code>$man</code></p>
<p>一点准备工作，环境使用的Ubuntu18.04 帮助手册不全<code>sudo apt install manpages-posix-dev</code></p>
</blockquote>
<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3>
	

	</div>
  <a type="button" href="/2022/02/26/007.Unix.Linux.start/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-一点历史"><a href="#0-一点历史" class="headerlink" title="0 .一点历史"></a>0 .一点历史</h3><blockquote>
<p>还是从一点历史引入，感觉了解一些历史缘由，会更好地理解采用某种特定实现技术的原因</p>
<p>看了一点《The art of Unix Programming》 序中有一句话挺吸引我</p>
<p><em>Unix is not so much an operating system as an oral history.  —-Neal Stephenson</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-&gt;(早期)批处理OS</span><br><span class="line">-&gt;(1960)MIT分时OS:多终端+大型机</span><br><span class="line">-&gt;(1965)AT&amp;T:Bell+MIT+GE(通用电气):Multics计划(全面通用分时OS:bye)</span><br><span class="line">-&gt;(1969)Bell认为该计划GG,退出 (不算失败，有些成果) ：Ken Thompson 写了 Space Travle, PDP-7小型机移植，对它重写OS内核并移植 称Unics</span><br><span class="line">-&gt;Unics(核心哲学:一切皆文件, 程序的目的只有一个-有效的完成目标 : 与Multics理念不同《The Art of Unix Programming》)</span><br><span class="line">-&gt;(1969)Linus Torvalds 在芬兰诞生</span><br><span class="line">-&gt;尝试用高级语言解决移植问题BCPL, PASCAL-&gt;编译出的内核性能不够好-&gt;根据BCPL发明C</span><br><span class="line">-&gt;(1973)Deneish Richie(C的主要发明者)用C重写了Unics系统(提供了管道等重要功能),更名为Unix</span><br><span class="line">-&gt;(1977)AT&amp;T将Unix源代码(用C写的,高可移植性)发给学术界-&gt;UC Berkeley-&gt;Bill Joy professor 编译成适合自己机器的系统，增减一些功能:命名为BSD(Berkeley Software Distribution)</span><br><span class="line">-&gt;(1979)AT&amp;T:推出System V(five(Sun - Solaris)):第七版(不再开源:商业纠纷开始):特性:可以支持x86架构的个人计算机</span><br><span class="line">-&gt;(1984)不再开源对教授OS的professor产生了影响:Andrew TannenBaum-&gt;自己写个Mini Unix -&gt; Minix</span><br><span class="line">-&gt;(1986)完成Minix, 并出版《Operating System : Design and Implementation》附带Minix的源代码</span><br><span class="line">        《Modern Operating System》也是他写的</span><br><span class="line">-&gt;同期 Richard Stallman 发起了GNU计划:GNU:Gnu is not Unix!(GCC, Emacs, Bash Shell, GDB...)目标创建一套完全自由的Unix OS(当时的Unix与硬件捆绑销售)但是缺少Unix内核</span><br><span class="line">-&gt;草拟 GPL协议(General Publilc License | 🙂 copyleft &lt;!-&gt; copyright:著作权) 开源 != 免费(维护可以收费)</span><br><span class="line">-&gt;(1988)IEEE:POSIX标准(旨在:保证各个OS间的兼容性) (IEEE-IX-&gt;POSIX:Portable Operating System Interface X:(Unix))可移植...</span><br><span class="line">-&gt;(1993)Linus:宏内核构造的Linux内核面世</span><br></pre></td></tr></table></figure>

<h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><blockquote>
<p>感觉之前学过很多次，并且每次学习也有用纸质或者文档记录，博客记录学到，使用过的命令，但大多情况学过不用就忘了，不是长久之计，这次就不记录这些。尽量多用以熟练。同时，本文的侧重点不在使用这方面，想要更深入的学习一些东西。</p>
</blockquote>
<blockquote>
<p>如果有不会的熟练使用 <code>$man</code></p>
<p>一点准备工作，环境使用的Ubuntu18.04 帮助手册不全<code>sudo apt install manpages-posix-dev</code></p>
</blockquote>
<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3>
	
	</div>
  <a type="button" href="/2022/02/26/007.Unix.Linux.start/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/17/006.sort-algorithm/" >Sort-Algorithm</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-17  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h3 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title=". 常见排序算法"></a>. 常见排序算法</h3><blockquote>
<p>关于排序算法分析</p>
<p>1.时间复杂度</p>
<p>冒泡排序，插入排序，简单选择排序无法突破<code>O(n2)</code>时间复杂度，因为其有序化过程中都是一个一个来减少逆序度的，当逆序度为0时整个序列有序，相对的希尔，并归，快排，堆排能突破是因为其不依赖相邻元素逐个排序。</p>
<ul>
<li><p>最好，最坏，平均   </p>
<p>分析时间复杂度，要给出 最好，最坏，平均情况下的时间复杂度(给出最好，最坏情况下对应要排序的原始数据情况)</p>
<ul>
<li><p>平均时间复杂度分析</p>
<p>n个元素有n!种排序，然后统计比较和交换的次数，再计算平均值。想想就十分复杂。</p>
<p>这里我们采用逆序对的方式来分析。</p>
<p>有序元素对：<code>arr[i] &lt;= arr[j], i &lt; j  </code></p>
<p>逆序元素对：<code>arr[i] &gt; arr[j], i &lt; j</code></p>
<p>有序度：数组中有序元素对的个数</p>
<p>逆序度：数组中逆序元素对的个数</p>
<p>满有序度：数组排好序后的有序度。</p>
<p>假设数组有n个元素，满有序度 =  <code>n(n-1)/2</code></p>
<p>公式： 满有序度 = 有序度 + 逆序度排序过程就是增加有序度，减少逆序度，最终达到满有序度的过程。</p>
</li>
</ul>
</li>
<li><p>常数，系数，低阶  </p>
<p>时间复杂度反应规模n很大时的增长趋势，忽略常数，系数，低阶(考虑规模小的数据时考虑这些因素)</p>
</li>
<li><p>比较， 交换  </p>
<p>基于比较的排序算法涉及元素的比较，交换，分析效率要考虑这些</p>
</li>
</ul>
<p>2.空间复杂度  </p>
<p>是否是原地算法</p>
<p>3.稳定性  </p>
<p>待排序列中存在值相等的元素，排序后这些元素间的前后关系是否不变</p>
</blockquote>
<p><code>bubble</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// i 表示冒泡的次数，也就是比较的趟数</span></span><br><span class="line">        <span class="keyword">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//每趟比较中，j从0开始取相邻两个元素比较(交换),每趟一定有一个元素有序排好，可以利用i</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;<span class="comment">//做点优化，使得有序(这趟没执行交换)之后结束排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有序度是数组中具有有序关系的元素对的个数。如果一个数组完全有序，有序度就是<code>Cn2 = n(n-1)/2</code>，这种叫做满有序度。</p>
<p>对于冒泡排序来说，交换会导致：有序度+1， 逆序度-1.</p>
<p>所以 交换的次数 = 逆序度。可以简单的认为平均情况下，逆序度 = <code> n(n-1)/4</code> 比较的次数肯定比交换的次数多，但少于 <code>n(n-1)/2</code>所以平均情况下，时间复杂度为<code>O(n2)</code></p>
</blockquote>
<p><code>selection</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// i表示选择元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = i;<span class="comment">//先预设当前索引所指数为最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//j从后一个元素开始向后找有无更小的</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每趟先假定本趟开头为最小元素，记录其索引，从其后一个元素开始向后遍历，找到更小的，更新最小元索引记录一趟走完交换本趟开头与最小<br>发生长距离的交换 所以不稳定</p>
<p>[5, 5, 1, 2, 3, 0, ]第一个5换到第二个5后面</p>
<p><code>O(n2) </code>不存在最好最坏，都是<code>O(n2)</code></p>
</blockquote>
<p><code>insertion</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">// i代表待插入元素的索引，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">int</span> val = arr[i];<span class="comment">//先记录，如果要插到前面的话需要前方元素后移，可能会覆盖它</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">//找到待插元素的前一个元素</span></span><br><span class="line">        <span class="comment">// 元素(比记录的待插元素大)往后移(凡比ta大的都后移，留出ta的位置)</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
	

	</div>
  <a type="button" href="/2022/02/17/006.sort-algorithm/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h3 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title=". 常见排序算法"></a>. 常见排序算法</h3><blockquote>
<p>关于排序算法分析</p>
<p>1.时间复杂度</p>
<p>冒泡排序，插入排序，简单选择排序无法突破<code>O(n2)</code>时间复杂度，因为其有序化过程中都是一个一个来减少逆序度的，当逆序度为0时整个序列有序，相对的希尔，并归，快排，堆排能突破是因为其不依赖相邻元素逐个排序。</p>
<ul>
<li><p>最好，最坏，平均   </p>
<p>分析时间复杂度，要给出 最好，最坏，平均情况下的时间复杂度(给出最好，最坏情况下对应要排序的原始数据情况)</p>
<ul>
<li><p>平均时间复杂度分析</p>
<p>n个元素有n!种排序，然后统计比较和交换的次数，再计算平均值。想想就十分复杂。</p>
<p>这里我们采用逆序对的方式来分析。</p>
<p>有序元素对：<code>arr[i] &lt;= arr[j], i &lt; j  </code></p>
<p>逆序元素对：<code>arr[i] &gt; arr[j], i &lt; j</code></p>
<p>有序度：数组中有序元素对的个数</p>
<p>逆序度：数组中逆序元素对的个数</p>
<p>满有序度：数组排好序后的有序度。</p>
<p>假设数组有n个元素，满有序度 =  <code>n(n-1)/2</code></p>
<p>公式： 满有序度 = 有序度 + 逆序度排序过程就是增加有序度，减少逆序度，最终达到满有序度的过程。</p>
</li>
</ul>
</li>
<li><p>常数，系数，低阶  </p>
<p>时间复杂度反应规模n很大时的增长趋势，忽略常数，系数，低阶(考虑规模小的数据时考虑这些因素)</p>
</li>
<li><p>比较， 交换  </p>
<p>基于比较的排序算法涉及元素的比较，交换，分析效率要考虑这些</p>
</li>
</ul>
<p>2.空间复杂度  </p>
<p>是否是原地算法</p>
<p>3.稳定性  </p>
<p>待排序列中存在值相等的元素，排序后这些元素间的前后关系是否不变</p>
</blockquote>
<p><code>bubble</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// i 表示冒泡的次数，也就是比较的趟数</span></span><br><span class="line">        <span class="keyword">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//每趟比较中，j从0开始取相邻两个元素比较(交换),每趟一定有一个元素有序排好，可以利用i</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;<span class="comment">//做点优化，使得有序(这趟没执行交换)之后结束排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有序度是数组中具有有序关系的元素对的个数。如果一个数组完全有序，有序度就是<code>Cn2 = n(n-1)/2</code>，这种叫做满有序度。</p>
<p>对于冒泡排序来说，交换会导致：有序度+1， 逆序度-1.</p>
<p>所以 交换的次数 = 逆序度。可以简单的认为平均情况下，逆序度 = <code> n(n-1)/4</code> 比较的次数肯定比交换的次数多，但少于 <code>n(n-1)/2</code>所以平均情况下，时间复杂度为<code>O(n2)</code></p>
</blockquote>
<p><code>selection</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// i表示选择元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = i;<span class="comment">//先预设当前索引所指数为最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//j从后一个元素开始向后找有无更小的</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每趟先假定本趟开头为最小元素，记录其索引，从其后一个元素开始向后遍历，找到更小的，更新最小元索引记录一趟走完交换本趟开头与最小<br>发生长距离的交换 所以不稳定</p>
<p>[5, 5, 1, 2, 3, 0, ]第一个5换到第二个5后面</p>
<p><code>O(n2) </code>不存在最好最坏，都是<code>O(n2)</code></p>
</blockquote>
<p><code>insertion</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">// i代表待插入元素的索引，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">int</span> val = arr[i];<span class="comment">//先记录，如果要插到前面的话需要前方元素后移，可能会覆盖它</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">//找到待插元素的前一个元素</span></span><br><span class="line">        <span class="comment">// 元素(比记录的待插元素大)往后移(凡比ta大的都后移，留出ta的位置)</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2022/02/17/006.sort-algorithm/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/10/004.C-Summarize/" >C Summarize</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-10  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>  ……</p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-历史"><a href="#0-历史" class="headerlink" title="0.历史"></a>0.历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ken Thompson为了游戏(Space Travel)</span><br><span class="line">Multics -&gt; Unics(最初汇编PDP-7,移植性问题-&gt;发明BCPL:B语言)-&gt;</span><br><span class="line">Dennis Ritchie加入</span><br><span class="line">Dennis Ritchie-&gt;B不适合Unics(内核)开发:发明C -&gt; 用C重写Unics更名为Unix</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论： C用来<strong>开发系统软件</strong> (重写Unics系统,而此系统是K为了发挥PDP-7的全部性能以玩游戏而产生的)：       </p>
<p>所以C没有try-catch机制(耗费性能)       C与汇编有强对应关系</p>
</blockquote>
<h3 id="1-虚拟内存空间"><a href="#1-虚拟内存空间" class="headerlink" title="1.虚拟内存空间"></a>1.虚拟内存空间</h3><blockquote>
<p>源码经-&gt;预处理-&gt;编译-&gt;汇编-&gt;链接  程序-静态</p>
</blockquote>
<blockquote>
<p>变成了可执行文件，而可执行文件加载进内存变为进程，用于独立的虚拟内存空间 进程-动态</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/15/fDxObctmSZCYWNM.png" alt="虚拟内存空间.png"></p>
<p>每个进程有自己的虚拟内存空间，而这个图可以辅助理解一些语言以及程序的相关特性。</p>
	

	</div>
  <a type="button" href="/2022/02/10/004.C-Summarize/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>  ……</p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-历史"><a href="#0-历史" class="headerlink" title="0.历史"></a>0.历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ken Thompson为了游戏(Space Travel)</span><br><span class="line">Multics -&gt; Unics(最初汇编PDP-7,移植性问题-&gt;发明BCPL:B语言)-&gt;</span><br><span class="line">Dennis Ritchie加入</span><br><span class="line">Dennis Ritchie-&gt;B不适合Unics(内核)开发:发明C -&gt; 用C重写Unics更名为Unix</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论： C用来<strong>开发系统软件</strong> (重写Unics系统,而此系统是K为了发挥PDP-7的全部性能以玩游戏而产生的)：       </p>
<p>所以C没有try-catch机制(耗费性能)       C与汇编有强对应关系</p>
</blockquote>
<h3 id="1-虚拟内存空间"><a href="#1-虚拟内存空间" class="headerlink" title="1.虚拟内存空间"></a>1.虚拟内存空间</h3><blockquote>
<p>源码经-&gt;预处理-&gt;编译-&gt;汇编-&gt;链接  程序-静态</p>
</blockquote>
<blockquote>
<p>变成了可执行文件，而可执行文件加载进内存变为进程，用于独立的虚拟内存空间 进程-动态</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/15/fDxObctmSZCYWNM.png" alt="虚拟内存空间.png"></p>
<p>每个进程有自己的虚拟内存空间，而这个图可以辅助理解一些语言以及程序的相关特性。</p>
	
	</div>
  <a type="button" href="/2022/02/10/004.C-Summarize/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/10/005.recursion/" >Recursion</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-10  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>  ……</p>
</blockquote>
<h3 id="递归-recursion"><a href="#递归-recursion" class="headerlink" title="递归 recursion"></a><strong>递归 recursion</strong></h3><p>定义时调用本身 (传统引例为:斐波那契数列求和，其实这并不是一个很好的例子(画出递归树可知有<strong>太多重复计算</strong>性能差))</p>
<p><strong>但作为分析案例是合适的</strong></p>
<p>它满足以下条件：</p>
<ul>
<li>大问题分解为小问题</li>
<li>大小问题求解方式一致，只是规模不同</li>
<li>小问题的解可合成大问题的解</li>
</ul>
<p>可是使用递归，但注意在递归代码书写时，一定要有:</p>
<ul>
<li><p>边界条件(没有的话会调用下去直到Stack Overflow)</p>
</li>
<li><p>递归公式要考虑重复计算问题:</p>
</li>
</ul>
<p>以斐波那契为例，由于存在重复计算问题，其实效率不高</p>
<p>总结：<strong>得出递归公式，知道边界条件且解决重复计算问题可用递归</strong></p>
	

	</div>
  <a type="button" href="/2022/02/10/005.recursion/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>  ……</p>
</blockquote>
<h3 id="递归-recursion"><a href="#递归-recursion" class="headerlink" title="递归 recursion"></a><strong>递归 recursion</strong></h3><p>定义时调用本身 (传统引例为:斐波那契数列求和，其实这并不是一个很好的例子(画出递归树可知有<strong>太多重复计算</strong>性能差))</p>
<p><strong>但作为分析案例是合适的</strong></p>
<p>它满足以下条件：</p>
<ul>
<li>大问题分解为小问题</li>
<li>大小问题求解方式一致，只是规模不同</li>
<li>小问题的解可合成大问题的解</li>
</ul>
<p>可是使用递归，但注意在递归代码书写时，一定要有:</p>
<ul>
<li><p>边界条件(没有的话会调用下去直到Stack Overflow)</p>
</li>
<li><p>递归公式要考虑重复计算问题:</p>
</li>
</ul>
<p>以斐波那契为例，由于存在重复计算问题，其实效率不高</p>
<p>总结：<strong>得出递归公式，知道边界条件且解决重复计算问题可用递归</strong></p>
	
	</div>
  <a type="button" href="/2022/02/10/005.recursion/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/01/22/003.Hello-New-World-build-history/" >Hello New Worldhistory</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-01-22  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60578464">参考</a><br><a target="_blank" rel="noopener" href="https://ares-x.com/2019/12/29/freemind-bithack-readme-zh/">主题参考</a><br><a target="_blank" rel="noopener" href="https://lacsscal.github.io/">实现效果</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>原理：本地撰写MarkDown文档，Hexo解析渲染成具有主题样式的HTML静态网页，推送至GitHub完成发布。</p>
</blockquote>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li> 环境 nodejs, git</li>
<li> 连接GitHub</li>
<li> 添加Github SSH秘钥 并验证连接</li>
<li> 创建GitHub仓库</li>
<li> 本地安装Hexo博客并测试</li>
<li> <strong>部署</strong>注意分支名(main/master）到github上</li>
<li> 验证</li>
</ol>
<h2 id="本地Hexo"><a href="#本地Hexo" class="headerlink" title="本地Hexo"></a>本地Hexo</h2><blockquote>
<p>前面的准备过程跳过，以前搭过，环境还在，环境配置也不难<br>下面从Hexo本地安装开始<br>因为Hexo是基于Node.js的静态博客框架，可以经由npm一键安装</p>
</blockquote>
<pre><code>npm install -g hexo-cli #安装命令
</code></pre>
<p>安装好后初始化即可，选一个空文件夹初始化并安装所需组件</p>
<pre><code>hexo init      # 初始化
npm install    # 安装组件
</code></pre>
	

	</div>
  <a type="button" href="/2022/01/22/003.Hello-New-World-build-history/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60578464">参考</a><br><a target="_blank" rel="noopener" href="https://ares-x.com/2019/12/29/freemind-bithack-readme-zh/">主题参考</a><br><a target="_blank" rel="noopener" href="https://lacsscal.github.io/">实现效果</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>原理：本地撰写MarkDown文档，Hexo解析渲染成具有主题样式的HTML静态网页，推送至GitHub完成发布。</p>
</blockquote>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li> 环境 nodejs, git</li>
<li> 连接GitHub</li>
<li> 添加Github SSH秘钥 并验证连接</li>
<li> 创建GitHub仓库</li>
<li> 本地安装Hexo博客并测试</li>
<li> <strong>部署</strong>注意分支名(main/master）到github上</li>
<li> 验证</li>
</ol>
<h2 id="本地Hexo"><a href="#本地Hexo" class="headerlink" title="本地Hexo"></a>本地Hexo</h2><blockquote>
<p>前面的准备过程跳过，以前搭过，环境还在，环境配置也不难<br>下面从Hexo本地安装开始<br>因为Hexo是基于Node.js的静态博客框架，可以经由npm一键安装</p>
</blockquote>
<pre><code>npm install -g hexo-cli #安装命令
</code></pre>
<p>安装好后初始化即可，选一个空文件夹初始化并安装所需组件</p>
<pre><code>hexo init      # 初始化
npm install    # 安装组件
</code></pre>
	
	</div>
  <a type="button" href="/2022/01/22/003.Hello-New-World-build-history/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/01/22/002.test2/" >test2</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-01-22  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<p>test 2 <em>version2.0</em></p>

	

	</div>
  <a type="button" href="/2022/01/22/002.test2/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>test 2 <em>version2.0</em></p>

	
	</div>
  <a type="button" href="/2022/01/22/002.test2/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/01/21/001.hello-world/" >Hello World</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-01-21  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
	

	</div>
  <a type="button" href="/2022/01/21/001.hello-world/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2022/01/21/001.hello-world/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
     <a href="/" type="button" class="btn btn-default"><i class="fa fa-arrow-circle-o-left"></i> Prev</a>
      

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
          <a type="button" class="btn btn-default disabled">Next<i class="fa fa-arrow-circle-o-right"></i></a>
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/database/">database<span>1</span></a></li>
		
			<li><a href="/tags/xxxx/">xxxx<span>4</span></a></li>
		
			<li><a href="/tags/Unix-Linux/">Unix/Linux<span>7</span></a></li>
		
			<li><a href="/tags/C-C/">C/C++<span>3</span></a></li>
		
			<li><a href="/tags/UNIX-APUE/">UNIX APUE<span>1</span></a></li>
		
			<li><a href="/tags/Proj/">Proj<span>2</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2022/04/24/12.regex/" ><i class="fa fa-file-o"></i>12.regex</a>
      </li>
    
      <li>
        <a href="/2022/03/26/Unix-Linux-proj-netDsic-II/" ><i class="fa fa-file-o"></i>Unix-Linux-proj-netDsic-II</a>
      </li>
    
      <li>
        <a href="/2022/03/14/13.database1/" ><i class="fa fa-file-o"></i>database1</a>
      </li>
    
      <li>
        <a href="/2022/03/14/11.Unix-Linux-NetworkProgramming-II/" ><i class="fa fa-file-o"></i>Unix-Linux-NetworkProgrammi...</a>
      </li>
    
      <li>
        <a href="/2022/03/14/Unix-Linux-proj-netdisc/" ><i class="fa fa-file-o"></i>netdisk</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/lacsscal" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2022 chen's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
