<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>lacsscal&#39;s blog</title>
  <meta name="author" content="chen">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="lacsscal&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="lacsscal&#39;s blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.0.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">lacsscal&#39;s blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>lacsscal&#39;s blog<span class="blink-fast">|</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/04/24/012.regex/" >12.regex</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-04-24  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>最初是由Unix 的grep 和sed等工具软件普及开的。</p>
<p>使用单个(模式)字符串描述，匹配一系列匹配某句法规则的字符串</p>
<p>一个学习的GitHub项目<a target="_blank" rel="noopener" href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">learn_regex</a></p>
<p>一个练习题库<a target="_blank" rel="noopener" href="https://regex101.com/">在线题库</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220422200036382.png" alt="POSIX字符组"></p>
<blockquote>
<p>正则表达式的POSIX规范，分为:</p>
<p>基本型正则表达式（Basic Regular Expression，BRE）<br>和扩展型正则表达式（Extended Regular Expression，ERE）两大流派。<br>前者的元字符需要转义，后者的不需要(包括egrep awk)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">基本正则表达式的元字符：</span><br><span class="line">	字符匹配：</span><br><span class="line">		.: 匹配任意单个字符</span><br><span class="line">		[]: 匹配指定范围内的任意单个字符</span><br><span class="line">			[0-9], [[:digit:]]</span><br><span class="line">			[a-z], [[:lower:]]</span><br><span class="line">			[A-Z], [[:upper:]]</span><br><span class="line">			[[:space:]]</span><br><span class="line">			[[:punct:]]</span><br><span class="line">			[[:alpha:]]</span><br><span class="line">			[[:alnum:]]</span><br><span class="line">		[^]:</span><br><span class="line">	次数匹配元字符：用于实现指定其前面的字符所能够出现的次数</span><br><span class="line">		*: 任意长度，它前面的字符可以出现任意次</span><br><span class="line">			例如：x*y</span><br><span class="line">				xxy, xyy, y, </span><br><span class="line">		\\?: 0次或1次，它前面的字符是可有可无的</span><br><span class="line">			例如：x\\?y</span><br><span class="line">				xy, y, ay</span><br><span class="line">		\\&#123;m\\&#125;: m次，它前的字符要出现m次</span><br><span class="line">			例如：x\\&#123;2\\&#125;y</span><br><span class="line">				xy, xxy, y, xxxxy, xyy</span><br><span class="line">		\\&#123;m,n\\&#125;: 至少m次，至多n次</span><br><span class="line">			例如：x\\&#123;2,5\\&#125;y</span><br><span class="line">				xy, y, xxy</span><br><span class="line">		\\&#123;m,\\&#125;：至少m次</span><br><span class="line">		\\&#123;0,n\\&#125;: 至多n次</span><br><span class="line"></span><br><span class="line">		.*：任意长度的任意字符</span><br><span class="line"></span><br><span class="line">	位置锚定：</span><br><span class="line">		^: 行首锚定；</span><br><span class="line">			写在模式最左侧</span><br><span class="line">		$: 行尾锚定：</span><br><span class="line">			写在模式最右侧</span><br><span class="line">		^$: 空白行</span><br><span class="line">			</span><br><span class="line">			不包含特殊字符的连续字符组成的串叫单词：</span><br><span class="line">		\\&lt;: 词首，出现于单词左侧</span><br><span class="line">			\\&lt;char</span><br><span class="line">		\\&gt;: 词尾，出现于单词右侧</span><br><span class="line">			char\\&gt;</span><br><span class="line">	</span><br><span class="line">	分组...</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">扩展正则表达式：</span><br><span class="line">	字符匹配：</span><br><span class="line">		.</span><br><span class="line">		[]</span><br><span class="line">		[^]</span><br><span class="line">	次数匹配：</span><br><span class="line">		*：任意次</span><br><span class="line">		?: 0次或1次</span><br><span class="line">		+: 至少1次；</span><br><span class="line">		&#123;m&#125;: 精确匹配m次</span><br><span class="line">		&#123;m,n&#125;: 至少m次，至多n次</span><br><span class="line">		&#123;m,&#125;</span><br><span class="line">		&#123;0,n&#125;</span><br><span class="line">	位置锚定：</span><br><span class="line">		^</span><br><span class="line">		$</span><br><span class="line">		\&lt;, </span><br><span class="line">		\&gt;, </span><br><span class="line">		^$, ^[[:space:]]*$</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="应用到grep"><a href="#应用到grep" class="headerlink" title="应用到grep"></a>应用到grep</h1>
	

	</div>
  <a type="button" href="/2022/04/24/012.regex/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>最初是由Unix 的grep 和sed等工具软件普及开的。</p>
<p>使用单个(模式)字符串描述，匹配一系列匹配某句法规则的字符串</p>
<p>一个学习的GitHub项目<a target="_blank" rel="noopener" href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">learn_regex</a></p>
<p>一个练习题库<a target="_blank" rel="noopener" href="https://regex101.com/">在线题库</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220422200036382.png" alt="POSIX字符组"></p>
<blockquote>
<p>正则表达式的POSIX规范，分为:</p>
<p>基本型正则表达式（Basic Regular Expression，BRE）<br>和扩展型正则表达式（Extended Regular Expression，ERE）两大流派。<br>前者的元字符需要转义，后者的不需要(包括egrep awk)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">基本正则表达式的元字符：</span><br><span class="line">	字符匹配：</span><br><span class="line">		.: 匹配任意单个字符</span><br><span class="line">		[]: 匹配指定范围内的任意单个字符</span><br><span class="line">			[0-9], [[:digit:]]</span><br><span class="line">			[a-z], [[:lower:]]</span><br><span class="line">			[A-Z], [[:upper:]]</span><br><span class="line">			[[:space:]]</span><br><span class="line">			[[:punct:]]</span><br><span class="line">			[[:alpha:]]</span><br><span class="line">			[[:alnum:]]</span><br><span class="line">		[^]:</span><br><span class="line">	次数匹配元字符：用于实现指定其前面的字符所能够出现的次数</span><br><span class="line">		*: 任意长度，它前面的字符可以出现任意次</span><br><span class="line">			例如：x*y</span><br><span class="line">				xxy, xyy, y, </span><br><span class="line">		\\?: 0次或1次，它前面的字符是可有可无的</span><br><span class="line">			例如：x\\?y</span><br><span class="line">				xy, y, ay</span><br><span class="line">		\\&#123;m\\&#125;: m次，它前的字符要出现m次</span><br><span class="line">			例如：x\\&#123;2\\&#125;y</span><br><span class="line">				xy, xxy, y, xxxxy, xyy</span><br><span class="line">		\\&#123;m,n\\&#125;: 至少m次，至多n次</span><br><span class="line">			例如：x\\&#123;2,5\\&#125;y</span><br><span class="line">				xy, y, xxy</span><br><span class="line">		\\&#123;m,\\&#125;：至少m次</span><br><span class="line">		\\&#123;0,n\\&#125;: 至多n次</span><br><span class="line"></span><br><span class="line">		.*：任意长度的任意字符</span><br><span class="line"></span><br><span class="line">	位置锚定：</span><br><span class="line">		^: 行首锚定；</span><br><span class="line">			写在模式最左侧</span><br><span class="line">		$: 行尾锚定：</span><br><span class="line">			写在模式最右侧</span><br><span class="line">		^$: 空白行</span><br><span class="line">			</span><br><span class="line">			不包含特殊字符的连续字符组成的串叫单词：</span><br><span class="line">		\\&lt;: 词首，出现于单词左侧</span><br><span class="line">			\\&lt;char</span><br><span class="line">		\\&gt;: 词尾，出现于单词右侧</span><br><span class="line">			char\\&gt;</span><br><span class="line">	</span><br><span class="line">	分组...</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">扩展正则表达式：</span><br><span class="line">	字符匹配：</span><br><span class="line">		.</span><br><span class="line">		[]</span><br><span class="line">		[^]</span><br><span class="line">	次数匹配：</span><br><span class="line">		*：任意次</span><br><span class="line">		?: 0次或1次</span><br><span class="line">		+: 至少1次；</span><br><span class="line">		&#123;m&#125;: 精确匹配m次</span><br><span class="line">		&#123;m,n&#125;: 至少m次，至多n次</span><br><span class="line">		&#123;m,&#125;</span><br><span class="line">		&#123;0,n&#125;</span><br><span class="line">	位置锚定：</span><br><span class="line">		^</span><br><span class="line">		$</span><br><span class="line">		\&lt;, </span><br><span class="line">		\&gt;, </span><br><span class="line">		^$, ^[[:space:]]*$</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="应用到grep"><a href="#应用到grep" class="headerlink" title="应用到grep"></a>应用到grep</h1>
	
	</div>
  <a type="button" href="/2022/04/24/012.regex/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/14/013.database1/" >database1</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-14  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="Navicat-连接mysql"><a href="#Navicat-连接mysql" class="headerlink" title="Navicat 连接mysql"></a>Navicat 连接mysql</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装C-sql依赖的dev</span></span><br><span class="line"></span><br><span class="line">[scallacs@scallacs ~\ []$ sudo apt install libmysqlclient-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改配置文件</span></span><br><span class="line">[scallacs@scallacs ~\ []$ <span class="built_in">cd</span> /etc/mysql/mysql.conf.d/</span><br><span class="line">[scallacs@scallacs /etc/mysql/mysql.conf.d\ []$ sudo vim mysqld.cnf </span><br><span class="line">[sudo] password <span class="keyword">for</span> scallacs: </span><br><span class="line">[scallacs@scallacs /etc/mysql/mysql.conf.d\ []$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220326150818014.png" alt="image-20220326150818014"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 修改mysql配置</span></span><br><span class="line">$ mysql -u root -p</span><br><span class="line">&gt; use mysql;</span><br><span class="line">&gt; select host, user from user;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 将表项  localhost 改为 % , 重启服务，或者刷新权限</span></span><br><span class="line">&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220323171238791.png" alt="image-20220323171238791" style="zoom: 80%;">

<img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220323171301807.png" alt="image-20220323171301807" style="zoom: 80%;">

	

	</div>
  <a type="button" href="/2022/03/14/013.database1/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="Navicat-连接mysql"><a href="#Navicat-连接mysql" class="headerlink" title="Navicat 连接mysql"></a>Navicat 连接mysql</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装C-sql依赖的dev</span></span><br><span class="line"></span><br><span class="line">[scallacs@scallacs ~\ []$ sudo apt install libmysqlclient-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改配置文件</span></span><br><span class="line">[scallacs@scallacs ~\ []$ <span class="built_in">cd</span> /etc/mysql/mysql.conf.d/</span><br><span class="line">[scallacs@scallacs /etc/mysql/mysql.conf.d\ []$ sudo vim mysqld.cnf </span><br><span class="line">[sudo] password <span class="keyword">for</span> scallacs: </span><br><span class="line">[scallacs@scallacs /etc/mysql/mysql.conf.d\ []$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220326150818014.png" alt="image-20220326150818014"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 修改mysql配置</span></span><br><span class="line">$ mysql -u root -p</span><br><span class="line">&gt; use mysql;</span><br><span class="line">&gt; select host, user from user;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 将表项  localhost 改为 % , 重启服务，或者刷新权限</span></span><br><span class="line">&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220323171238791.png" alt="image-20220323171238791" style="zoom: 80%;">

<img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220323171301807.png" alt="image-20220323171301807" style="zoom: 80%;">

	
	</div>
  <a type="button" href="/2022/03/14/013.database1/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/13/010.Unix-Linux-Network-Programming/" >Unix-Linux-Network-Programming</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-13  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><blockquote>
<p>Berkeley socket 伯克利套接字，网络编程的实施标准</p>
<p>socket是网络中用来建立连接，网络通信的设备，用户创建socket可以通过其发起或接受TCP连接，可以向TCP的<strong>发送和接收缓冲区中读写TCP数据段</strong>，或者UCP文本</p>
<p>大小端问题(一个源于商业的历史遗留问题)一般主机使用小端法(主机字节序)，而用于网络传输，使用大端法(网络字节序) 判断方式如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *c=(<span class="keyword">char</span> *)&amp;i; </span><br><span class="line">    <span class="keyword">if</span>(*c == <span class="number">0x12</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;big ending!&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;little ending!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/testendong ./isBigEnding </span><br><span class="line">little ending!</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><blockquote>
<p>设计网络需要的几个结构体(设置地址信息)</p>
<p>通用的地址结构 <code>struct sockadd</code> 但是过于通用导致设置复杂，惯用法是通过以下两个结构体来构造地址，利用其<strong>内存布局一致的特点</strong>强转为<code>struct sockaddr </code>作为参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//man 7 ip </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* address family: AF_INET */</span> </span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port; <span class="comment">/* port in network byte order */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* internet address */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Internet address. */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_addr; <span class="comment">/* address in network byte order */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>整数大小端转化接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>



<p>网络字节序IP与点分十进制IP转化接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>



<p>使用域名获取IP的接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name; <span class="comment">/* official name of host */</span> </span><br><span class="line">    <span class="keyword">char</span> **h_aliases; <span class="comment">/* alias list */</span> </span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">/* host address type */</span> </span><br><span class="line">    <span class="keyword">int</span> h_length; <span class="comment">/* length of address */</span> </span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">/* list of addresses */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把TCP的通信机制看做两条管道，通信双方为A和B，三次握手分别做了一下几件事</span><br><span class="line">第一次握手A-&gt;B : 现在B知道了A-&gt;B 的通信是正常的  即B知道:A的发送B的接收正常</span><br><span class="line">第二次握手B-&gt;A : 现在A知道了A-&gt;B 与 B-&gt;A的通信是正常的 即A知道:A与B的收发都正常，但B不能确定A的收正常</span><br><span class="line">第三次握手A-&gt;B : 现在A知道自己的收发和B的收发都没有问题，而B还需确认A的接收能力。</span><br><span class="line"></span><br><span class="line">如果只有两次握手，那么B是没能确认A的接收能力的，如果认为两次握手后通信无误，那么A可能只是发了连接请求就关闭了此时认为连接建立成功的B只能永久等待</span><br></pre></td></tr></table></figure>
	

	</div>
  <a type="button" href="/2022/03/13/010.Unix-Linux-Network-Programming/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><blockquote>
<p>Berkeley socket 伯克利套接字，网络编程的实施标准</p>
<p>socket是网络中用来建立连接，网络通信的设备，用户创建socket可以通过其发起或接受TCP连接，可以向TCP的<strong>发送和接收缓冲区中读写TCP数据段</strong>，或者UCP文本</p>
<p>大小端问题(一个源于商业的历史遗留问题)一般主机使用小端法(主机字节序)，而用于网络传输，使用大端法(网络字节序) 判断方式如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *c=(<span class="keyword">char</span> *)&amp;i; </span><br><span class="line">    <span class="keyword">if</span>(*c == <span class="number">0x12</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;big ending!&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;little ending!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/testendong ./isBigEnding </span><br><span class="line">little ending!</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><blockquote>
<p>设计网络需要的几个结构体(设置地址信息)</p>
<p>通用的地址结构 <code>struct sockadd</code> 但是过于通用导致设置复杂，惯用法是通过以下两个结构体来构造地址，利用其<strong>内存布局一致的特点</strong>强转为<code>struct sockaddr </code>作为参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//man 7 ip </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* address family: AF_INET */</span> </span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port; <span class="comment">/* port in network byte order */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* internet address */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Internet address. */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_addr; <span class="comment">/* address in network byte order */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>整数大小端转化接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>



<p>网络字节序IP与点分十进制IP转化接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>



<p>使用域名获取IP的接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name; <span class="comment">/* official name of host */</span> </span><br><span class="line">    <span class="keyword">char</span> **h_aliases; <span class="comment">/* alias list */</span> </span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">/* host address type */</span> </span><br><span class="line">    <span class="keyword">int</span> h_length; <span class="comment">/* length of address */</span> </span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">/* list of addresses */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把TCP的通信机制看做两条管道，通信双方为A和B，三次握手分别做了一下几件事</span><br><span class="line">第一次握手A-&gt;B : 现在B知道了A-&gt;B 的通信是正常的  即B知道:A的发送B的接收正常</span><br><span class="line">第二次握手B-&gt;A : 现在A知道了A-&gt;B 与 B-&gt;A的通信是正常的 即A知道:A与B的收发都正常，但B不能确定A的收正常</span><br><span class="line">第三次握手A-&gt;B : 现在A知道自己的收发和B的收发都没有问题，而B还需确认A的接收能力。</span><br><span class="line"></span><br><span class="line">如果只有两次握手，那么B是没能确认A的接收能力的，如果认为两次握手后通信无误，那么A可能只是发了连接请求就关闭了此时认为连接建立成功的B只能永久等待</span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2022/03/13/010.Unix-Linux-Network-Programming/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/07/011.Unix-Linux-Thread/" >8.Unix-Linux-Thread</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-07  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、线程基础"><a href="#一、线程基础" class="headerlink" title="一、线程基础"></a>一、线程基础</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote>
<p>在Linux中线程是轻量级的进程(LWP:Low-weight-Process)减少进程切换的开销,它也拥有独立的task_struct作为独立的动态执行流(同属于一个进程的多个线程task_struct中有大量字段相同或共享)方便CPU进行调度。</p>
<p>进程除了作为独立的执行流外，还是资源分配的基本单位，使用线程并非要取代进程，而是让一个进程中存在多个线程，它们共享内存资源(线程有独立的栈但堆，数据段，代码段，文件描述符，信号屏蔽字等共享)，同时把CPU的调度单位细化为线程。</p>
<p>分析性能时，计算机将大量的时间花费在进程切换上(上下文切换:CPU寄存器中大量信息:堆栈，代码段…:寄存器与内存间的保存与载入工作；进程切换虚拟内存页表切换)</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/进程管理/线程模型.jpg" alt="线程" style="zoom:80%;">

<blockquote>
<p>同一个进程的多个线程各自拥有自己的栈，这些栈虽然是独立的，但是都位于同一个地址空间中，所以一个线程可以通过地址去访问另一个线程的栈区。</p>
</blockquote>
<blockquote>
<p>多线程天生就能利用多核的CPU架构，此前的进程都可以认为是单线程进程</p>
<p>使用线程库NPTL(Native Posix Threads Library)</p>
</blockquote>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3>
	

	</div>
  <a type="button" href="/2022/03/07/011.Unix-Linux-Thread/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、线程基础"><a href="#一、线程基础" class="headerlink" title="一、线程基础"></a>一、线程基础</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote>
<p>在Linux中线程是轻量级的进程(LWP:Low-weight-Process)减少进程切换的开销,它也拥有独立的task_struct作为独立的动态执行流(同属于一个进程的多个线程task_struct中有大量字段相同或共享)方便CPU进行调度。</p>
<p>进程除了作为独立的执行流外，还是资源分配的基本单位，使用线程并非要取代进程，而是让一个进程中存在多个线程，它们共享内存资源(线程有独立的栈但堆，数据段，代码段，文件描述符，信号屏蔽字等共享)，同时把CPU的调度单位细化为线程。</p>
<p>分析性能时，计算机将大量的时间花费在进程切换上(上下文切换:CPU寄存器中大量信息:堆栈，代码段…:寄存器与内存间的保存与载入工作；进程切换虚拟内存页表切换)</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/进程管理/线程模型.jpg" alt="线程" style="zoom:80%;">

<blockquote>
<p>同一个进程的多个线程各自拥有自己的栈，这些栈虽然是独立的，但是都位于同一个地址空间中，所以一个线程可以通过地址去访问另一个线程的栈区。</p>
</blockquote>
<blockquote>
<p>多线程天生就能利用多核的CPU架构，此前的进程都可以认为是单线程进程</p>
<p>使用线程库NPTL(Native Posix Threads Library)</p>
</blockquote>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3>
	
	</div>
  <a type="button" href="/2022/03/07/011.Unix-Linux-Thread/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/02/009.Unix-Linux-Process-management/" >Unix-Linux-Process-management</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-02  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、进程基础"><a href="#一、进程基础" class="headerlink" title="一、进程基础"></a>一、进程基础</h2><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0.概念"></a>0.概念</h3><blockquote>
<p>程序：静态文件，二进制指令和数据的集合，存储在磁盘中</p>
<p>进程：程序的动态执行过程，资源分配的基本单位(占CPU资源以执行程序指令，占存储资源以保存状态(数据段，代码段，堆…))，进程是处于执行器的程序和相关资源的总称。(同一份静态程序，可以启动多个不同进程).以进程的视角来看，它是独占CPU的，同时它也是独占内存空间的。以进程视角看到的内存空间称为虚拟内存空间。如下图所示。</p>
<p>[注]在内核态空间里面，与进程相关的数据结构是每个进程都不同的，物理存储器和内核代码数据是所有进程共享的。内核进程通常被成为内核线程，因为它们没有自己的独立地址空间，它们永远运行在内核态空间或者说它们本身就是内核的一部分。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%9B%B4%E7%BB%86%E5%8C%96%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.jpg" alt="更细化恶虚拟内存空间"></p>
<blockquote>
<p>Linux开机:(ROM中存有自举程序，计算机加电，CPU的PC置为自举程序的第一条指令，这个程序的唯一职责是把OS本身(至少是启动计算机的那部分)装入内存)主要关注进程的话，略过这些细节，在所有硬件配置好的情况下，<strong>这时bootloader程序会启动0号进程。0号进程会配置实时时钟，它的主要工作是启动1号进程(init,新版中被systemd取代)和2号进程(页面守护进程)</strong>,0号进程在启动完1号2号进程后终止(后面OS会再重启一个0号进程，但功能完全不同，它是idel空闲进程PID:0, 因为CPU总要选择一个进程运行，所以没活干的时候让CPU运行idel进程以省电。<strong>1号进程是其他所有用户进程的祖先, 2号进程是其他内核线程的祖先</strong>内核进程不占用户虚拟地址，也称做用户线程</p>
</blockquote>
<h3 id="1-一些库函数和系统调用"><a href="#1-一些库函数和系统调用" class="headerlink" title="1.一些库函数和系统调用"></a>1.一些库函数和系统调用</h3><p><code>GETPID(2)</code></p>
	

	</div>
  <a type="button" href="/2022/03/02/009.Unix-Linux-Process-management/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、进程基础"><a href="#一、进程基础" class="headerlink" title="一、进程基础"></a>一、进程基础</h2><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0.概念"></a>0.概念</h3><blockquote>
<p>程序：静态文件，二进制指令和数据的集合，存储在磁盘中</p>
<p>进程：程序的动态执行过程，资源分配的基本单位(占CPU资源以执行程序指令，占存储资源以保存状态(数据段，代码段，堆…))，进程是处于执行器的程序和相关资源的总称。(同一份静态程序，可以启动多个不同进程).以进程的视角来看，它是独占CPU的，同时它也是独占内存空间的。以进程视角看到的内存空间称为虚拟内存空间。如下图所示。</p>
<p>[注]在内核态空间里面，与进程相关的数据结构是每个进程都不同的，物理存储器和内核代码数据是所有进程共享的。内核进程通常被成为内核线程，因为它们没有自己的独立地址空间，它们永远运行在内核态空间或者说它们本身就是内核的一部分。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%9B%B4%E7%BB%86%E5%8C%96%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.jpg" alt="更细化恶虚拟内存空间"></p>
<blockquote>
<p>Linux开机:(ROM中存有自举程序，计算机加电，CPU的PC置为自举程序的第一条指令，这个程序的唯一职责是把OS本身(至少是启动计算机的那部分)装入内存)主要关注进程的话，略过这些细节，在所有硬件配置好的情况下，<strong>这时bootloader程序会启动0号进程。0号进程会配置实时时钟，它的主要工作是启动1号进程(init,新版中被systemd取代)和2号进程(页面守护进程)</strong>,0号进程在启动完1号2号进程后终止(后面OS会再重启一个0号进程，但功能完全不同，它是idel空闲进程PID:0, 因为CPU总要选择一个进程运行，所以没活干的时候让CPU运行idel进程以省电。<strong>1号进程是其他所有用户进程的祖先, 2号进程是其他内核线程的祖先</strong>内核进程不占用户虚拟地址，也称做用户线程</p>
</blockquote>
<h3 id="1-一些库函数和系统调用"><a href="#1-一些库函数和系统调用" class="headerlink" title="1.一些库函数和系统调用"></a>1.一些库函数和系统调用</h3><p><code>GETPID(2)</code></p>
	
	</div>
  <a type="button" href="/2022/03/02/009.Unix-Linux-Process-management/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/02/009.应用-聊天程序/" >Unix-Linux-Process-聊天室</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-02  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h3 id="综合应用：实现一个四窗口聊天"><a href="#综合应用：实现一个四窗口聊天" class="headerlink" title="综合应用：实现一个四窗口聊天"></a>综合应用：实现一个四窗口聊天</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通信方式：</span><br><span class="line">- 4个进程，A进程和B进程负责通信，从标准输入读到的字符串通过管道发给对方，A1和B1进程负责显示。</span><br><span class="line">- A进程从标准输入读到的字符串发给B进程后，放到共享内存里，从管道中读到的字符串也放到共享内存里，A1进程到共享内存中拿到字符串，打印到屏幕上。</span><br><span class="line">- B进程从标准输入读到的字符串发给B进程，同时通过消息队列发给B1进程，B1进程从消息队列中读出消息，打印到屏幕上。</span><br><span class="line">退出方式：</span><br><span class="line">- 第一种：可以通过ctrl+C退出，任意一个进程收到CTRL+C时，给所有进程（包括自己）发送10号信号，每个进程收到10号信号后，开始执行有序退出。</span><br><span class="line">- 第二种：通过kill命令给4个进程中的任何一个进程发送10号信号，收到信号的进程再给其他3个进程发送10号信号。每个进程在自己的信号处理函数中执行有序退出。</span><br><span class="line">有序退出的工作内容：</span><br><span class="line">- 有序退出要做的主要有：关闭管道，解除对共享内存的映射，删除共享内存，删除信号量，删除消息队列。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  注意：A和A1进程都要访问共享内存，需要同信号量完成同步，所以退出时要也删除信号量。</span><br><span class="line">  提示：A1进程和B1进程需要知道每条消息是对方发来的消息还是发给对方的消息，用消息队列的一方可以通过mtype的值来标识，</span><br><span class="line">       用共享内存的进程可以自己定义一个类似 msgbuf的结构体，然后结构体中也用一个类似mtype的成员来标记。</span><br></pre></td></tr></table></figure>

<p><code>a.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">2048</span>];</span><br><span class="line">&#125;<span class="keyword">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pa, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid 输出看看是否正常收到</span></span><br><span class="line">    <span class="comment">// 程序启动，先获取四个进程的PID存入全局变量输出一下(通信时用不到，但退出时有用)</span></span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">0</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ******************************************************</span></span><br><span class="line">    <span class="comment">// 通信，a2b管道通信</span></span><br><span class="line">    <span class="comment">// int ret_ab = mkfifo(&quot;a2b&quot;, 0666);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_ab, -1, &quot;mkfifo&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信 a2a1 by 共享内存+信号量 ?共享内存中怎么设置msgbuf结构体? 类似malloc</span></span><br><span class="line">    <span class="comment">// 为什么要用信号量：写的时候不允许读 先做共享内存读写再做信号量</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">msg_t</span> *p = (<span class="keyword">msg_t</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信号量完成同步(不用的话a1显示时有时候会阻塞住?)</span></span><br><span class="line">    <span class="comment">//(Q:stdin的消息较少阻塞，pipe的消息很容易?)确实是同步问题，加锁解决</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret_sem = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem, <span class="number">-1</span>, <span class="string">&quot;semctl setval&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>;<span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开a2b的写端，b2a的读端 完成后输出</span></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;a2b&quot;</span>, O_WRONLY);</span><br><span class="line">    ERROR_CHECK(fdw, <span class="number">-1</span>, <span class="string">&quot;open pipe a2b\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;b2a&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fdr, <span class="number">-1</span>, <span class="string">&quot;open pipe b2a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;chat established!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//IO多路复用</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);<span class="comment">//设置监听集合</span></span><br><span class="line">        <span class="keyword">int</span> ret_slt = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from process b\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdb = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdb == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// puts(buf);//后面改成在进程a1上显示</span></span><br><span class="line">            <span class="comment">// 从管道读来自b的消息 重定向到a1进程去显示 来自管道的消息定为2</span></span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            p-&gt;mtype = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;mtext, buf);</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from stdin.\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdin = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdin == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fdw, buf, ret_rdin);<span class="comment">//除开给管道发送一份之外还要写给a1显示进程一份</span></span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            p-&gt;mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;mtext, buf);</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    shmdt(p);</span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>a1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">2048</span>];</span><br><span class="line">&#125;<span class="keyword">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">1</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *************************************************</span></span><br><span class="line">    <span class="comment">// 读取共享内存中的消息</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">msg_t</span> *p = (<span class="keyword">msg_t</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信号量完成同步</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret_sem = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem, <span class="number">-1</span>, <span class="string">&quot;semctl setval&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>;<span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mtype == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg from process b:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg type = %d, msg = %s\n&quot;</span>, p-&gt;mtype, p-&gt;mtext);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mtype == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg from stdin:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg type = %d, msg = %s\n&quot;</span>, p-&gt;mtype, p-&gt;mtext);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Q : 怎么做到读出一条消息后阻塞? 清空一下阻塞住了但是 有时候接不到下条消息?等会加锁试试</span></span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line">        semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int ret_shmdt = shmdt(p);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_shmdt, -1, &quot;shmdt&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> ret_sem_rm = semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem_rm, <span class="number">-1</span>, <span class="string">&quot;semctl IPC_RMID&quot;</span>);</span><br><span class="line">    shmdt(p);   <span class="comment">//有一片共享内存(a2a1通信用的那片)和信号量没有正确退出，其他的正常</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>b.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">2</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *********************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信，b2b1(b1为显示端) 使用消息队列，要做的事情:b把从管道读端,键盘输入读到的数据重定向到b1,区分消息类型 by 消息队列</span></span><br><span class="line">    <span class="comment">// 消息对列发端</span></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">bufin</span>, <span class="title">bufpipe</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信，a2b管道通信</span></span><br><span class="line">    <span class="comment">// int ret_ba = mkfifo(&quot;b2a&quot;, 0666);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_ba, -1, &quot;mkfifo&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开b2a的写端，a2b的读端 完成后输出</span></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;a2b&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fdr, <span class="number">-1</span>, <span class="string">&quot;open pipe b2a\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;b2a&quot;</span>, O_WRONLY);</span><br><span class="line">    ERROR_CHECK(fdw, <span class="number">-1</span>, <span class="string">&quot;open pipe a2b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;chat established!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        <span class="keyword">int</span> ret_slt = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from process a\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rda = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rda == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// puts(buf);//管道读端读到的原本直接输出，现在重定向到b1进程 by message queue;</span></span><br><span class="line">            </span><br><span class="line">            bufpipe.mtype = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(bufpipe.mtext, buf);</span><br><span class="line">            <span class="keyword">int</span> ret_msgque_pipe = msgsnd(msgid, &amp;bufpipe, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret_msgque_pipe, <span class="number">-1</span>, <span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from stdin.\n&quot;);//隐藏掉这些信息进程b就只管输入了,显示全在b1</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdin = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdin == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fdw, buf, ret_rdin);<span class="comment">//后面改成在进程a1上显示</span></span><br><span class="line">            <span class="comment">// 键盘输入还要再在b1上显示一次</span></span><br><span class="line">            bufin.mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(bufin.mtext, buf);</span><br><span class="line">            <span class="keyword">int</span> ret_msgque_in = msgsnd(msgid, &amp;bufin, <span class="keyword">sizeof</span>(bufin), <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret_msgque_in, <span class="number">-1</span>, <span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>b1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">3</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *********************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// msgrcv</span></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">bufin</span>, <span class="title">bufpipe</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin)); <span class="comment">//两种消息有时候会阻塞?</span></span><br><span class="line">        <span class="keyword">int</span> ret_msgrcv_in = msgrcv(msgid, &amp;bufin, <span class="keyword">sizeof</span>(bufin), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//1, IPC_NOWAIT  改填0不限制消息类型直接取出</span></span><br><span class="line">        ERROR_CHECK(ret_msgrcv_in, <span class="number">-1</span>, <span class="string">&quot;msgrcv_in&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgrcv form stdin:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type = %ld, msg = %s\n&quot;</span>, bufin.mtype, bufin.mtext);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));       <span class="comment">//注意这个限制消息队列长度的参数：msgrcv: Argument list too long</span></span><br><span class="line">        <span class="keyword">int</span> ret_msgrcv_pipe = msgrcv(msgid, &amp;bufpipe, <span class="keyword">sizeof</span>(bufpipe), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//2, IPC_NOWAIT</span></span><br><span class="line">        ERROR_CHECK(ret_msgrcv_pipe, <span class="number">-1</span>, <span class="string">&quot;msgrcv_pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgrcv from pipe:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type = %ld, msg = %s\n&quot;</span>, bufpipe.mtype, bufpipe.mtext);</span><br><span class="line">        <span class="comment">//这样会循环取出，几乎一瞬间取完然后进程终止(怎么阻塞它)？不加IPC_NOWAIT 即可</span></span><br><span class="line">        <span class="comment">//目前对b1用Ctrl+C 不会影响a, b进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
	

	</div>
  <a type="button" href="/2022/03/02/009.应用-聊天程序/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h3 id="综合应用：实现一个四窗口聊天"><a href="#综合应用：实现一个四窗口聊天" class="headerlink" title="综合应用：实现一个四窗口聊天"></a>综合应用：实现一个四窗口聊天</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通信方式：</span><br><span class="line">- 4个进程，A进程和B进程负责通信，从标准输入读到的字符串通过管道发给对方，A1和B1进程负责显示。</span><br><span class="line">- A进程从标准输入读到的字符串发给B进程后，放到共享内存里，从管道中读到的字符串也放到共享内存里，A1进程到共享内存中拿到字符串，打印到屏幕上。</span><br><span class="line">- B进程从标准输入读到的字符串发给B进程，同时通过消息队列发给B1进程，B1进程从消息队列中读出消息，打印到屏幕上。</span><br><span class="line">退出方式：</span><br><span class="line">- 第一种：可以通过ctrl+C退出，任意一个进程收到CTRL+C时，给所有进程（包括自己）发送10号信号，每个进程收到10号信号后，开始执行有序退出。</span><br><span class="line">- 第二种：通过kill命令给4个进程中的任何一个进程发送10号信号，收到信号的进程再给其他3个进程发送10号信号。每个进程在自己的信号处理函数中执行有序退出。</span><br><span class="line">有序退出的工作内容：</span><br><span class="line">- 有序退出要做的主要有：关闭管道，解除对共享内存的映射，删除共享内存，删除信号量，删除消息队列。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  注意：A和A1进程都要访问共享内存，需要同信号量完成同步，所以退出时要也删除信号量。</span><br><span class="line">  提示：A1进程和B1进程需要知道每条消息是对方发来的消息还是发给对方的消息，用消息队列的一方可以通过mtype的值来标识，</span><br><span class="line">       用共享内存的进程可以自己定义一个类似 msgbuf的结构体，然后结构体中也用一个类似mtype的成员来标记。</span><br></pre></td></tr></table></figure>

<p><code>a.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">2048</span>];</span><br><span class="line">&#125;<span class="keyword">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    <span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pa, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid 输出看看是否正常收到</span></span><br><span class="line">    <span class="comment">// 程序启动，先获取四个进程的PID存入全局变量输出一下(通信时用不到，但退出时有用)</span></span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">0</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ******************************************************</span></span><br><span class="line">    <span class="comment">// 通信，a2b管道通信</span></span><br><span class="line">    <span class="comment">// int ret_ab = mkfifo(&quot;a2b&quot;, 0666);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_ab, -1, &quot;mkfifo&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信 a2a1 by 共享内存+信号量 ?共享内存中怎么设置msgbuf结构体? 类似malloc</span></span><br><span class="line">    <span class="comment">// 为什么要用信号量：写的时候不允许读 先做共享内存读写再做信号量</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">msg_t</span> *p = (<span class="keyword">msg_t</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">void</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信号量完成同步(不用的话a1显示时有时候会阻塞住?)</span></span><br><span class="line">    <span class="comment">//(Q:stdin的消息较少阻塞，pipe的消息很容易?)确实是同步问题，加锁解决</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret_sem = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem, <span class="number">-1</span>, <span class="string">&quot;semctl setval&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>;<span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开a2b的写端，b2a的读端 完成后输出</span></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;a2b&quot;</span>, O_WRONLY);</span><br><span class="line">    ERROR_CHECK(fdw, <span class="number">-1</span>, <span class="string">&quot;open pipe a2b\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;b2a&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fdr, <span class="number">-1</span>, <span class="string">&quot;open pipe b2a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;chat established!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//IO多路复用</span></span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);<span class="comment">//设置监听集合</span></span><br><span class="line">        <span class="keyword">int</span> ret_slt = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from process b\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdb = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdb == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// puts(buf);//后面改成在进程a1上显示</span></span><br><span class="line">            <span class="comment">// 从管道读来自b的消息 重定向到a1进程去显示 来自管道的消息定为2</span></span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            p-&gt;mtype = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;mtext, buf);</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from stdin.\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdin = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdin == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fdw, buf, ret_rdin);<span class="comment">//除开给管道发送一份之外还要写给a1显示进程一份</span></span><br><span class="line">            semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">            p-&gt;mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;mtext, buf);</span><br><span class="line">            semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    shmdt(p);</span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>a1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">2048</span>];</span><br><span class="line">&#125;<span class="keyword">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">1</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *************************************************</span></span><br><span class="line">    <span class="comment">// 读取共享内存中的消息</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">1000</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmid, <span class="number">-1</span>, <span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">    <span class="keyword">msg_t</span> *p = (<span class="keyword">msg_t</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(p, (<span class="keyword">char</span>*)<span class="number">-1</span>, <span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用信号量完成同步</span></span><br><span class="line">    <span class="keyword">int</span> semid = semget(<span class="number">1000</span>, <span class="number">1</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(semid, <span class="number">-1</span>, <span class="string">&quot;semget&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret_sem = semctl(semid, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem, <span class="number">-1</span>, <span class="string">&quot;semctl setval&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>;</span></span><br><span class="line">    P.sem_num = <span class="number">0</span>;<span class="comment">//数组下标</span></span><br><span class="line">    P.sem_op = <span class="number">-1</span>;</span><br><span class="line">    P.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">V</span>;</span></span><br><span class="line">    V.sem_num = <span class="number">0</span>;</span><br><span class="line">    V.sem_op = <span class="number">1</span>;</span><br><span class="line">    V.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        semop(semid, &amp;P, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mtype == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg from process b:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg type = %d, msg = %s\n&quot;</span>, p-&gt;mtype, p-&gt;mtext);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mtype == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg from stdin:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;msg type = %d, msg = %s\n&quot;</span>, p-&gt;mtype, p-&gt;mtext);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Q : 怎么做到读出一条消息后阻塞? 清空一下阻塞住了但是 有时候接不到下条消息?等会加锁试试</span></span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">msg_t</span>));</span><br><span class="line">        semop(semid, &amp;V, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int ret_shmdt = shmdt(p);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_shmdt, -1, &quot;shmdt&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> ret_sem_rm = semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    ERROR_CHECK(ret_sem_rm, <span class="number">-1</span>, <span class="string">&quot;semctl IPC_RMID&quot;</span>);</span><br><span class="line">    shmdt(p);   <span class="comment">//有一片共享内存(a2a1通信用的那片)和信号量没有正确退出，其他的正常</span></span><br><span class="line">    shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>b.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">2</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *********************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信，b2b1(b1为显示端) 使用消息队列，要做的事情:b把从管道读端,键盘输入读到的数据重定向到b1,区分消息类型 by 消息队列</span></span><br><span class="line">    <span class="comment">// 消息对列发端</span></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">bufin</span>, <span class="title">bufpipe</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通信，a2b管道通信</span></span><br><span class="line">    <span class="comment">// int ret_ba = mkfifo(&quot;b2a&quot;, 0666);</span></span><br><span class="line">    <span class="comment">// ERROR_CHECK(ret_ba, -1, &quot;mkfifo&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开b2a的写端，a2b的读端 完成后输出</span></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;a2b&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(fdr, <span class="number">-1</span>, <span class="string">&quot;open pipe b2a\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;b2a&quot;</span>, O_WRONLY);</span><br><span class="line">    ERROR_CHECK(fdw, <span class="number">-1</span>, <span class="string">&quot;open pipe a2b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;chat established!&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        FD_ZERO(&amp;rdset);</span><br><span class="line">        FD_SET(STDIN_FILENO, &amp;rdset);</span><br><span class="line">        FD_SET(fdr, &amp;rdset);</span><br><span class="line">        <span class="keyword">int</span> ret_slt = select(fdr+<span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fdr, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from process a\n&quot;);</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rda = read(fdr, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rda == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;bye.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// puts(buf);//管道读端读到的原本直接输出，现在重定向到b1进程 by message queue;</span></span><br><span class="line">            </span><br><span class="line">            bufpipe.mtype = <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(bufpipe.mtext, buf);</span><br><span class="line">            <span class="keyword">int</span> ret_msgque_pipe = msgsnd(msgid, &amp;bufpipe, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret_msgque_pipe, <span class="number">-1</span>, <span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(STDIN_FILENO, &amp;rdset))&#123;</span><br><span class="line">            <span class="comment">// printf(&quot;message from stdin.\n&quot;);//隐藏掉这些信息进程b就只管输入了,显示全在b1</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret_rdin = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(ret_rdin == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(fdw, buf, ret_rdin);<span class="comment">//后面改成在进程a1上显示</span></span><br><span class="line">            <span class="comment">// 键盘输入还要再在b1上显示一次</span></span><br><span class="line">            bufin.mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(bufin.mtext, buf);</span><br><span class="line">            <span class="keyword">int</span> ret_msgque_in = msgsnd(msgid, &amp;bufin, <span class="keyword">sizeof</span>(bufin), <span class="number">0</span>);</span><br><span class="line">            ERROR_CHECK(ret_msgque_in, <span class="number">-1</span>, <span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fdw);</span><br><span class="line">    close(fdr);</span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>b1.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> pa, pa1, pb, pb1;<span class="comment">//通信之前获取四个进程的pid,用全局变量保存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_exit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;handler got signal num = %d\n&quot;</span>, num);</span><br><span class="line">    kill(pa, SIGUSR1);<span class="comment">//发送10号信号有序退出 </span></span><br><span class="line">    kill(pa1, SIGUSR1);</span><br><span class="line">    kill(pb, SIGUSR1);</span><br><span class="line">    kill(pb1, SIGUSR1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取pid PID的存储也用一块共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmpid = shmget(<span class="number">1001</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(shmpid, <span class="number">-1</span>, <span class="string">&quot;shmget pid&quot;</span>);</span><br><span class="line">    <span class="keyword">pid_t</span> *pid = (<span class="keyword">pid_t</span>*)shmat(shmpid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pid[<span class="number">3</span>] = getpid();</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pa = pid[<span class="number">0</span>];</span><br><span class="line">    pa1 = pid[<span class="number">1</span>];</span><br><span class="line">    pb = pid[<span class="number">2</span>];</span><br><span class="line">    pb1 = pid[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa is %d\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pa1 is %d\n&quot;</span>, pa1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb is %d\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of pb1 is %d\n&quot;</span>, pb1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 将Ctrl+c 注册为向其他各个进程发送kill -10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line">    act.sa_flags = SA_NODEFER;</span><br><span class="line">    act.sa_handler = handler_exit;<span class="comment">//使用单参数版的回调函数</span></span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// *********************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// msgrcv</span></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(<span class="number">1000</span>, IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    ERROR_CHECK(msgid, <span class="number">-1</span>, <span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">bufin</span>, <span class="title">bufpipe</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;bufin, <span class="number">0</span>, <span class="keyword">sizeof</span>(bufin)); <span class="comment">//两种消息有时候会阻塞?</span></span><br><span class="line">        <span class="keyword">int</span> ret_msgrcv_in = msgrcv(msgid, &amp;bufin, <span class="keyword">sizeof</span>(bufin), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//1, IPC_NOWAIT  改填0不限制消息类型直接取出</span></span><br><span class="line">        ERROR_CHECK(ret_msgrcv_in, <span class="number">-1</span>, <span class="string">&quot;msgrcv_in&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgrcv form stdin:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type = %ld, msg = %s\n&quot;</span>, bufin.mtype, bufin.mtext);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;bufpipe, <span class="number">0</span> , <span class="keyword">sizeof</span>(bufpipe));       <span class="comment">//注意这个限制消息队列长度的参数：msgrcv: Argument list too long</span></span><br><span class="line">        <span class="keyword">int</span> ret_msgrcv_pipe = msgrcv(msgid, &amp;bufpipe, <span class="keyword">sizeof</span>(bufpipe), <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//2, IPC_NOWAIT</span></span><br><span class="line">        ERROR_CHECK(ret_msgrcv_pipe, <span class="number">-1</span>, <span class="string">&quot;msgrcv_pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msgrcv from pipe:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg type = %ld, msg = %s\n&quot;</span>, bufpipe.mtype, bufpipe.mtext);</span><br><span class="line">        <span class="comment">//这样会循环取出，几乎一瞬间取完然后进程终止(怎么阻塞它)？不加IPC_NOWAIT 即可</span></span><br><span class="line">        <span class="comment">//目前对b1用Ctrl+C 不会影响a, b进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">    shmdt(pid);</span><br><span class="line">    shmctl(shmpid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2022/03/02/009.应用-聊天程序/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/02/009.进程间通信机制/" >Unix-Linux-Process-进程间通信</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-02  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="进程间通信-IPC-Inter-Process-Communication"><a href="#进程间通信-IPC-Inter-Process-Communication" class="headerlink" title="进程间通信 IPC:Inter Process Communication"></a>进程间通信 IPC:Inter Process Communication</h2><blockquote>
<p>分别从几种进程间通信机制总结，每个机制可能搭配几个相关函数或系统调用的手册信息和一个或几个小例程，分析一下各种机制的特点。</p>
</blockquote>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><blockquote>
<p>之前用过命令创建的有名管道, 也能在程序中创建管道。在<code>fork()</code>的基础上还能使用匿名管道。</p>
</blockquote>
<p><code>POPEN(3) PCLOSE(3)</code>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line">                         |</span><br><span class="line">                     底层实现是fork()+exec()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">用的不多，意义不大, fork+匿名管道pipe可能更常用一点</span><br></pre></td></tr></table></figure>

<p><code>PIPE(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line">                 |</span><br><span class="line">               传参时退化为指针，主要是提示去传入长度为<span class="number">2</span>的数组，这个数组会保存文件描述符返回，由此可操纵匿名管道</span><br><span class="line">The <span class="built_in">array</span> pipefd is used to <span class="keyword">return</span> two file descriptors referring to the ends of the pipe.</span><br><span class="line">pipefd[<span class="number">0</span>] refers to the read end of the pipe.  pipefd[<span class="number">1</span>] refers to the  write  end  of  the  pipe.</span><br><span class="line">Data  written  to  the  write  end of the pipe is buffered by the kernel until it is read from the read end of the pipe.     </span><br></pre></td></tr></table></figure>

<blockquote>
<p>配合<code>fork()</code>一起使用，<code>fork()</code>出的两个进程是共享文件对象的，而用户态资源又是全部拷贝的</p>
<p>这样父子进程分别拥有用于描述匿名管道读端，写端文件对象的文件描述符，各自关闭一端就能实现半双工通信，两根管道各自关闭一端就能实现全双工通信。(显然，这样的特性是依赖与fork()实现的)</p>
</blockquote>
<p><code>示例</code></p>
	

	</div>
  <a type="button" href="/2022/03/02/009.进程间通信机制/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="进程间通信-IPC-Inter-Process-Communication"><a href="#进程间通信-IPC-Inter-Process-Communication" class="headerlink" title="进程间通信 IPC:Inter Process Communication"></a>进程间通信 IPC:Inter Process Communication</h2><blockquote>
<p>分别从几种进程间通信机制总结，每个机制可能搭配几个相关函数或系统调用的手册信息和一个或几个小例程，分析一下各种机制的特点。</p>
</blockquote>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h3><blockquote>
<p>之前用过命令创建的有名管道, 也能在程序中创建管道。在<code>fork()</code>的基础上还能使用匿名管道。</p>
</blockquote>
<p><code>POPEN(3) PCLOSE(3)</code>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line">                         |</span><br><span class="line">                     底层实现是fork()+exec()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">用的不多，意义不大, fork+匿名管道pipe可能更常用一点</span><br></pre></td></tr></table></figure>

<p><code>PIPE(2)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line">                 |</span><br><span class="line">               传参时退化为指针，主要是提示去传入长度为<span class="number">2</span>的数组，这个数组会保存文件描述符返回，由此可操纵匿名管道</span><br><span class="line">The <span class="built_in">array</span> pipefd is used to <span class="keyword">return</span> two file descriptors referring to the ends of the pipe.</span><br><span class="line">pipefd[<span class="number">0</span>] refers to the read end of the pipe.  pipefd[<span class="number">1</span>] refers to the  write  end  of  the  pipe.</span><br><span class="line">Data  written  to  the  write  end of the pipe is buffered by the kernel until it is read from the read end of the pipe.     </span><br></pre></td></tr></table></figure>

<blockquote>
<p>配合<code>fork()</code>一起使用，<code>fork()</code>出的两个进程是共享文件对象的，而用户态资源又是全部拷贝的</p>
<p>这样父子进程分别拥有用于描述匿名管道读端，写端文件对象的文件描述符，各自关闭一端就能实现半双工通信，两根管道各自关闭一端就能实现全双工通信。(显然，这样的特性是依赖与fork()实现的)</p>
</blockquote>
<p><code>示例</code></p>
	
	</div>
  <a type="button" href="/2022/03/02/009.进程间通信机制/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/26/008.Unix-Linux.FileManagement/" >Unix/Linux-file-management</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-26  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><blockquote>
<p>关于一切皆文件这个理念</p>
<p>对于这个Unix设计哲学，之前是知道这个名词，但是要具体来说可能说不出什么，结合一些文件操作来理解可能更为清晰。(图画的丑: ))在程序的运行过程中，计算机是怎样去操作磁盘上的文件的? 在一个程序运行时，由CPU去代码段取一条条指令，并将指令执行生成的数据放入堆栈等数据区。那么指令的操作数在哪？在内存上，内存的数据是从磁盘上取出的，最终也会持久化的存储在磁盘上。从中取，往回存这两个操作是怎么做到的，把磁盘看做程序运行时的外部设备，它在内存上建立了映射区—称作文件缓冲区。文件缓冲区在内存上，但是影响外部设备。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/img%E6%96%87%E4%BB%B6_%E6%93%8D%E4%BD%9C.jpg"></p>
<blockquote>
<p>以此类推，目录文件，设备文件，管道文件等等，理念是一致的，对于众多的文件类型使用通用的方式去操作它们。文件操作操作的是内存上的数据，影响的是外部设备。对于Linux而言存在内核态与用户态，当文件操作涉及外部硬件时，用户态将这些操作委托给内核态去完成，这就离不开系统调用。</p>
<p>理解了这一点，就可以通过学习文件操作更深入的理解(操作文件会影响外部硬件，这个函数就不是普通的函数而是系统调用)。使用库函数和系统调用来操作文件，从库函数–&gt;系统调用。</p>
<p>基于文件指针的文件操作函数(ANSI 标准库函数) –&gt; 基于系统调用的文件操作</p>
</blockquote>
<h4 id="1-1-文件操作-基于-库函数-文件指针FILE"><a href="#1-1-文件操作-基于-库函数-文件指针FILE" class="headerlink" title="1.1 文件操作 - 基于(库函数)文件指针FILE*"></a>1.1 文件操作 - 基于(库函数)文件指针FILE*</h4><blockquote>
<p>从普通文件的打开与操作开始</p>
</blockquote>
<p><code>流</code>：表示任意输入<code>src</code>, 任意输出<code>dst</code> ，屏蔽硬件设备之间的差异，使得C像读写文件一样读写任意设备。</p>
<blockquote>
<p>内存与硬件设备存在读写性能上的鸿沟，OS在内存上为<code>流</code>设置缓冲区，C通过文件指针<code>FILE*</code>实现对流的访问, 启动任意进程OS将打开三个标准流<code>stdin</code> , <code>stdout</code>,  <code>stderr</code>.它们都默认与硬件关联。</p>
</blockquote>
<p>从普通文件操作开始, 读写之前先打开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">返回值是指针:暗含的意思-&gt;返回值指针指向必定不在被调函数栈帧(而在用户态某个空间，需用户自行释放)</span><br><span class="line">返回文件指针访问流</span><br><span class="line">|</span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* mode)</span></span>;</span><br><span class="line">                                                |</span><br><span class="line">                                            打开模式(考虑后续操作)</span><br><span class="line">                                            <span class="string">&quot;r&quot;</span> :只读打开</span><br><span class="line">                                            <span class="string">&quot;r+&quot;</span>:读写打开 文件必须存在</span><br><span class="line">                                            <span class="string">&quot;w&quot;</span> :只写创建 文件不需要存在</span><br><span class="line">                                            <span class="string">&quot;w+&quot;</span>:读写创建 文件存在就清空</span><br><span class="line">                                            <span class="string">&quot;a+&quot;</span>:读写追加 在原有数据后写入新值</span><br><span class="line">                                                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* stream)</span></span>;                                                    </span><br></pre></td></tr></table></figure>
	

	</div>
  <a type="button" href="/2022/02/26/008.Unix-Linux.FileManagement/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><blockquote>
<p>关于一切皆文件这个理念</p>
<p>对于这个Unix设计哲学，之前是知道这个名词，但是要具体来说可能说不出什么，结合一些文件操作来理解可能更为清晰。(图画的丑: ))在程序的运行过程中，计算机是怎样去操作磁盘上的文件的? 在一个程序运行时，由CPU去代码段取一条条指令，并将指令执行生成的数据放入堆栈等数据区。那么指令的操作数在哪？在内存上，内存的数据是从磁盘上取出的，最终也会持久化的存储在磁盘上。从中取，往回存这两个操作是怎么做到的，把磁盘看做程序运行时的外部设备，它在内存上建立了映射区—称作文件缓冲区。文件缓冲区在内存上，但是影响外部设备。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/img%E6%96%87%E4%BB%B6_%E6%93%8D%E4%BD%9C.jpg"></p>
<blockquote>
<p>以此类推，目录文件，设备文件，管道文件等等，理念是一致的，对于众多的文件类型使用通用的方式去操作它们。文件操作操作的是内存上的数据，影响的是外部设备。对于Linux而言存在内核态与用户态，当文件操作涉及外部硬件时，用户态将这些操作委托给内核态去完成，这就离不开系统调用。</p>
<p>理解了这一点，就可以通过学习文件操作更深入的理解(操作文件会影响外部硬件，这个函数就不是普通的函数而是系统调用)。使用库函数和系统调用来操作文件，从库函数–&gt;系统调用。</p>
<p>基于文件指针的文件操作函数(ANSI 标准库函数) –&gt; 基于系统调用的文件操作</p>
</blockquote>
<h4 id="1-1-文件操作-基于-库函数-文件指针FILE"><a href="#1-1-文件操作-基于-库函数-文件指针FILE" class="headerlink" title="1.1 文件操作 - 基于(库函数)文件指针FILE*"></a>1.1 文件操作 - 基于(库函数)文件指针FILE*</h4><blockquote>
<p>从普通文件的打开与操作开始</p>
</blockquote>
<p><code>流</code>：表示任意输入<code>src</code>, 任意输出<code>dst</code> ，屏蔽硬件设备之间的差异，使得C像读写文件一样读写任意设备。</p>
<blockquote>
<p>内存与硬件设备存在读写性能上的鸿沟，OS在内存上为<code>流</code>设置缓冲区，C通过文件指针<code>FILE*</code>实现对流的访问, 启动任意进程OS将打开三个标准流<code>stdin</code> , <code>stdout</code>,  <code>stderr</code>.它们都默认与硬件关联。</p>
</blockquote>
<p>从普通文件操作开始, 读写之前先打开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">返回值是指针:暗含的意思-&gt;返回值指针指向必定不在被调函数栈帧(而在用户态某个空间，需用户自行释放)</span><br><span class="line">返回文件指针访问流</span><br><span class="line">|</span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* mode)</span></span>;</span><br><span class="line">                                                |</span><br><span class="line">                                            打开模式(考虑后续操作)</span><br><span class="line">                                            <span class="string">&quot;r&quot;</span> :只读打开</span><br><span class="line">                                            <span class="string">&quot;r+&quot;</span>:读写打开 文件必须存在</span><br><span class="line">                                            <span class="string">&quot;w&quot;</span> :只写创建 文件不需要存在</span><br><span class="line">                                            <span class="string">&quot;w+&quot;</span>:读写创建 文件存在就清空</span><br><span class="line">                                            <span class="string">&quot;a+&quot;</span>:读写追加 在原有数据后写入新值</span><br><span class="line">                                                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* stream)</span></span>;                                                    </span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2022/02/26/008.Unix-Linux.FileManagement/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/26/007.Unix.Linux.start/" >Unix/Linux-file-management</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-26  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-一点历史"><a href="#0-一点历史" class="headerlink" title="0 .一点历史"></a>0 .一点历史</h3><blockquote>
<p>还是从一点历史引入，感觉了解一些历史缘由，会更好地理解采用某种特定实现技术的原因</p>
<p>看了一点《The art of Unix Programming》 序中有一句话挺吸引我</p>
<p><em>Unix is not so much an operating system as an oral history.  —-Neal Stephenson</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-&gt;(早期)批处理OS</span><br><span class="line">-&gt;(1960)MIT分时OS:多终端+大型机</span><br><span class="line">-&gt;(1965)AT&amp;T:Bell+MIT+GE(通用电气):Multics计划(全面通用分时OS:bye)</span><br><span class="line">-&gt;(1969)Bell认为该计划GG,退出 (不算失败，有些成果) ：Ken Thompson 写了 Space Travle, PDP-7小型机移植，对它重写OS内核并移植 称Unics</span><br><span class="line">-&gt;Unics(核心哲学:一切皆文件, 程序的目的只有一个-有效的完成目标 : 与Multics理念不同《The Art of Unix Programming》)</span><br><span class="line">-&gt;(1969)Linus Torvalds 在芬兰诞生</span><br><span class="line">-&gt;尝试用高级语言解决移植问题BCPL, PASCAL-&gt;编译出的内核性能不够好-&gt;根据BCPL发明C</span><br><span class="line">-&gt;(1973)Deneish Richie(C的主要发明者)用C重写了Unics系统(提供了管道等重要功能),更名为Unix</span><br><span class="line">-&gt;(1977)AT&amp;T将Unix源代码(用C写的,高可移植性)发给学术界-&gt;UC Berkeley-&gt;Bill Joy professor 编译成适合自己机器的系统，增减一些功能:命名为BSD(Berkeley Software Distribution)</span><br><span class="line">-&gt;(1979)AT&amp;T:推出System V(five(Sun - Solaris)):第七版(不再开源:商业纠纷开始):特性:可以支持x86架构的个人计算机</span><br><span class="line">-&gt;(1984)不再开源对教授OS的professor产生了影响:Andrew TannenBaum-&gt;自己写个Mini Unix -&gt; Minix</span><br><span class="line">-&gt;(1986)完成Minix, 并出版《Operating System : Design and Implementation》附带Minix的源代码</span><br><span class="line">        《Modern Operating System》也是他写的</span><br><span class="line">-&gt;同期 Richard Stallman 发起了GNU计划:GNU:Gnu is not Unix!(GCC, Emacs, Bash Shell, GDB...)目标创建一套完全自由的Unix OS(当时的Unix与硬件捆绑销售)但是缺少Unix内核</span><br><span class="line">-&gt;草拟 GPL协议(General Publilc License | 🙂 copyleft &lt;!-&gt; copyright:著作权) 开源 != 免费(维护可以收费)</span><br><span class="line">-&gt;(1988)IEEE:POSIX标准(旨在:保证各个OS间的兼容性) (IEEE-IX-&gt;POSIX:Portable Operating System Interface X:(Unix))可移植...</span><br><span class="line">-&gt;(1993)Linus:宏内核构造的Linux内核面世</span><br></pre></td></tr></table></figure>

<h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><blockquote>
<p>感觉之前学过很多次，并且每次学习也有用纸质或者文档记录，博客记录学到，使用过的命令，但大多情况学过不用就忘了，不是长久之计，这次就不记录这些。尽量多用以熟练。同时，本文的侧重点不在使用这方面，想要更深入的学习一些东西。</p>
</blockquote>
<blockquote>
<p>如果有不会的熟练使用 <code>$man</code></p>
<p>一点准备工作，环境使用的Ubuntu18.04 帮助手册不全<code>sudo apt install manpages-posix-dev</code></p>
</blockquote>
<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3>
	

	</div>
  <a type="button" href="/2022/02/26/007.Unix.Linux.start/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-一点历史"><a href="#0-一点历史" class="headerlink" title="0 .一点历史"></a>0 .一点历史</h3><blockquote>
<p>还是从一点历史引入，感觉了解一些历史缘由，会更好地理解采用某种特定实现技术的原因</p>
<p>看了一点《The art of Unix Programming》 序中有一句话挺吸引我</p>
<p><em>Unix is not so much an operating system as an oral history.  —-Neal Stephenson</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-&gt;(早期)批处理OS</span><br><span class="line">-&gt;(1960)MIT分时OS:多终端+大型机</span><br><span class="line">-&gt;(1965)AT&amp;T:Bell+MIT+GE(通用电气):Multics计划(全面通用分时OS:bye)</span><br><span class="line">-&gt;(1969)Bell认为该计划GG,退出 (不算失败，有些成果) ：Ken Thompson 写了 Space Travle, PDP-7小型机移植，对它重写OS内核并移植 称Unics</span><br><span class="line">-&gt;Unics(核心哲学:一切皆文件, 程序的目的只有一个-有效的完成目标 : 与Multics理念不同《The Art of Unix Programming》)</span><br><span class="line">-&gt;(1969)Linus Torvalds 在芬兰诞生</span><br><span class="line">-&gt;尝试用高级语言解决移植问题BCPL, PASCAL-&gt;编译出的内核性能不够好-&gt;根据BCPL发明C</span><br><span class="line">-&gt;(1973)Deneish Richie(C的主要发明者)用C重写了Unics系统(提供了管道等重要功能),更名为Unix</span><br><span class="line">-&gt;(1977)AT&amp;T将Unix源代码(用C写的,高可移植性)发给学术界-&gt;UC Berkeley-&gt;Bill Joy professor 编译成适合自己机器的系统，增减一些功能:命名为BSD(Berkeley Software Distribution)</span><br><span class="line">-&gt;(1979)AT&amp;T:推出System V(five(Sun - Solaris)):第七版(不再开源:商业纠纷开始):特性:可以支持x86架构的个人计算机</span><br><span class="line">-&gt;(1984)不再开源对教授OS的professor产生了影响:Andrew TannenBaum-&gt;自己写个Mini Unix -&gt; Minix</span><br><span class="line">-&gt;(1986)完成Minix, 并出版《Operating System : Design and Implementation》附带Minix的源代码</span><br><span class="line">        《Modern Operating System》也是他写的</span><br><span class="line">-&gt;同期 Richard Stallman 发起了GNU计划:GNU:Gnu is not Unix!(GCC, Emacs, Bash Shell, GDB...)目标创建一套完全自由的Unix OS(当时的Unix与硬件捆绑销售)但是缺少Unix内核</span><br><span class="line">-&gt;草拟 GPL协议(General Publilc License | 🙂 copyleft &lt;!-&gt; copyright:著作权) 开源 != 免费(维护可以收费)</span><br><span class="line">-&gt;(1988)IEEE:POSIX标准(旨在:保证各个OS间的兼容性) (IEEE-IX-&gt;POSIX:Portable Operating System Interface X:(Unix))可移植...</span><br><span class="line">-&gt;(1993)Linus:宏内核构造的Linux内核面世</span><br></pre></td></tr></table></figure>

<h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><blockquote>
<p>感觉之前学过很多次，并且每次学习也有用纸质或者文档记录，博客记录学到，使用过的命令，但大多情况学过不用就忘了，不是长久之计，这次就不记录这些。尽量多用以熟练。同时，本文的侧重点不在使用这方面，想要更深入的学习一些东西。</p>
</blockquote>
<blockquote>
<p>如果有不会的熟练使用 <code>$man</code></p>
<p>一点准备工作，环境使用的Ubuntu18.04 帮助手册不全<code>sudo apt install manpages-posix-dev</code></p>
</blockquote>
<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3>
	
	</div>
  <a type="button" href="/2022/02/26/007.Unix.Linux.start/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/17/006.sort-algorithm/" >Sort-Algorithm</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-17  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h3 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title=". 常见排序算法"></a>. 常见排序算法</h3><blockquote>
<p>关于排序算法分析</p>
<p>1.时间复杂度</p>
<p>冒泡排序，插入排序，简单选择排序无法突破<code>O(n2)</code>时间复杂度，因为其有序化过程中都是一个一个来减少逆序度的，当逆序度为0时整个序列有序，相对的希尔，并归，快排，堆排能突破是因为其不依赖相邻元素逐个排序。</p>
<ul>
<li><p>最好，最坏，平均   </p>
<p>分析时间复杂度，要给出 最好，最坏，平均情况下的时间复杂度(给出最好，最坏情况下对应要排序的原始数据情况)</p>
<ul>
<li><p>平均时间复杂度分析</p>
<p>n个元素有n!种排序，然后统计比较和交换的次数，再计算平均值。想想就十分复杂。</p>
<p>这里我们采用逆序对的方式来分析。</p>
<p>有序元素对：<code>arr[i] &lt;= arr[j], i &lt; j  </code></p>
<p>逆序元素对：<code>arr[i] &gt; arr[j], i &lt; j</code></p>
<p>有序度：数组中有序元素对的个数</p>
<p>逆序度：数组中逆序元素对的个数</p>
<p>满有序度：数组排好序后的有序度。</p>
<p>假设数组有n个元素，满有序度 =  <code>n(n-1)/2</code></p>
<p>公式： 满有序度 = 有序度 + 逆序度排序过程就是增加有序度，减少逆序度，最终达到满有序度的过程。</p>
</li>
</ul>
</li>
<li><p>常数，系数，低阶  </p>
<p>时间复杂度反应规模n很大时的增长趋势，忽略常数，系数，低阶(考虑规模小的数据时考虑这些因素)</p>
</li>
<li><p>比较， 交换  </p>
<p>基于比较的排序算法涉及元素的比较，交换，分析效率要考虑这些</p>
</li>
</ul>
<p>2.空间复杂度  </p>
<p>是否是原地算法</p>
<p>3.稳定性  </p>
<p>待排序列中存在值相等的元素，排序后这些元素间的前后关系是否不变</p>
</blockquote>
<p><code>bubble</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// i 表示冒泡的次数，也就是比较的趟数</span></span><br><span class="line">        <span class="keyword">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//每趟比较中，j从0开始取相邻两个元素比较(交换),每趟一定有一个元素有序排好，可以利用i</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;<span class="comment">//做点优化，使得有序(这趟没执行交换)之后结束排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有序度是数组中具有有序关系的元素对的个数。如果一个数组完全有序，有序度就是<code>Cn2 = n(n-1)/2</code>，这种叫做满有序度。</p>
<p>对于冒泡排序来说，交换会导致：有序度+1， 逆序度-1.</p>
<p>所以 交换的次数 = 逆序度。可以简单的认为平均情况下，逆序度 = <code> n(n-1)/4</code> 比较的次数肯定比交换的次数多，但少于 <code>n(n-1)/2</code>所以平均情况下，时间复杂度为<code>O(n2)</code></p>
</blockquote>
<p><code>selection</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// i表示选择元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = i;<span class="comment">//先预设当前索引所指数为最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//j从后一个元素开始向后找有无更小的</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每趟先假定本趟开头为最小元素，记录其索引，从其后一个元素开始向后遍历，找到更小的，更新最小元索引记录一趟走完交换本趟开头与最小<br>发生长距离的交换 所以不稳定</p>
<p>[5, 5, 1, 2, 3, 0, ]第一个5换到第二个5后面</p>
<p><code>O(n2) </code>不存在最好最坏，都是<code>O(n2)</code></p>
</blockquote>
<p><code>insertion</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">// i代表待插入元素的索引，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">int</span> val = arr[i];<span class="comment">//先记录，如果要插到前面的话需要前方元素后移，可能会覆盖它</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">//找到待插元素的前一个元素</span></span><br><span class="line">        <span class="comment">// 元素(比记录的待插元素大)往后移(凡比ta大的都后移，留出ta的位置)</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
	

	</div>
  <a type="button" href="/2022/02/17/006.sort-algorithm/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h3 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title=". 常见排序算法"></a>. 常见排序算法</h3><blockquote>
<p>关于排序算法分析</p>
<p>1.时间复杂度</p>
<p>冒泡排序，插入排序，简单选择排序无法突破<code>O(n2)</code>时间复杂度，因为其有序化过程中都是一个一个来减少逆序度的，当逆序度为0时整个序列有序，相对的希尔，并归，快排，堆排能突破是因为其不依赖相邻元素逐个排序。</p>
<ul>
<li><p>最好，最坏，平均   </p>
<p>分析时间复杂度，要给出 最好，最坏，平均情况下的时间复杂度(给出最好，最坏情况下对应要排序的原始数据情况)</p>
<ul>
<li><p>平均时间复杂度分析</p>
<p>n个元素有n!种排序，然后统计比较和交换的次数，再计算平均值。想想就十分复杂。</p>
<p>这里我们采用逆序对的方式来分析。</p>
<p>有序元素对：<code>arr[i] &lt;= arr[j], i &lt; j  </code></p>
<p>逆序元素对：<code>arr[i] &gt; arr[j], i &lt; j</code></p>
<p>有序度：数组中有序元素对的个数</p>
<p>逆序度：数组中逆序元素对的个数</p>
<p>满有序度：数组排好序后的有序度。</p>
<p>假设数组有n个元素，满有序度 =  <code>n(n-1)/2</code></p>
<p>公式： 满有序度 = 有序度 + 逆序度排序过程就是增加有序度，减少逆序度，最终达到满有序度的过程。</p>
</li>
</ul>
</li>
<li><p>常数，系数，低阶  </p>
<p>时间复杂度反应规模n很大时的增长趋势，忽略常数，系数，低阶(考虑规模小的数据时考虑这些因素)</p>
</li>
<li><p>比较， 交换  </p>
<p>基于比较的排序算法涉及元素的比较，交换，分析效率要考虑这些</p>
</li>
</ul>
<p>2.空间复杂度  </p>
<p>是否是原地算法</p>
<p>3.稳定性  </p>
<p>待排序列中存在值相等的元素，排序后这些元素间的前后关系是否不变</p>
</blockquote>
<p><code>bubble</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// i 表示冒泡的次数，也就是比较的趟数</span></span><br><span class="line">        <span class="keyword">bool</span> sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;<span class="comment">//每趟比较中，j从0开始取相邻两个元素比较(交换),每趟一定有一个元素有序排好，可以利用i</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;<span class="comment">//做点优化，使得有序(这趟没执行交换)之后结束排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有序度是数组中具有有序关系的元素对的个数。如果一个数组完全有序，有序度就是<code>Cn2 = n(n-1)/2</code>，这种叫做满有序度。</p>
<p>对于冒泡排序来说，交换会导致：有序度+1， 逆序度-1.</p>
<p>所以 交换的次数 = 逆序度。可以简单的认为平均情况下，逆序度 = <code> n(n-1)/4</code> 比较的次数肯定比交换的次数多，但少于 <code>n(n-1)/2</code>所以平均情况下，时间复杂度为<code>O(n2)</code></p>
</blockquote>
<p><code>selection</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// i表示选择元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = i;<span class="comment">//先预设当前索引所指数为最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//j从后一个元素开始向后找有无更小的</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每趟先假定本趟开头为最小元素，记录其索引，从其后一个元素开始向后遍历，找到更小的，更新最小元索引记录一趟走完交换本趟开头与最小<br>发生长距离的交换 所以不稳定</p>
<p>[5, 5, 1, 2, 3, 0, ]第一个5换到第二个5后面</p>
<p><code>O(n2) </code>不存在最好最坏，都是<code>O(n2)</code></p>
</blockquote>
<p><code>insertion</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">// i代表待插入元素的索引，从第二个元素开始</span></span><br><span class="line">        <span class="keyword">int</span> val = arr[i];<span class="comment">//先记录，如果要插到前面的话需要前方元素后移，可能会覆盖它</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">//找到待插元素的前一个元素</span></span><br><span class="line">        <span class="comment">// 元素(比记录的待插元素大)往后移(凡比ta大的都后移，留出ta的位置)</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; val) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2022/02/17/006.sort-algorithm/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
           <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
        

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/2/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/C-C/">C/C++<span>3</span></a></li>
		
			<li><a href="/tags/Unix-Linux/">Unix/Linux<span>7</span></a></li>
		
			<li><a href="/tags/database/">database<span>1</span></a></li>
		
			<li><a href="/tags/xxxx/">xxxx<span>4</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2022/04/24/012.regex/" ><i class="fa fa-file-o"></i>12.regex</a>
      </li>
    
      <li>
        <a href="/2022/03/14/013.database1/" ><i class="fa fa-file-o"></i>database1</a>
      </li>
    
      <li>
        <a href="/2022/03/13/010.Unix-Linux-Network-Programming/" ><i class="fa fa-file-o"></i>Unix-Linux-Network-Programm...</a>
      </li>
    
      <li>
        <a href="/2022/03/07/011.Unix-Linux-Thread/" ><i class="fa fa-file-o"></i>8.Unix-Linux-Thread</a>
      </li>
    
      <li>
        <a href="/2022/03/02/009.Unix-Linux-Process-management/" ><i class="fa fa-file-o"></i>Unix-Linux-Process-management</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/lacsscal" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2022 chen's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
