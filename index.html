<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>lacsscal&#39;s blog</title>
  <meta name="author" content="chen">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="lacsscal&#39;s blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="lacsscal&#39;s blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.0.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">lacsscal&#39;s blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>lacsscal&#39;s blog<span class="blink-fast">|</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/04/24/12-regex/" >12.regex</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-04-24  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>最初是由Unix 的grep 和sed等工具软件普及开的。</p>
<p>使用单个(模式)字符串描述，匹配一系列匹配某句法规则的字符串</p>
<p>一个学习的GitHub项目<a target="_blank" rel="noopener" href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">learn_regex</a></p>
<p>一个练习题库<a target="_blank" rel="noopener" href="https://regex101.com/">在线题库</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220422200036382.png" alt="POSIX字符组"></p>
<blockquote>
<p>正则表达式的POSIX规范，分为:</p>
<p>基本型正则表达式（Basic Regular Expression，BRE）<br>和扩展型正则表达式（Extended Regular Expression，ERE）两大流派。<br>前者的元字符需要转义，后者的不需要(包括egrep awk)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">基本正则表达式的元字符：</span><br><span class="line">	字符匹配：</span><br><span class="line">		.: 匹配任意单个字符</span><br><span class="line">		[]: 匹配指定范围内的任意单个字符</span><br><span class="line">			[0-9], [[:digit:]]</span><br><span class="line">			[a-z], [[:lower:]]</span><br><span class="line">			[A-Z], [[:upper:]]</span><br><span class="line">			[[:space:]]</span><br><span class="line">			[[:punct:]]</span><br><span class="line">			[[:alpha:]]</span><br><span class="line">			[[:alnum:]]</span><br><span class="line">		[^]:</span><br><span class="line">	次数匹配元字符：用于实现指定其前面的字符所能够出现的次数</span><br><span class="line">		*: 任意长度，它前面的字符可以出现任意次</span><br><span class="line">			例如：x*y</span><br><span class="line">				xxy, xyy, y, </span><br><span class="line">		\\?: 0次或1次，它前面的字符是可有可无的</span><br><span class="line">			例如：x\\?y</span><br><span class="line">				xy, y, ay</span><br><span class="line">		\\&#123;m\\&#125;: m次，它前的字符要出现m次</span><br><span class="line">			例如：x\\&#123;2\\&#125;y</span><br><span class="line">				xy, xxy, y, xxxxy, xyy</span><br><span class="line">		\\&#123;m,n\\&#125;: 至少m次，至多n次</span><br><span class="line">			例如：x\\&#123;2,5\\&#125;y</span><br><span class="line">				xy, y, xxy</span><br><span class="line">		\\&#123;m,\\&#125;：至少m次</span><br><span class="line">		\\&#123;0,n\\&#125;: 至多n次</span><br><span class="line"></span><br><span class="line">		.*：任意长度的任意字符</span><br><span class="line"></span><br><span class="line">	位置锚定：</span><br><span class="line">		^: 行首锚定；</span><br><span class="line">			写在模式最左侧</span><br><span class="line">		$: 行尾锚定：</span><br><span class="line">			写在模式最右侧</span><br><span class="line">		^$: 空白行</span><br><span class="line">			</span><br><span class="line">			不包含特殊字符的连续字符组成的串叫单词：</span><br><span class="line">		\\&lt;: 词首，出现于单词左侧</span><br><span class="line">			\\&lt;char</span><br><span class="line">		\\&gt;: 词尾，出现于单词右侧</span><br><span class="line">			char\\&gt;</span><br><span class="line">	</span><br><span class="line">	分组...</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">扩展正则表达式：</span><br><span class="line">	字符匹配：</span><br><span class="line">		.</span><br><span class="line">		[]</span><br><span class="line">		[^]</span><br><span class="line">	次数匹配：</span><br><span class="line">		*：任意次</span><br><span class="line">		?: 0次或1次</span><br><span class="line">		+: 至少1次；</span><br><span class="line">		&#123;m&#125;: 精确匹配m次</span><br><span class="line">		&#123;m,n&#125;: 至少m次，至多n次</span><br><span class="line">		&#123;m,&#125;</span><br><span class="line">		&#123;0,n&#125;</span><br><span class="line">	位置锚定：</span><br><span class="line">		^</span><br><span class="line">		$</span><br><span class="line">		\&lt;, </span><br><span class="line">		\&gt;, </span><br><span class="line">		^$, ^[[:space:]]*$</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="应用到grep"><a href="#应用到grep" class="headerlink" title="应用到grep"></a>应用到grep</h1>
	

	</div>
  <a type="button" href="/2022/04/24/12-regex/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>最初是由Unix 的grep 和sed等工具软件普及开的。</p>
<p>使用单个(模式)字符串描述，匹配一系列匹配某句法规则的字符串</p>
<p>一个学习的GitHub项目<a target="_blank" rel="noopener" href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">learn_regex</a></p>
<p>一个练习题库<a target="_blank" rel="noopener" href="https://regex101.com/">在线题库</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220422200036382.png" alt="POSIX字符组"></p>
<blockquote>
<p>正则表达式的POSIX规范，分为:</p>
<p>基本型正则表达式（Basic Regular Expression，BRE）<br>和扩展型正则表达式（Extended Regular Expression，ERE）两大流派。<br>前者的元字符需要转义，后者的不需要(包括egrep awk)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">基本正则表达式的元字符：</span><br><span class="line">	字符匹配：</span><br><span class="line">		.: 匹配任意单个字符</span><br><span class="line">		[]: 匹配指定范围内的任意单个字符</span><br><span class="line">			[0-9], [[:digit:]]</span><br><span class="line">			[a-z], [[:lower:]]</span><br><span class="line">			[A-Z], [[:upper:]]</span><br><span class="line">			[[:space:]]</span><br><span class="line">			[[:punct:]]</span><br><span class="line">			[[:alpha:]]</span><br><span class="line">			[[:alnum:]]</span><br><span class="line">		[^]:</span><br><span class="line">	次数匹配元字符：用于实现指定其前面的字符所能够出现的次数</span><br><span class="line">		*: 任意长度，它前面的字符可以出现任意次</span><br><span class="line">			例如：x*y</span><br><span class="line">				xxy, xyy, y, </span><br><span class="line">		\\?: 0次或1次，它前面的字符是可有可无的</span><br><span class="line">			例如：x\\?y</span><br><span class="line">				xy, y, ay</span><br><span class="line">		\\&#123;m\\&#125;: m次，它前的字符要出现m次</span><br><span class="line">			例如：x\\&#123;2\\&#125;y</span><br><span class="line">				xy, xxy, y, xxxxy, xyy</span><br><span class="line">		\\&#123;m,n\\&#125;: 至少m次，至多n次</span><br><span class="line">			例如：x\\&#123;2,5\\&#125;y</span><br><span class="line">				xy, y, xxy</span><br><span class="line">		\\&#123;m,\\&#125;：至少m次</span><br><span class="line">		\\&#123;0,n\\&#125;: 至多n次</span><br><span class="line"></span><br><span class="line">		.*：任意长度的任意字符</span><br><span class="line"></span><br><span class="line">	位置锚定：</span><br><span class="line">		^: 行首锚定；</span><br><span class="line">			写在模式最左侧</span><br><span class="line">		$: 行尾锚定：</span><br><span class="line">			写在模式最右侧</span><br><span class="line">		^$: 空白行</span><br><span class="line">			</span><br><span class="line">			不包含特殊字符的连续字符组成的串叫单词：</span><br><span class="line">		\\&lt;: 词首，出现于单词左侧</span><br><span class="line">			\\&lt;char</span><br><span class="line">		\\&gt;: 词尾，出现于单词右侧</span><br><span class="line">			char\\&gt;</span><br><span class="line">	</span><br><span class="line">	分组...</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">扩展正则表达式：</span><br><span class="line">	字符匹配：</span><br><span class="line">		.</span><br><span class="line">		[]</span><br><span class="line">		[^]</span><br><span class="line">	次数匹配：</span><br><span class="line">		*：任意次</span><br><span class="line">		?: 0次或1次</span><br><span class="line">		+: 至少1次；</span><br><span class="line">		&#123;m&#125;: 精确匹配m次</span><br><span class="line">		&#123;m,n&#125;: 至少m次，至多n次</span><br><span class="line">		&#123;m,&#125;</span><br><span class="line">		&#123;0,n&#125;</span><br><span class="line">	位置锚定：</span><br><span class="line">		^</span><br><span class="line">		$</span><br><span class="line">		\&lt;, </span><br><span class="line">		\&gt;, </span><br><span class="line">		^$, ^[[:space:]]*$</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="应用到grep"><a href="#应用到grep" class="headerlink" title="应用到grep"></a>应用到grep</h1>
	
	</div>
  <a type="button" href="/2022/04/24/12-regex/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/26/Unix-Linux-proj-netDsic-II/" >Unix-Linux-proj-netDsic-II</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-26  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1>
	

	</div>
  <a type="button" href="/2022/03/26/Unix-Linux-proj-netDsic-II/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1>
	
	</div>
  <a type="button" href="/2022/03/26/Unix-Linux-proj-netDsic-II/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/14/database/" >database</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-14  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="Navicat-连接mysql"><a href="#Navicat-连接mysql" class="headerlink" title="Navicat 连接mysql"></a>Navicat 连接mysql</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装C-sql依赖的dev</span></span><br><span class="line"></span><br><span class="line">[scallacs@scallacs ~\ []$ sudo apt install libmysqlclient-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改配置文件</span></span><br><span class="line">[scallacs@scallacs ~\ []$ <span class="built_in">cd</span> /etc/mysql/mysql.conf.d/</span><br><span class="line">[scallacs@scallacs /etc/mysql/mysql.conf.d\ []$ sudo vim mysqld.cnf </span><br><span class="line">[sudo] password <span class="keyword">for</span> scallacs: </span><br><span class="line">[scallacs@scallacs /etc/mysql/mysql.conf.d\ []$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220326150818014.png" alt="image-20220326150818014"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 修改mysql配置</span></span><br><span class="line">$ mysql -u root -p</span><br><span class="line">&gt; use mysql;</span><br><span class="line">&gt; select host, user from user;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 将表项  localhost 改为 % , 重启服务，或者刷新权限</span></span><br><span class="line">&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220323171238791.png" alt="image-20220323171238791" style="zoom: 80%;">

<img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220323171301807.png" alt="image-20220323171301807" style="zoom: 80%;">

	

	</div>
  <a type="button" href="/2022/03/14/database/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="Navicat-连接mysql"><a href="#Navicat-连接mysql" class="headerlink" title="Navicat 连接mysql"></a>Navicat 连接mysql</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装C-sql依赖的dev</span></span><br><span class="line"></span><br><span class="line">[scallacs@scallacs ~\ []$ sudo apt install libmysqlclient-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改配置文件</span></span><br><span class="line">[scallacs@scallacs ~\ []$ <span class="built_in">cd</span> /etc/mysql/mysql.conf.d/</span><br><span class="line">[scallacs@scallacs /etc/mysql/mysql.conf.d\ []$ sudo vim mysqld.cnf </span><br><span class="line">[sudo] password <span class="keyword">for</span> scallacs: </span><br><span class="line">[scallacs@scallacs /etc/mysql/mysql.conf.d\ []$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220326150818014.png" alt="image-20220326150818014"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 修改mysql配置</span></span><br><span class="line">$ mysql -u root -p</span><br><span class="line">&gt; use mysql;</span><br><span class="line">&gt; select host, user from user;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 将表项  localhost 改为 % , 重启服务，或者刷新权限</span></span><br><span class="line">&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/image-20220323171238791.png" alt="image-20220323171238791" style="zoom: 80%;">

<img src="C:\Users\76403\AppData\Roaming\Typora\typora-user-images\image-20220323171301807.png" alt="image-20220323171301807" style="zoom: 80%;">

	
	</div>
  <a type="button" href="/2022/03/14/database/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/14/11.Unix-Linux-NetworkProgramming-II/" >Unix-Linux-NetworkProgramming-II</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-14  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、select-epoll对比"><a href="#一、select-epoll对比" class="headerlink" title="一、select epoll对比"></a>一、select epoll对比</h2><p>?不需询问没就绪的 网络连接高并发 <strong>epoll原理</strong></p>
<p><strong>触发方式</strong></p>
<h2 id="二、-进程池-amp-线程池"><a href="#二、-进程池-amp-线程池" class="headerlink" title="二、 进程池&amp;线程池"></a>二、 进程池&amp;线程池</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><h4 id="0-makefile"><a href="#0-makefile" class="headerlink" title="0.makefile"></a>0.makefile</h4><blockquote>
<p>复杂的应用重新写一下makefile</p>
</blockquote>
	

	</div>
  <a type="button" href="/2022/03/14/11.Unix-Linux-NetworkProgramming-II/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、select-epoll对比"><a href="#一、select-epoll对比" class="headerlink" title="一、select epoll对比"></a>一、select epoll对比</h2><p>?不需询问没就绪的 网络连接高并发 <strong>epoll原理</strong></p>
<p><strong>触发方式</strong></p>
<h2 id="二、-进程池-amp-线程池"><a href="#二、-进程池-amp-线程池" class="headerlink" title="二、 进程池&amp;线程池"></a>二、 进程池&amp;线程池</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><h4 id="0-makefile"><a href="#0-makefile" class="headerlink" title="0.makefile"></a>0.makefile</h4><blockquote>
<p>复杂的应用重新写一下makefile</p>
</blockquote>
	
	</div>
  <a type="button" href="/2022/03/14/11.Unix-Linux-NetworkProgramming-II/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/14/Unix-Linux-proj-netdisc/" >netdisk</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-14  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="v1"><a href="#v1" class="headerlink" title="v1"></a>v1</h1><blockquote>
<p>目标：写客户端，服务端，服务端响应客户端命令请求 + 密码验证，登录，日志，断点续传，大文件<code>mmap</code></p>
</blockquote>
<blockquote>
<p>整合此前的各个库函数与系统调用实现的<strong>命令</strong>，搭建基本的服务端框架和客户端雏形，使得客户端发出指令，服务端能够解析他们并做出对应的功能响应。</p>
<p>命令包括<code> cd, ls, pwd, mkdir, rm, puts, gets...</code></p>
</blockquote>
<h2 id="1-搭建服务端框架"><a href="#1-搭建服务端框架" class="headerlink" title="1.搭建服务端框架"></a>1.搭建服务端框架</h2><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/%E6%95%B4%E4%BD%93%E6%A8%A1%E5%9E%8B.jpg" alt="大致线程池模型"></p>
<blockquote>
<p>服务端需要维护一个线程池做业务处理</p>
</blockquote>
<p><code>整体代码结构</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">## 最终定下的代码结构如下</span><br><span class="line">.</span><br><span class="line">├── client</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   ├── head<span class="selector-class">.h</span></span><br><span class="line">│   │   └── train<span class="selector-class">.h</span></span><br><span class="line">│   ├── obj</span><br><span class="line">│   └── <span class="attribute">src</span></span><br><span class="line">│       ├── client<span class="selector-class">.c</span></span><br><span class="line">│       ├── download<span class="selector-class">.c</span></span><br><span class="line">│       ├── recv<span class="selector-class">.c</span></span><br><span class="line">│       ├── send<span class="selector-class">.c</span></span><br><span class="line">│       └── upload<span class="selector-class">.c</span></span><br><span class="line">├── Makefile</span><br><span class="line">└── server</span><br><span class="line">    ├── server</span><br><span class="line">    │   ├── include</span><br><span class="line">    │   │   ├── factory<span class="selector-class">.h</span>       - 整个线程池的共享资源信息</span><br><span class="line">    │   │   ├── head<span class="selector-class">.h</span>          - 项目头文件，封装好，其余程序只需引用此文件即可</span><br><span class="line">    │   │   ├── netList<span class="selector-class">.h</span>       - !用户连接成功加入，为什么一个任务完成就要移除? </span><br><span class="line">    │   │   ├── taskQueue<span class="selector-class">.h</span>     - 每个功能的对应函数要执行时建立一个!task，主线程专用一个线程来调!parse</span><br><span class="line">    │   │   └── train<span class="selector-class">.h</span>         - 封装的火车头文件传输协议</span><br><span class="line">    ├── repository              - 资源仓库</span><br><span class="line">    │   ├── dir1</span><br><span class="line">    │   │   ├── file2</span><br><span class="line">    │   │   └── file3</span><br><span class="line">    │   ├── dir2</span><br><span class="line">    │   │   └── file4</span><br><span class="line">    │   └── file1</span><br><span class="line">    └── <span class="attribute">src</span></span><br><span class="line">        ├── epollFunc<span class="selector-class">.c</span>         - 封装多路复用</span><br><span class="line">        ├── factoryInit<span class="selector-class">.c</span>       - 封装共享资源初始化</span><br><span class="line">        ├── freeTask<span class="selector-class">.c</span>          - !在线程创建函数中，线程执行结束调用，释放分配的堆区内存，!mallocTaskArg</span><br><span class="line">        ├── getTaskArg<span class="selector-class">.c</span>        - !strtok涉及二级指针和内存分配</span><br><span class="line">        ├── mallocTaskArg<span class="selector-class">.c</span>     - !strtok涉及二级指针和内存分配</span><br><span class="line">        ├── makeWorker<span class="selector-class">.c</span>        - 创建子线程</span><br><span class="line">        ├── netInsert<span class="selector-class">.c</span>         - 链表节点入队操作</span><br><span class="line">        ├── netRemove<span class="selector-class">.c</span>         - 链表节点出队操作 思路要清晰</span><br><span class="line">        ├── parse<span class="selector-class">.c</span>             - 主线程调用的专用于解析命令的功能函数，取参数把对应功能加入任务队列</span><br><span class="line">        ├── get<span class="selector-class">.c</span>               - 服务端发送文件给客户端</span><br><span class="line">        ├── put<span class="selector-class">.c</span>               - 服务端接收文件，对应客户端的功能</span><br><span class="line">        ├── mkDir<span class="selector-class">.c</span>             - 目录流,...</span><br><span class="line">        ├── cd<span class="selector-class">.c</span>                - 目录流,考虑正常切换，错误切换，在根往前切换...</span><br><span class="line">        ├── rm<span class="selector-class">.c</span>                - 目录流,...</span><br><span class="line">        ├── ls<span class="selector-class">.c</span>                - 目录流,注意统一客户端与服务端的信息传输</span><br><span class="line">        ├── pwd<span class="selector-class">.c</span>               - 理论上不需要服务端做什么</span><br><span class="line">        ├── enter<span class="selector-class">.c</span>             - 登录注册</span><br><span class="line">        ├── quit<span class="selector-class">.c</span>			   - 退出</span><br><span class="line">        ├── recv<span class="selector-class">.c</span>              - 封装的收发信息接口</span><br><span class="line">        ├── send<span class="selector-class">.c</span>              - 封装的收发信息接口</span><br><span class="line">        ├── server<span class="selector-class">.c</span>            - 线程池主要逻辑，将此前的事件处理封装成结构体， 再理一下思路</span><br><span class="line">        ├── taskDequeue<span class="selector-class">.c</span>       - 线程被唤醒，会从任务队列中出队一个任务， 执行完释放</span><br><span class="line">        ├── taskEnqueue<span class="selector-class">.c</span>       - 有功能函数要调用时，将它入队，在这个函数中分配内存，创建任务</span><br><span class="line">        ├── tcpInit<span class="selector-class">.c</span>           - 封装服务端网络初始化操作</span><br><span class="line">        └── threadFunc<span class="selector-class">.c</span>        - 线程创建函数，涉及条件变量，锁的使用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><code>server</code></p>
<blockquote>
<p>服务端关于<code>netFd </code>与<code> netList</code>的设计 </p>
<p>对于<code>netFd</code>，用户连接成功时加入<code>netList</code>，为什么在<code>epoll</code>监听的新命令就绪即有用户指令到达时要将<code>netFd</code>移出<code>netList?</code><br>因为主线程监听到<code>netFd</code>(已登录套接字就绪)有命令到，会调用<code>taskEnque</code>让专用于解析命令的功能函数<code>parse</code>作为一个任务入队。执行<code>parse</code>的线程走完，会让一个命令(用户想要执行的)作为一个任务加入任务队列。而加入任务队列的这些命令(功能函数，包括<code>parse</code>解析到非系统命令的情况)末尾的代码逻辑是让<code>netFd</code>重新加入监听。<br>所以在<code>server</code>主线程中需要在命令执行前将<code>netFd</code>移除，它将在任务执行完毕时加入，而处理任务时出队，处理完再入队是符合逻辑的。</p>
</blockquote>
	

	</div>
  <a type="button" href="/2022/03/14/Unix-Linux-proj-netdisc/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="v1"><a href="#v1" class="headerlink" title="v1"></a>v1</h1><blockquote>
<p>目标：写客户端，服务端，服务端响应客户端命令请求 + 密码验证，登录，日志，断点续传，大文件<code>mmap</code></p>
</blockquote>
<blockquote>
<p>整合此前的各个库函数与系统调用实现的<strong>命令</strong>，搭建基本的服务端框架和客户端雏形，使得客户端发出指令，服务端能够解析他们并做出对应的功能响应。</p>
<p>命令包括<code> cd, ls, pwd, mkdir, rm, puts, gets...</code></p>
</blockquote>
<h2 id="1-搭建服务端框架"><a href="#1-搭建服务端框架" class="headerlink" title="1.搭建服务端框架"></a>1.搭建服务端框架</h2><p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/Proj-NetDisc/v1/%E6%95%B4%E4%BD%93%E6%A8%A1%E5%9E%8B.jpg" alt="大致线程池模型"></p>
<blockquote>
<p>服务端需要维护一个线程池做业务处理</p>
</blockquote>
<p><code>整体代码结构</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">## 最终定下的代码结构如下</span><br><span class="line">.</span><br><span class="line">├── client</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   ├── head<span class="selector-class">.h</span></span><br><span class="line">│   │   └── train<span class="selector-class">.h</span></span><br><span class="line">│   ├── obj</span><br><span class="line">│   └── <span class="attribute">src</span></span><br><span class="line">│       ├── client<span class="selector-class">.c</span></span><br><span class="line">│       ├── download<span class="selector-class">.c</span></span><br><span class="line">│       ├── recv<span class="selector-class">.c</span></span><br><span class="line">│       ├── send<span class="selector-class">.c</span></span><br><span class="line">│       └── upload<span class="selector-class">.c</span></span><br><span class="line">├── Makefile</span><br><span class="line">└── server</span><br><span class="line">    ├── server</span><br><span class="line">    │   ├── include</span><br><span class="line">    │   │   ├── factory<span class="selector-class">.h</span>       - 整个线程池的共享资源信息</span><br><span class="line">    │   │   ├── head<span class="selector-class">.h</span>          - 项目头文件，封装好，其余程序只需引用此文件即可</span><br><span class="line">    │   │   ├── netList<span class="selector-class">.h</span>       - !用户连接成功加入，为什么一个任务完成就要移除? </span><br><span class="line">    │   │   ├── taskQueue<span class="selector-class">.h</span>     - 每个功能的对应函数要执行时建立一个!task，主线程专用一个线程来调!parse</span><br><span class="line">    │   │   └── train<span class="selector-class">.h</span>         - 封装的火车头文件传输协议</span><br><span class="line">    ├── repository              - 资源仓库</span><br><span class="line">    │   ├── dir1</span><br><span class="line">    │   │   ├── file2</span><br><span class="line">    │   │   └── file3</span><br><span class="line">    │   ├── dir2</span><br><span class="line">    │   │   └── file4</span><br><span class="line">    │   └── file1</span><br><span class="line">    └── <span class="attribute">src</span></span><br><span class="line">        ├── epollFunc<span class="selector-class">.c</span>         - 封装多路复用</span><br><span class="line">        ├── factoryInit<span class="selector-class">.c</span>       - 封装共享资源初始化</span><br><span class="line">        ├── freeTask<span class="selector-class">.c</span>          - !在线程创建函数中，线程执行结束调用，释放分配的堆区内存，!mallocTaskArg</span><br><span class="line">        ├── getTaskArg<span class="selector-class">.c</span>        - !strtok涉及二级指针和内存分配</span><br><span class="line">        ├── mallocTaskArg<span class="selector-class">.c</span>     - !strtok涉及二级指针和内存分配</span><br><span class="line">        ├── makeWorker<span class="selector-class">.c</span>        - 创建子线程</span><br><span class="line">        ├── netInsert<span class="selector-class">.c</span>         - 链表节点入队操作</span><br><span class="line">        ├── netRemove<span class="selector-class">.c</span>         - 链表节点出队操作 思路要清晰</span><br><span class="line">        ├── parse<span class="selector-class">.c</span>             - 主线程调用的专用于解析命令的功能函数，取参数把对应功能加入任务队列</span><br><span class="line">        ├── get<span class="selector-class">.c</span>               - 服务端发送文件给客户端</span><br><span class="line">        ├── put<span class="selector-class">.c</span>               - 服务端接收文件，对应客户端的功能</span><br><span class="line">        ├── mkDir<span class="selector-class">.c</span>             - 目录流,...</span><br><span class="line">        ├── cd<span class="selector-class">.c</span>                - 目录流,考虑正常切换，错误切换，在根往前切换...</span><br><span class="line">        ├── rm<span class="selector-class">.c</span>                - 目录流,...</span><br><span class="line">        ├── ls<span class="selector-class">.c</span>                - 目录流,注意统一客户端与服务端的信息传输</span><br><span class="line">        ├── pwd<span class="selector-class">.c</span>               - 理论上不需要服务端做什么</span><br><span class="line">        ├── enter<span class="selector-class">.c</span>             - 登录注册</span><br><span class="line">        ├── quit<span class="selector-class">.c</span>			   - 退出</span><br><span class="line">        ├── recv<span class="selector-class">.c</span>              - 封装的收发信息接口</span><br><span class="line">        ├── send<span class="selector-class">.c</span>              - 封装的收发信息接口</span><br><span class="line">        ├── server<span class="selector-class">.c</span>            - 线程池主要逻辑，将此前的事件处理封装成结构体， 再理一下思路</span><br><span class="line">        ├── taskDequeue<span class="selector-class">.c</span>       - 线程被唤醒，会从任务队列中出队一个任务， 执行完释放</span><br><span class="line">        ├── taskEnqueue<span class="selector-class">.c</span>       - 有功能函数要调用时，将它入队，在这个函数中分配内存，创建任务</span><br><span class="line">        ├── tcpInit<span class="selector-class">.c</span>           - 封装服务端网络初始化操作</span><br><span class="line">        └── threadFunc<span class="selector-class">.c</span>        - 线程创建函数，涉及条件变量，锁的使用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><code>server</code></p>
<blockquote>
<p>服务端关于<code>netFd </code>与<code> netList</code>的设计 </p>
<p>对于<code>netFd</code>，用户连接成功时加入<code>netList</code>，为什么在<code>epoll</code>监听的新命令就绪即有用户指令到达时要将<code>netFd</code>移出<code>netList?</code><br>因为主线程监听到<code>netFd</code>(已登录套接字就绪)有命令到，会调用<code>taskEnque</code>让专用于解析命令的功能函数<code>parse</code>作为一个任务入队。执行<code>parse</code>的线程走完，会让一个命令(用户想要执行的)作为一个任务加入任务队列。而加入任务队列的这些命令(功能函数，包括<code>parse</code>解析到非系统命令的情况)末尾的代码逻辑是让<code>netFd</code>重新加入监听。<br>所以在<code>server</code>主线程中需要在命令执行前将<code>netFd</code>移除，它将在任务执行完毕时加入，而处理任务时出队，处理完再入队是符合逻辑的。</p>
</blockquote>
	
	</div>
  <a type="button" href="/2022/03/14/Unix-Linux-proj-netdisc/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/13/10.Unix-Linux-Network-Programming/" >Unix-Linux-Network-Programming</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-13  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><blockquote>
<p>Berkeley socket 伯克利套接字，网络编程的实施标准</p>
<p>socket是网络中用来建立连接，网络通信的设备，用户创建socket可以通过其发起或接受TCP连接，可以向TCP的<strong>发送和接收缓冲区中读写TCP数据段</strong>，或者UCP文本</p>
<p>大小端问题(一个源于商业的历史遗留问题)一般主机使用小端法(主机字节序)，而用于网络传输，使用大端法(网络字节序) 判断方式如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *c=(<span class="keyword">char</span> *)&amp;i; </span><br><span class="line">    <span class="keyword">if</span>(*c == <span class="number">0x12</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;big ending!&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;little ending!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/testendong ./isBigEnding </span><br><span class="line">little ending!</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><blockquote>
<p>设计网络需要的几个结构体(设置地址信息)</p>
<p>通用的地址结构 <code>struct sockadd</code> 但是过于通用导致设置复杂，惯用法是通过以下两个结构体来构造地址，利用其<strong>内存布局一致的特点</strong>强转为<code>struct sockaddr </code>作为参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//man 7 ip </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* address family: AF_INET */</span> </span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port; <span class="comment">/* port in network byte order */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* internet address */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Internet address. */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_addr; <span class="comment">/* address in network byte order */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>整数大小端转化接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>



<p>网络字节序IP与点分十进制IP转化接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>



<p>使用域名获取IP的接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name; <span class="comment">/* official name of host */</span> </span><br><span class="line">    <span class="keyword">char</span> **h_aliases; <span class="comment">/* alias list */</span> </span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">/* host address type */</span> </span><br><span class="line">    <span class="keyword">int</span> h_length; <span class="comment">/* length of address */</span> </span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">/* list of addresses */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把TCP的通信机制看做两条管道，通信双方为A和B，三次握手分别做了一下几件事</span><br><span class="line">第一次握手A-&gt;B : 现在B知道了A-&gt;B 的通信是正常的  即B知道:A的发送B的接收正常</span><br><span class="line">第二次握手B-&gt;A : 现在A知道了A-&gt;B 与 B-&gt;A的通信是正常的 即A知道:A与B的收发都正常，但B不能确定A的收正常</span><br><span class="line">第三次握手A-&gt;B : 现在A知道自己的收发和B的收发都没有问题，而B还需确认A的接收能力。</span><br><span class="line"></span><br><span class="line">如果只有两次握手，那么B是没能确认A的接收能力的，如果认为两次握手后通信无误，那么A可能只是发了连接请求就关闭了此时认为连接建立成功的B只能永久等待</span><br></pre></td></tr></table></figure>
	

	</div>
  <a type="button" href="/2022/03/13/10.Unix-Linux-Network-Programming/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><blockquote>
<p>Berkeley socket 伯克利套接字，网络编程的实施标准</p>
<p>socket是网络中用来建立连接，网络通信的设备，用户创建socket可以通过其发起或接受TCP连接，可以向TCP的<strong>发送和接收缓冲区中读写TCP数据段</strong>，或者UCP文本</p>
<p>大小端问题(一个源于商业的历史遗留问题)一般主机使用小端法(主机字节序)，而用于网络传输，使用大端法(网络字节序) 判断方式如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *c=(<span class="keyword">char</span> *)&amp;i; </span><br><span class="line">    <span class="keyword">if</span>(*c == <span class="number">0x12</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;big ending!&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;little ending!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">scallacs@scallacs:~/testendong ./isBigEnding </span><br><span class="line">little ending!</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><blockquote>
<p>设计网络需要的几个结构体(设置地址信息)</p>
<p>通用的地址结构 <code>struct sockadd</code> 但是过于通用导致设置复杂，惯用法是通过以下两个结构体来构造地址，利用其<strong>内存布局一致的特点</strong>强转为<code>struct sockaddr </code>作为参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//man 7 ip </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* address family: AF_INET */</span> </span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port; <span class="comment">/* port in network byte order */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* internet address */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Internet address. */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_addr; <span class="comment">/* address in network byte order */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>整数大小端转化接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>



<p>网络字节序IP与点分十进制IP转化接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>



<p>使用域名获取IP的接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *h_name; <span class="comment">/* official name of host */</span> </span><br><span class="line">    <span class="keyword">char</span> **h_aliases; <span class="comment">/* alias list */</span> </span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">/* host address type */</span> </span><br><span class="line">    <span class="keyword">int</span> h_length; <span class="comment">/* length of address */</span> </span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">/* list of addresses */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把TCP的通信机制看做两条管道，通信双方为A和B，三次握手分别做了一下几件事</span><br><span class="line">第一次握手A-&gt;B : 现在B知道了A-&gt;B 的通信是正常的  即B知道:A的发送B的接收正常</span><br><span class="line">第二次握手B-&gt;A : 现在A知道了A-&gt;B 与 B-&gt;A的通信是正常的 即A知道:A与B的收发都正常，但B不能确定A的收正常</span><br><span class="line">第三次握手A-&gt;B : 现在A知道自己的收发和B的收发都没有问题，而B还需确认A的接收能力。</span><br><span class="line"></span><br><span class="line">如果只有两次握手，那么B是没能确认A的接收能力的，如果认为两次握手后通信无误，那么A可能只是发了连接请求就关闭了此时认为连接建立成功的B只能永久等待</span><br></pre></td></tr></table></figure>
	
	</div>
  <a type="button" href="/2022/03/13/10.Unix-Linux-Network-Programming/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/09/9.APUE-1-Overview/" >APUE_1_Overview</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-09  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>不同版本UNIX操作系统提供的服务</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/APUE/Unix%E6%9E%B6%E6%9E%84.png" alt="架构图"></p>
<blockquote>
<p>一些概念摘抄</p>
<p>逻辑上可以认为每个目录项包含一个文件名，以及说明该文件属性的信息</p>
<p>登录时，工作目录设置为起始目录，从口令文件<code>/etc/passwd</code>中相应用户登录项获取</p>
<p>文件描述符<code>file discriptor</code>内核用以标识特定进程正在访问的文件,对内核而言，所有打开的文件都用文件描述符引用</p>
<p>标准I/O 不带缓冲I/O<code>unbuffered I/O</code></p>
<p>程序是存储在磁盘上某个目录中的可执行文件，内核使用<code>exec</code>函数将程序读入内存</p>
<p>之所以使用用户ID和组ID是历史原因，存储两个值4字节，存储完整的用户名和组名需要更多磁盘空间，检查权限时，比较字符串比比较整型数更耗时间</p>
<p>从实现者的角度看，系统调用和库函数之间有根本的区别，但从用户的角度看，其区别并不重要；系统调用通常提供一种最小接口，而库函数则提供比较复杂的功能。</p>
<p><code>POSIX : Portable Operating System Interface</code></p>
<p>每个打开的文件都有一个与其相关联的”当前文件偏移量”(<code>current file offset</code>)通常，读写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。</p>
<p>文件偏移量可以大于文件的当前长度，在此情况下对该文件的下一次写将加长该文件并在文件中构成文件空洞(文件空洞不要求在磁盘上占存储区，只做定位具体处理方式看文件系统的实现)</p>
</blockquote>
<blockquote>
<p>文件操作</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/APUE/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="打开文件的内核数据结构"></p>
<blockquote>
<p>Linux 采用一个与文件系统无关的i节点和一个与文件系统相关的i节点</p>
<p>任何多于一个函数调用的操作都不是原子操作，因为在两个函数调用之间，内核可能临时挂起进程。</p>
<p><code>/dev/fd</code>目录中，目录项为0， 1， 2等文件， 打开<code>/dev/fd/n</code>等效于复制描述符n</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[scallacs@VM-16-8-ubuntu /dev/fd\ []$ ls</span><br><span class="line">0  1  2  255</span><br><span class="line">[scallacs@VM-16-8-ubuntu /dev/fd\ []$ ll</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 scallacs scallacs  0 Mar 10 14:47 ./</span><br><span class="line">dr-xr-xr-x 9 scallacs scallacs  0 Mar 10 14:26 ../</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 0 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 1 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 2 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 255 -&gt; /dev/pts/4</span><br></pre></td></tr></table></figure>

<p>它把文件描述符映射为指向底层物理文件的符号链接</p>
<p><code>read, write</code>都在内核执行，所以成为不带缓冲的I/O函数</p>
<p>为了执行程序，内核必须理解二进制可执行文件的格式，所有二进制可执行文件都遵循一种标准化的格式，这种格式使内核能确定程序文本和数据的加载位置。</p>
</blockquote>

	

	</div>
  <a type="button" href="/2022/03/09/9.APUE-1-Overview/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>不同版本UNIX操作系统提供的服务</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/APUE/Unix%E6%9E%B6%E6%9E%84.png" alt="架构图"></p>
<blockquote>
<p>一些概念摘抄</p>
<p>逻辑上可以认为每个目录项包含一个文件名，以及说明该文件属性的信息</p>
<p>登录时，工作目录设置为起始目录，从口令文件<code>/etc/passwd</code>中相应用户登录项获取</p>
<p>文件描述符<code>file discriptor</code>内核用以标识特定进程正在访问的文件,对内核而言，所有打开的文件都用文件描述符引用</p>
<p>标准I/O 不带缓冲I/O<code>unbuffered I/O</code></p>
<p>程序是存储在磁盘上某个目录中的可执行文件，内核使用<code>exec</code>函数将程序读入内存</p>
<p>之所以使用用户ID和组ID是历史原因，存储两个值4字节，存储完整的用户名和组名需要更多磁盘空间，检查权限时，比较字符串比比较整型数更耗时间</p>
<p>从实现者的角度看，系统调用和库函数之间有根本的区别，但从用户的角度看，其区别并不重要；系统调用通常提供一种最小接口，而库函数则提供比较复杂的功能。</p>
<p><code>POSIX : Portable Operating System Interface</code></p>
<p>每个打开的文件都有一个与其相关联的”当前文件偏移量”(<code>current file offset</code>)通常，读写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。</p>
<p>文件偏移量可以大于文件的当前长度，在此情况下对该文件的下一次写将加长该文件并在文件中构成文件空洞(文件空洞不要求在磁盘上占存储区，只做定位具体处理方式看文件系统的实现)</p>
</blockquote>
<blockquote>
<p>文件操作</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/APUE/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="打开文件的内核数据结构"></p>
<blockquote>
<p>Linux 采用一个与文件系统无关的i节点和一个与文件系统相关的i节点</p>
<p>任何多于一个函数调用的操作都不是原子操作，因为在两个函数调用之间，内核可能临时挂起进程。</p>
<p><code>/dev/fd</code>目录中，目录项为0， 1， 2等文件， 打开<code>/dev/fd/n</code>等效于复制描述符n</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[scallacs@VM-16-8-ubuntu /dev/fd\ []$ ls</span><br><span class="line">0  1  2  255</span><br><span class="line">[scallacs@VM-16-8-ubuntu /dev/fd\ []$ ll</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 scallacs scallacs  0 Mar 10 14:47 ./</span><br><span class="line">dr-xr-xr-x 9 scallacs scallacs  0 Mar 10 14:26 ../</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 0 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 1 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 2 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 scallacs scallacs 64 Mar 10 14:47 255 -&gt; /dev/pts/4</span><br></pre></td></tr></table></figure>

<p>它把文件描述符映射为指向底层物理文件的符号链接</p>
<p><code>read, write</code>都在内核执行，所以成为不带缓冲的I/O函数</p>
<p>为了执行程序，内核必须理解二进制可执行文件的格式，所有二进制可执行文件都遵循一种标准化的格式，这种格式使内核能确定程序文本和数据的加载位置。</p>
</blockquote>

	
	</div>
  <a type="button" href="/2022/03/09/9.APUE-1-Overview/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/07/8.Unix-Linux-Thread/" >8.Unix-Linux-Thread</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-07  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、线程基础"><a href="#一、线程基础" class="headerlink" title="一、线程基础"></a>一、线程基础</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote>
<p>在Linux中线程是轻量级的进程(LWP:Low-weight-Process)减少进程切换的开销,它也拥有独立的task_struct作为独立的动态执行流(同属于一个进程的多个线程task_struct中有大量字段相同或共享)方便CPU进行调度。</p>
<p>进程除了作为独立的执行流外，还是资源分配的基本单位，使用线程并非要取代进程，而是让一个进程中存在多个线程，它们共享内存资源(线程有独立的栈但堆，数据段，代码段，文件描述符，信号屏蔽字等共享)，同时把CPU的调度单位细化为线程。</p>
<p>分析性能时，计算机将大量的时间花费在进程切换上(上下文切换:CPU寄存器中大量信息:堆栈，代码段…:寄存器与内存间的保存与载入工作；进程切换虚拟内存页表切换)</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/进程管理/线程模型.jpg" alt="线程" style="zoom:80%;">

<blockquote>
<p>同一个进程的多个线程各自拥有自己的栈，这些栈虽然是独立的，但是都位于同一个地址空间中，所以一个线程可以通过地址去访问另一个线程的栈区。</p>
</blockquote>
<blockquote>
<p>多线程天生就能利用多核的CPU架构，此前的进程都可以认为是单线程进程</p>
<p>使用线程库NPTL(Native Posix Threads Library)</p>
</blockquote>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3>
	

	</div>
  <a type="button" href="/2022/03/07/8.Unix-Linux-Thread/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、线程基础"><a href="#一、线程基础" class="headerlink" title="一、线程基础"></a>一、线程基础</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote>
<p>在Linux中线程是轻量级的进程(LWP:Low-weight-Process)减少进程切换的开销,它也拥有独立的task_struct作为独立的动态执行流(同属于一个进程的多个线程task_struct中有大量字段相同或共享)方便CPU进行调度。</p>
<p>进程除了作为独立的执行流外，还是资源分配的基本单位，使用线程并非要取代进程，而是让一个进程中存在多个线程，它们共享内存资源(线程有独立的栈但堆，数据段，代码段，文件描述符，信号屏蔽字等共享)，同时把CPU的调度单位细化为线程。</p>
<p>分析性能时，计算机将大量的时间花费在进程切换上(上下文切换:CPU寄存器中大量信息:堆栈，代码段…:寄存器与内存间的保存与载入工作；进程切换虚拟内存页表切换)</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/进程管理/线程模型.jpg" alt="线程" style="zoom:80%;">

<blockquote>
<p>同一个进程的多个线程各自拥有自己的栈，这些栈虽然是独立的，但是都位于同一个地址空间中，所以一个线程可以通过地址去访问另一个线程的栈区。</p>
</blockquote>
<blockquote>
<p>多线程天生就能利用多核的CPU架构，此前的进程都可以认为是单线程进程</p>
<p>使用线程库NPTL(Native Posix Threads Library)</p>
</blockquote>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3>
	
	</div>
  <a type="button" href="/2022/03/07/8.Unix-Linux-Thread/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/03/02/7.Unix-Linux-Process-management/" >Unix-Linux-Process-management</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-03-02  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、进程基础"><a href="#一、进程基础" class="headerlink" title="一、进程基础"></a>一、进程基础</h2><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0.概念"></a>0.概念</h3><blockquote>
<p>程序：静态文件，二进制指令和数据的集合，存储在磁盘中</p>
<p>进程：程序的动态执行过程，资源分配的基本单位(占CPU资源以执行程序指令，占存储资源以保存状态(数据段，代码段，堆…))，进程是处于执行器的程序和相关资源的总称。(同一份静态程序，可以启动多个不同进程).以进程的视角来看，它是独占CPU的，同时它也是独占内存空间的。以进程视角看到的内存空间称为虚拟内存空间。如下图所示。</p>
<p>[注]在内核态空间里面，与进程相关的数据结构是每个进程都不同的，物理存储器和内核代码数据是所有进程共享的。内核进程通常被成为内核线程，因为它们没有自己的独立地址空间，它们永远运行在内核态空间或者说它们本身就是内核的一部分。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%9B%B4%E7%BB%86%E5%8C%96%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.jpg" alt="更细化恶虚拟内存空间"></p>
<blockquote>
<p>Linux开机:(ROM中存有自举程序，计算机加电，CPU的PC置为自举程序的第一条指令，这个程序的唯一职责是把OS本身(至少是启动计算机的那部分)装入内存)主要关注进程的话，略过这些细节，在所有硬件配置好的情况下，<strong>这时bootloader程序会启动0号进程。0号进程会配置实时时钟，它的主要工作是启动1号进程(init,新版中被systemd取代)和2号进程(页面守护进程)</strong>,0号进程在启动完1号2号进程后终止(后面OS会再重启一个0号进程，但功能完全不同，它是idel空闲进程PID:0, 因为CPU总要选择一个进程运行，所以没活干的时候让CPU运行idel进程以省电。<strong>1号进程是其他所有用户进程的祖先, 2号进程是其他内核线程的祖先</strong>内核进程不占用户虚拟地址，也称做用户线程</p>
</blockquote>
<h3 id="1-一些库函数和系统调用"><a href="#1-一些库函数和系统调用" class="headerlink" title="1.一些库函数和系统调用"></a>1.一些库函数和系统调用</h3><p><code>GETPID(2)</code></p>
	

	</div>
  <a type="button" href="/2022/03/02/7.Unix-Linux-Process-management/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><em>go on</em></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一、进程基础"><a href="#一、进程基础" class="headerlink" title="一、进程基础"></a>一、进程基础</h2><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0.概念"></a>0.概念</h3><blockquote>
<p>程序：静态文件，二进制指令和数据的集合，存储在磁盘中</p>
<p>进程：程序的动态执行过程，资源分配的基本单位(占CPU资源以执行程序指令，占存储资源以保存状态(数据段，代码段，堆…))，进程是处于执行器的程序和相关资源的总称。(同一份静态程序，可以启动多个不同进程).以进程的视角来看，它是独占CPU的，同时它也是独占内存空间的。以进程视角看到的内存空间称为虚拟内存空间。如下图所示。</p>
<p>[注]在内核态空间里面，与进程相关的数据结构是每个进程都不同的，物理存储器和内核代码数据是所有进程共享的。内核进程通常被成为内核线程，因为它们没有自己的独立地址空间，它们永远运行在内核态空间或者说它们本身就是内核的一部分。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lacsscal/pictureBed/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%9B%B4%E7%BB%86%E5%8C%96%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86.jpg" alt="更细化恶虚拟内存空间"></p>
<blockquote>
<p>Linux开机:(ROM中存有自举程序，计算机加电，CPU的PC置为自举程序的第一条指令，这个程序的唯一职责是把OS本身(至少是启动计算机的那部分)装入内存)主要关注进程的话，略过这些细节，在所有硬件配置好的情况下，<strong>这时bootloader程序会启动0号进程。0号进程会配置实时时钟，它的主要工作是启动1号进程(init,新版中被systemd取代)和2号进程(页面守护进程)</strong>,0号进程在启动完1号2号进程后终止(后面OS会再重启一个0号进程，但功能完全不同，它是idel空闲进程PID:0, 因为CPU总要选择一个进程运行，所以没活干的时候让CPU运行idel进程以省电。<strong>1号进程是其他所有用户进程的祖先, 2号进程是其他内核线程的祖先</strong>内核进程不占用户虚拟地址，也称做用户线程</p>
</blockquote>
<h3 id="1-一些库函数和系统调用"><a href="#1-一些库函数和系统调用" class="headerlink" title="1.一些库函数和系统调用"></a>1.一些库函数和系统调用</h3><p><code>GETPID(2)</code></p>
	
	</div>
  <a type="button" href="/2022/03/02/7.Unix-Linux-Process-management/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2022/02/26/6.Unix-Linux-file-management/" >Unix/Linux-file-management</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2022-02-26  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-一点历史"><a href="#0-一点历史" class="headerlink" title="0 .一点历史"></a>0 .一点历史</h3><blockquote>
<p>还是从一点历史引入，感觉了解一些历史缘由，会更好地理解采用某种特定实现技术的原因</p>
<p>看了一点《The art of Unix Programming》 序中有一句话挺吸引我</p>
<p><em>Unix is not so much an operating system as an oral history.  —-Neal Stephenson</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-&gt;(早期)批处理OS</span><br><span class="line">-&gt;(1960)MIT分时OS:多终端+大型机</span><br><span class="line">-&gt;(1965)AT&amp;T:Bell+MIT+GE(通用电气):Multics计划(全面通用分时OS:bye)</span><br><span class="line">-&gt;(1969)Bell认为该计划GG,退出 (不算失败，有些成果) ：Ken Thompson 写了 Space Travle, PDP-7小型机移植，对它重写OS内核并移植 称Unics</span><br><span class="line">-&gt;Unics(核心哲学:一切皆文件, 程序的目的只有一个-有效的完成目标 : 与Multics理念不同《The Art of Unix Programming》)</span><br><span class="line">-&gt;(1969)Linus Torvalds 在芬兰诞生</span><br><span class="line">-&gt;尝试用高级语言解决移植问题BCPL, PASCAL-&gt;编译出的内核性能不够好-&gt;根据BCPL发明C</span><br><span class="line">-&gt;(1973)Deneish Richie(C的主要发明者)用C重写了Unics系统(提供了管道等重要功能),更名为Unix</span><br><span class="line">-&gt;(1977)AT&amp;T将Unix源代码(用C写的,高可移植性)发给学术界-&gt;UC Berkeley-&gt;Bill Joy professor 编译成适合自己机器的系统，增减一些功能:命名为BSD(Berkeley Software Distribution)</span><br><span class="line">-&gt;(1979)AT&amp;T:推出System V(five(Sun - Solaris)):第七版(不再开源:商业纠纷开始):特性:可以支持x86架构的个人计算机</span><br><span class="line">-&gt;(1984)不再开源对教授OS的professor产生了影响:Andrew TannenBaum-&gt;自己写个Mini Unix -&gt; Minix</span><br><span class="line">-&gt;(1986)完成Minix, 并出版《Operating System : Design and Implementation》附带Minix的源代码</span><br><span class="line">        《Modern Operating System》也是他写的</span><br><span class="line">-&gt;同期 Richard Stallman 发起了GNU计划:GNU:Gnu is not Unix!(GCC, Emacs, Bash Shell, GDB...)目标创建一套完全自由的Unix OS(当时的Unix与硬件捆绑销售)但是缺少Unix内核</span><br><span class="line">-&gt;草拟 GPL协议(General Publilc License | 🙂 copyleft &lt;!-&gt; copyright:著作权) 开源 != 免费(维护可以收费)</span><br><span class="line">-&gt;(1988)IEEE:POSIX标准(旨在:保证各个OS间的兼容性) (IEEE-IX-&gt;POSIX:Portable Operating System Interface X:(Unix))可移植...</span><br><span class="line">-&gt;(1993)Linus:宏内核构造的Linux内核面世</span><br></pre></td></tr></table></figure>

<h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><blockquote>
<p>感觉之前学过很多次，并且每次学习也有用纸质或者文档记录，博客记录学到，使用过的命令，但大多情况学过不用就忘了，不是长久之计，这次就不记录这些。尽量多用以熟练。同时，本文的侧重点不在使用这方面，想要更深入的学习一些东西。</p>
</blockquote>
<blockquote>
<p>如果有不会的熟练使用 <code>$man</code></p>
<p>一点准备工作，环境使用的Ubuntu18.04 帮助手册不全<code>sudo apt install manpages-posix-dev</code></p>
</blockquote>
<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3>
	

	</div>
  <a type="button" href="/2022/02/26/6.Unix-Linux-file-management/#more" class="btn btn-default more">Read More</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="写在前面-序"><a href="#写在前面-序" class="headerlink" title="写在前面(序)"></a>写在前面(序)</h2><blockquote>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0-一点历史"><a href="#0-一点历史" class="headerlink" title="0 .一点历史"></a>0 .一点历史</h3><blockquote>
<p>还是从一点历史引入，感觉了解一些历史缘由，会更好地理解采用某种特定实现技术的原因</p>
<p>看了一点《The art of Unix Programming》 序中有一句话挺吸引我</p>
<p><em>Unix is not so much an operating system as an oral history.  —-Neal Stephenson</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-&gt;(早期)批处理OS</span><br><span class="line">-&gt;(1960)MIT分时OS:多终端+大型机</span><br><span class="line">-&gt;(1965)AT&amp;T:Bell+MIT+GE(通用电气):Multics计划(全面通用分时OS:bye)</span><br><span class="line">-&gt;(1969)Bell认为该计划GG,退出 (不算失败，有些成果) ：Ken Thompson 写了 Space Travle, PDP-7小型机移植，对它重写OS内核并移植 称Unics</span><br><span class="line">-&gt;Unics(核心哲学:一切皆文件, 程序的目的只有一个-有效的完成目标 : 与Multics理念不同《The Art of Unix Programming》)</span><br><span class="line">-&gt;(1969)Linus Torvalds 在芬兰诞生</span><br><span class="line">-&gt;尝试用高级语言解决移植问题BCPL, PASCAL-&gt;编译出的内核性能不够好-&gt;根据BCPL发明C</span><br><span class="line">-&gt;(1973)Deneish Richie(C的主要发明者)用C重写了Unics系统(提供了管道等重要功能),更名为Unix</span><br><span class="line">-&gt;(1977)AT&amp;T将Unix源代码(用C写的,高可移植性)发给学术界-&gt;UC Berkeley-&gt;Bill Joy professor 编译成适合自己机器的系统，增减一些功能:命名为BSD(Berkeley Software Distribution)</span><br><span class="line">-&gt;(1979)AT&amp;T:推出System V(five(Sun - Solaris)):第七版(不再开源:商业纠纷开始):特性:可以支持x86架构的个人计算机</span><br><span class="line">-&gt;(1984)不再开源对教授OS的professor产生了影响:Andrew TannenBaum-&gt;自己写个Mini Unix -&gt; Minix</span><br><span class="line">-&gt;(1986)完成Minix, 并出版《Operating System : Design and Implementation》附带Minix的源代码</span><br><span class="line">        《Modern Operating System》也是他写的</span><br><span class="line">-&gt;同期 Richard Stallman 发起了GNU计划:GNU:Gnu is not Unix!(GCC, Emacs, Bash Shell, GDB...)目标创建一套完全自由的Unix OS(当时的Unix与硬件捆绑销售)但是缺少Unix内核</span><br><span class="line">-&gt;草拟 GPL协议(General Publilc License | 🙂 copyleft &lt;!-&gt; copyright:著作权) 开源 != 免费(维护可以收费)</span><br><span class="line">-&gt;(1988)IEEE:POSIX标准(旨在:保证各个OS间的兼容性) (IEEE-IX-&gt;POSIX:Portable Operating System Interface X:(Unix))可移植...</span><br><span class="line">-&gt;(1993)Linus:宏内核构造的Linux内核面世</span><br></pre></td></tr></table></figure>

<h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><blockquote>
<p>感觉之前学过很多次，并且每次学习也有用纸质或者文档记录，博客记录学到，使用过的命令，但大多情况学过不用就忘了，不是长久之计，这次就不记录这些。尽量多用以熟练。同时，本文的侧重点不在使用这方面，想要更深入的学习一些东西。</p>
</blockquote>
<blockquote>
<p>如果有不会的熟练使用 <code>$man</code></p>
<p>一点准备工作，环境使用的Ubuntu18.04 帮助手册不全<code>sudo apt install manpages-posix-dev</code></p>
</blockquote>
<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2.架构"></a>2.架构</h3>
	
	</div>
  <a type="button" href="/2022/02/26/6.Unix-Linux-file-management/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
           <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
        

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/2/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
		
			
	<div class="widget">
		<h4>Tag Cloud</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/C-C/">C/C++<span>2</span></a></li>
		
			<li><a href="/tags/Proj/">Proj<span>2</span></a></li>
		
			<li><a href="/tags/database/">database<span>1</span></a></li>
		
			<li><a href="/tags/Unix-Linux/">Unix/Linux<span>5</span></a></li>
		
			<li><a href="/tags/UNIX-APUE/">UNIX APUE<span>1</span></a></li>
		
			<li><a href="/tags/xxxx/">xxxx<span>4</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2022/04/24/12-regex/" ><i class="fa fa-file-o"></i>12.regex</a>
      </li>
    
      <li>
        <a href="/2022/03/26/Unix-Linux-proj-netDsic-II/" ><i class="fa fa-file-o"></i>Unix-Linux-proj-netDsic-II</a>
      </li>
    
      <li>
        <a href="/2022/03/14/database/" ><i class="fa fa-file-o"></i>database</a>
      </li>
    
      <li>
        <a href="/2022/03/14/11.Unix-Linux-NetworkProgramming-II/" ><i class="fa fa-file-o"></i>Unix-Linux-NetworkProgrammi...</a>
      </li>
    
      <li>
        <a href="/2022/03/14/Unix-Linux-proj-netdisc/" ><i class="fa fa-file-o"></i>netdisk</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/lacsscal" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2022 chen's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
